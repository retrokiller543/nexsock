#![feature(prelude_import)]
#[macro_use]
extern crate std;
#[prelude_import]
use std::prelude::rust_2021::*;
pub mod commands {
    pub mod add_service {
        use crate::commands::config::ServiceConfigPayload;
        use crate::service_command;
        use bincode::{Decode, Encode};
        use serde::{Deserialize, Serialize};
        pub struct AddServicePayload {
            pub name: String,
            pub repo_url: String,
            pub port: i64,
            pub repo_path: String,
            #[serde(skip_serializing_if = "Option::is_none")]
            pub config: Option<ServiceConfigPayload>,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for AddServicePayload {
            #[inline]
            fn clone(&self) -> AddServicePayload {
                AddServicePayload {
                    name: ::core::clone::Clone::clone(&self.name),
                    repo_url: ::core::clone::Clone::clone(&self.repo_url),
                    port: ::core::clone::Clone::clone(&self.port),
                    repo_path: ::core::clone::Clone::clone(&self.repo_path),
                    config: ::core::clone::Clone::clone(&self.config),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for AddServicePayload {
            #[inline]
            fn default() -> AddServicePayload {
                AddServicePayload {
                    name: ::core::default::Default::default(),
                    repo_url: ::core::default::Default::default(),
                    port: ::core::default::Default::default(),
                    repo_path: ::core::default::Default::default(),
                    config: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for AddServicePayload {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field5_finish(
                    f,
                    "AddServicePayload",
                    "name",
                    &self.name,
                    "repo_url",
                    &self.repo_url,
                    "port",
                    &self.port,
                    "repo_path",
                    &self.repo_path,
                    "config",
                    &&self.config,
                )
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Ord for AddServicePayload {
            #[inline]
            fn cmp(&self, other: &AddServicePayload) -> ::core::cmp::Ordering {
                match ::core::cmp::Ord::cmp(&self.name, &other.name) {
                    ::core::cmp::Ordering::Equal => {
                        match ::core::cmp::Ord::cmp(&self.repo_url, &other.repo_url) {
                            ::core::cmp::Ordering::Equal => {
                                match ::core::cmp::Ord::cmp(&self.port, &other.port) {
                                    ::core::cmp::Ordering::Equal => {
                                        match ::core::cmp::Ord::cmp(
                                            &self.repo_path,
                                            &other.repo_path,
                                        ) {
                                            ::core::cmp::Ordering::Equal => {
                                                ::core::cmp::Ord::cmp(&self.config, &other.config)
                                            }
                                            cmp => cmp,
                                        }
                                    }
                                    cmp => cmp,
                                }
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
        }
        #[automatically_derived]
        impl ::core::cmp::PartialOrd for AddServicePayload {
            #[inline]
            fn partial_cmp(
                &self,
                other: &AddServicePayload,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                match ::core::cmp::PartialOrd::partial_cmp(&self.name, &other.name) {
                    ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                        match ::core::cmp::PartialOrd::partial_cmp(&self.repo_url, &other.repo_url)
                        {
                            ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                                match ::core::cmp::PartialOrd::partial_cmp(&self.port, &other.port)
                                {
                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                                        match ::core::cmp::PartialOrd::partial_cmp(
                                            &self.repo_path,
                                            &other.repo_path,
                                        ) {
                                            ::core::option::Option::Some(
                                                ::core::cmp::Ordering::Equal,
                                            ) => ::core::cmp::PartialOrd::partial_cmp(
                                                &self.config,
                                                &other.config,
                                            ),
                                            cmp => cmp,
                                        }
                                    }
                                    cmp => cmp,
                                }
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for AddServicePayload {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for AddServicePayload {
            #[inline]
            fn eq(&self, other: &AddServicePayload) -> bool {
                self.name == other.name
                    && self.repo_url == other.repo_url
                    && self.port == other.port
                    && self.repo_path == other.repo_path
                    && self.config == other.config
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for AddServicePayload {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<String>;
                let _: ::core::cmp::AssertParamIsEq<i64>;
                let _: ::core::cmp::AssertParamIsEq<Option<ServiceConfigPayload>>;
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for AddServicePayload {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.name, state);
                ::core::hash::Hash::hash(&self.repo_url, state);
                ::core::hash::Hash::hash(&self.port, state);
                ::core::hash::Hash::hash(&self.repo_path, state);
                ::core::hash::Hash::hash(&self.config, state)
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for AddServicePayload {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "AddServicePayload",
                        false as usize
                            + 1
                            + 1
                            + 1
                            + 1
                            + if Option::is_none(&self.config) { 0 } else { 1 },
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "name",
                        &self.name,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "repo_url",
                        &self.repo_url,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "port",
                        &self.port,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "repo_path",
                        &self.repo_path,
                    )?;
                    if !Option::is_none(&self.config) {
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "config",
                            &self.config,
                        )?;
                    } else {
                        _serde::ser::SerializeStruct::skip_field(&mut __serde_state, "config")?;
                    }
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for AddServicePayload {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __field4,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                4u64 => _serde::__private::Ok(__Field::__field4),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "name" => _serde::__private::Ok(__Field::__field0),
                                "repo_url" => _serde::__private::Ok(__Field::__field1),
                                "port" => _serde::__private::Ok(__Field::__field2),
                                "repo_path" => _serde::__private::Ok(__Field::__field3),
                                "config" => _serde::__private::Ok(__Field::__field4),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"name" => _serde::__private::Ok(__Field::__field0),
                                b"repo_url" => _serde::__private::Ok(__Field::__field1),
                                b"port" => _serde::__private::Ok(__Field::__field2),
                                b"repo_path" => _serde::__private::Ok(__Field::__field3),
                                b"config" => _serde::__private::Ok(__Field::__field4),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<AddServicePayload>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = AddServicePayload;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct AddServicePayload",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 =
                                match _serde::de::SeqAccess::next_element::<String>(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct AddServicePayload with 5 elements",
                                            ),
                                        );
                                    }
                                };
                            let __field1 =
                                match _serde::de::SeqAccess::next_element::<String>(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct AddServicePayload with 5 elements",
                                            ),
                                        );
                                    }
                                };
                            let __field2 =
                                match _serde::de::SeqAccess::next_element::<i64>(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                2usize,
                                                &"struct AddServicePayload with 5 elements",
                                            ),
                                        );
                                    }
                                };
                            let __field3 =
                                match _serde::de::SeqAccess::next_element::<String>(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                3usize,
                                                &"struct AddServicePayload with 5 elements",
                                            ),
                                        );
                                    }
                                };
                            let __field4 = match _serde::de::SeqAccess::next_element::<
                                Option<ServiceConfigPayload>,
                            >(&mut __seq)?
                            {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            4usize,
                                            &"struct AddServicePayload with 5 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(AddServicePayload {
                                name: __field0,
                                repo_url: __field1,
                                port: __field2,
                                repo_path: __field3,
                                config: __field4,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> =
                                _serde::__private::None;
                            let mut __field1: _serde::__private::Option<String> =
                                _serde::__private::None;
                            let mut __field2: _serde::__private::Option<i64> =
                                _serde::__private::None;
                            let mut __field3: _serde::__private::Option<String> =
                                _serde::__private::None;
                            let mut __field4: _serde::__private::Option<
                                Option<ServiceConfigPayload>,
                            > = _serde::__private::None;
                            while let _serde::__private::Some(__key) =
                                _serde::de::MapAccess::next_key::<__Field>(&mut __map)?
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "name",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(
                                                &mut __map,
                                            )?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "repo_url",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(
                                                &mut __map,
                                            )?,
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "port",
                                                ),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field3 => {
                                        if _serde::__private::Option::is_some(&__field3) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "repo_path",
                                                ),
                                            );
                                        }
                                        __field3 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(
                                                &mut __map,
                                            )?,
                                        );
                                    }
                                    __Field::__field4 => {
                                        if _serde::__private::Option::is_some(&__field4) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "config",
                                                ),
                                            );
                                        }
                                        __field4 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Option<ServiceConfigPayload>,
                                            >(
                                                &mut __map
                                            )?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        )?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("name")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("repo_url")?
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("port")?
                                }
                            };
                            let __field3 = match __field3 {
                                _serde::__private::Some(__field3) => __field3,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("repo_path")?
                                }
                            };
                            let __field4 = match __field4 {
                                _serde::__private::Some(__field4) => __field4,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("config")?
                                }
                            };
                            _serde::__private::Ok(AddServicePayload {
                                name: __field0,
                                repo_url: __field1,
                                port: __field2,
                                repo_path: __field3,
                                config: __field4,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] =
                        &["name", "repo_url", "port", "repo_path", "config"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "AddServicePayload",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<AddServicePayload>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        impl ::bincode::Encode for AddServicePayload {
            fn encode<__E: ::bincode::enc::Encoder>(
                &self,
                encoder: &mut __E,
            ) -> core::result::Result<(), ::bincode::error::EncodeError> {
                ::bincode::Encode::encode(&self.name, encoder)?;
                ::bincode::Encode::encode(&self.repo_url, encoder)?;
                ::bincode::Encode::encode(&self.port, encoder)?;
                ::bincode::Encode::encode(&self.repo_path, encoder)?;
                ::bincode::Encode::encode(&self.config, encoder)?;
                Ok(())
            }
        }
        impl ::bincode::Decode for AddServicePayload {
            fn decode<__D: ::bincode::de::Decoder>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, ::bincode::error::DecodeError> {
                Ok(Self {
                    name: ::bincode::Decode::decode(decoder)?,
                    repo_url: ::bincode::Decode::decode(decoder)?,
                    port: ::bincode::Decode::decode(decoder)?,
                    repo_path: ::bincode::Decode::decode(decoder)?,
                    config: ::bincode::Decode::decode(decoder)?,
                })
            }
        }
        impl<'__de> ::bincode::BorrowDecode<'__de> for AddServicePayload {
            fn borrow_decode<__D: ::bincode::de::BorrowDecoder<'__de>>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, ::bincode::error::DecodeError> {
                Ok(Self {
                    name: ::bincode::BorrowDecode::borrow_decode(decoder)?,
                    repo_url: ::bincode::BorrowDecode::borrow_decode(decoder)?,
                    port: ::bincode::BorrowDecode::borrow_decode(decoder)?,
                    repo_path: ::bincode::BorrowDecode::borrow_decode(decoder)?,
                    config: ::bincode::BorrowDecode::borrow_decode(decoder)?,
                })
            }
        }
        pub struct AddServiceCommand {
            name: String,
            repo_url: String,
            port: i64,
            repo_path: String,
            config: Option<ServiceConfigPayload>,
        }
        impl AddServiceCommand {
            pub fn new(
                name: impl Into<String>,
                repo_url: impl Into<String>,
                port: impl Into<i64>,
                repo_path: impl Into<String>,
                config: impl Into<Option<ServiceConfigPayload>>,
            ) -> Self {
                let name = name.into();
                let repo_url = repo_url.into();
                let port = port.into();
                let repo_path = repo_path.into();
                let config = config.into();
                Self {
                    name,
                    repo_url,
                    port,
                    repo_path,
                    config,
                }
            }
        }
        impl From<AddServiceCommand> for <AddServiceCommand as crate::traits::ServiceCommand>::Input {
            fn from(command: AddServiceCommand) -> Self {
                use crate::traits::ServiceCommand;
                command.into_payload()
            }
        }
        impl crate::traits::ServiceCommand for AddServiceCommand {
            type Input = AddServicePayload;
            type Output = ();
            const COMMAND: crate::commands::Command = crate::commands::Command::AddService;
            fn into_payload(self) -> Self::Input {
                Self::Input {
                    name: self.name,
                    repo_url: self.repo_url,
                    port: self.port,
                    repo_path: self.repo_path,
                    config: self.config,
                }
            }
        }
        impl From<AddServicePayload> for AddServiceCommand {
            fn from(input: AddServicePayload) -> Self {
                Self {
                    name: input.name,
                    repo_url: input.repo_url,
                    port: input.port,
                    repo_path: input.repo_path,
                    config: input.config,
                }
            }
        }
    }
    pub mod config {
        use crate::commands::manage_service::ServiceRef;
        use crate::commands::CommandPayload;
        use crate::{service_command, try_from};
        use bincode::{Decode, Encode};
        use serde::{Deserialize, Serialize};
        use sqlx::Type;
        pub struct GetConfig(ServiceRef);
        impl GetConfig {
            pub fn new(input: impl Into<ServiceRef>) -> Self {
                Self(input.into())
            }
        }
        impl crate::traits::ServiceCommand for GetConfig {
            type Input = ServiceRef;
            type Output = ServiceConfigPayload;
            const COMMAND: crate::commands::Command = crate::commands::Command::GetConfig;
            fn into_payload(self) -> Self::Input {
                self.0
            }
        }
        impl From<GetConfig> for <GetConfig as crate::traits::ServiceCommand>::Input {
            fn from(command: GetConfig) -> Self {
                use crate::traits::ServiceCommand;
                command.into_payload()
            }
        }
        impl From<ServiceRef> for GetConfig {
            fn from(input: ServiceRef) -> Self {
                Self::new(input)
            }
        }
        pub struct UpdateConfigCommand {
            service: ServiceRef,
            filename: String,
            format: ConfigFormat,
            run_command: String,
        }
        impl UpdateConfigCommand {
            pub fn new(
                service: impl Into<ServiceRef>,
                filename: impl Into<String>,
                format: impl Into<ConfigFormat>,
                run_command: impl Into<String>,
            ) -> Self {
                let service = service.into();
                let filename = filename.into();
                let format = format.into();
                let run_command = run_command.into();
                Self {
                    service,
                    filename,
                    format,
                    run_command,
                }
            }
        }
        impl From<UpdateConfigCommand> for <UpdateConfigCommand as crate::traits::ServiceCommand>::Input {
            fn from(command: UpdateConfigCommand) -> Self {
                use crate::traits::ServiceCommand;
                command.into_payload()
            }
        }
        impl crate::traits::ServiceCommand for UpdateConfigCommand {
            type Input = ServiceConfigPayload;
            type Output = ();
            const COMMAND: crate::commands::Command = crate::commands::Command::UpdateConfig;
            fn into_payload(self) -> Self::Input {
                Self::Input {
                    service: self.service,
                    filename: self.filename,
                    format: self.format,
                    run_command: self.run_command,
                }
            }
        }
        impl From<ServiceConfigPayload> for UpdateConfigCommand {
            fn from(input: ServiceConfigPayload) -> Self {
                Self {
                    service: input.service,
                    filename: input.filename,
                    format: input.format,
                    run_command: input.run_command,
                }
            }
        }
        pub struct ServiceConfigPayload {
            pub service: ServiceRef,
            pub filename: String,
            pub format: ConfigFormat,
            pub run_command: String,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for ServiceConfigPayload {
            #[inline]
            fn clone(&self) -> ServiceConfigPayload {
                ServiceConfigPayload {
                    service: ::core::clone::Clone::clone(&self.service),
                    filename: ::core::clone::Clone::clone(&self.filename),
                    format: ::core::clone::Clone::clone(&self.format),
                    run_command: ::core::clone::Clone::clone(&self.run_command),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for ServiceConfigPayload {
            #[inline]
            fn default() -> ServiceConfigPayload {
                ServiceConfigPayload {
                    service: ::core::default::Default::default(),
                    filename: ::core::default::Default::default(),
                    format: ::core::default::Default::default(),
                    run_command: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for ServiceConfigPayload {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field4_finish(
                    f,
                    "ServiceConfigPayload",
                    "service",
                    &self.service,
                    "filename",
                    &self.filename,
                    "format",
                    &self.format,
                    "run_command",
                    &&self.run_command,
                )
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Ord for ServiceConfigPayload {
            #[inline]
            fn cmp(&self, other: &ServiceConfigPayload) -> ::core::cmp::Ordering {
                match ::core::cmp::Ord::cmp(&self.service, &other.service) {
                    ::core::cmp::Ordering::Equal => {
                        match ::core::cmp::Ord::cmp(&self.filename, &other.filename) {
                            ::core::cmp::Ordering::Equal => {
                                match ::core::cmp::Ord::cmp(&self.format, &other.format) {
                                    ::core::cmp::Ordering::Equal => {
                                        ::core::cmp::Ord::cmp(&self.run_command, &other.run_command)
                                    }
                                    cmp => cmp,
                                }
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
        }
        #[automatically_derived]
        impl ::core::cmp::PartialOrd for ServiceConfigPayload {
            #[inline]
            fn partial_cmp(
                &self,
                other: &ServiceConfigPayload,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                match ::core::cmp::PartialOrd::partial_cmp(&self.service, &other.service) {
                    ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                        match ::core::cmp::PartialOrd::partial_cmp(&self.filename, &other.filename)
                        {
                            ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                                match ::core::cmp::PartialOrd::partial_cmp(
                                    &self.format,
                                    &other.format,
                                ) {
                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                                        ::core::cmp::PartialOrd::partial_cmp(
                                            &self.run_command,
                                            &other.run_command,
                                        )
                                    }
                                    cmp => cmp,
                                }
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for ServiceConfigPayload {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for ServiceConfigPayload {
            #[inline]
            fn eq(&self, other: &ServiceConfigPayload) -> bool {
                self.service == other.service
                    && self.filename == other.filename
                    && self.format == other.format
                    && self.run_command == other.run_command
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for ServiceConfigPayload {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<ServiceRef>;
                let _: ::core::cmp::AssertParamIsEq<String>;
                let _: ::core::cmp::AssertParamIsEq<ConfigFormat>;
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for ServiceConfigPayload {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.service, state);
                ::core::hash::Hash::hash(&self.filename, state);
                ::core::hash::Hash::hash(&self.format, state);
                ::core::hash::Hash::hash(&self.run_command, state)
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for ServiceConfigPayload {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "ServiceConfigPayload",
                        false as usize + 1 + 1 + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "service",
                        &self.service,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "filename",
                        &self.filename,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "format",
                        &self.format,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "run_command",
                        &self.run_command,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for ServiceConfigPayload {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "service" => _serde::__private::Ok(__Field::__field0),
                                "filename" => _serde::__private::Ok(__Field::__field1),
                                "format" => _serde::__private::Ok(__Field::__field2),
                                "run_command" => _serde::__private::Ok(__Field::__field3),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"service" => _serde::__private::Ok(__Field::__field0),
                                b"filename" => _serde::__private::Ok(__Field::__field1),
                                b"format" => _serde::__private::Ok(__Field::__field2),
                                b"run_command" => _serde::__private::Ok(__Field::__field3),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<ServiceConfigPayload>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = ServiceConfigPayload;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct ServiceConfigPayload",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<ServiceRef>(
                                &mut __seq,
                            )? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct ServiceConfigPayload with 4 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 =
                                match _serde::de::SeqAccess::next_element::<String>(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct ServiceConfigPayload with 4 elements",
                                            ),
                                        );
                                    }
                                };
                            let __field2 = match _serde::de::SeqAccess::next_element::<ConfigFormat>(
                                &mut __seq,
                            )? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct ServiceConfigPayload with 4 elements",
                                        ),
                                    );
                                }
                            };
                            let __field3 =
                                match _serde::de::SeqAccess::next_element::<String>(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                3usize,
                                                &"struct ServiceConfigPayload with 4 elements",
                                            ),
                                        );
                                    }
                                };
                            _serde::__private::Ok(ServiceConfigPayload {
                                service: __field0,
                                filename: __field1,
                                format: __field2,
                                run_command: __field3,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<ServiceRef> =
                                _serde::__private::None;
                            let mut __field1: _serde::__private::Option<String> =
                                _serde::__private::None;
                            let mut __field2: _serde::__private::Option<ConfigFormat> =
                                _serde::__private::None;
                            let mut __field3: _serde::__private::Option<String> =
                                _serde::__private::None;
                            while let _serde::__private::Some(__key) =
                                _serde::de::MapAccess::next_key::<__Field>(&mut __map)?
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "service",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<ServiceRef>(
                                                &mut __map,
                                            )?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "filename",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(
                                                &mut __map,
                                            )?,
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "format",
                                                ),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<ConfigFormat>(
                                                &mut __map,
                                            )?,
                                        );
                                    }
                                    __Field::__field3 => {
                                        if _serde::__private::Option::is_some(&__field3) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "run_command",
                                                ),
                                            );
                                        }
                                        __field3 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(
                                                &mut __map,
                                            )?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        )?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("service")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("filename")?
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("format")?
                                }
                            };
                            let __field3 = match __field3 {
                                _serde::__private::Some(__field3) => __field3,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("run_command")?
                                }
                            };
                            _serde::__private::Ok(ServiceConfigPayload {
                                service: __field0,
                                filename: __field1,
                                format: __field2,
                                run_command: __field3,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] =
                        &["service", "filename", "format", "run_command"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "ServiceConfigPayload",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<ServiceConfigPayload>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        impl ::bincode::Encode for ServiceConfigPayload {
            fn encode<__E: ::bincode::enc::Encoder>(
                &self,
                encoder: &mut __E,
            ) -> core::result::Result<(), ::bincode::error::EncodeError> {
                ::bincode::Encode::encode(&self.service, encoder)?;
                ::bincode::Encode::encode(&self.filename, encoder)?;
                ::bincode::Encode::encode(&self.format, encoder)?;
                ::bincode::Encode::encode(&self.run_command, encoder)?;
                Ok(())
            }
        }
        impl ::bincode::Decode for ServiceConfigPayload {
            fn decode<__D: ::bincode::de::Decoder>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, ::bincode::error::DecodeError> {
                Ok(Self {
                    service: ::bincode::Decode::decode(decoder)?,
                    filename: ::bincode::Decode::decode(decoder)?,
                    format: ::bincode::Decode::decode(decoder)?,
                    run_command: ::bincode::Decode::decode(decoder)?,
                })
            }
        }
        impl<'__de> ::bincode::BorrowDecode<'__de> for ServiceConfigPayload {
            fn borrow_decode<__D: ::bincode::de::BorrowDecoder<'__de>>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, ::bincode::error::DecodeError> {
                Ok(Self {
                    service: ::bincode::BorrowDecode::borrow_decode(decoder)?,
                    filename: ::bincode::BorrowDecode::borrow_decode(decoder)?,
                    format: ::bincode::BorrowDecode::borrow_decode(decoder)?,
                    run_command: ::bincode::BorrowDecode::borrow_decode(decoder)?,
                })
            }
        }
        impl TryFrom<CommandPayload> for ServiceConfigPayload {
            type Error = ::anyhow::Error;
            fn try_from(value: CommandPayload) -> Result<Self, Self::Error> {
                #[allow(unused_imports)]
                use crate::commands::CommandPayload::ServiceConfig;
                if !value.is_service_config() {
                    return ::anyhow::__private::Err(::anyhow::Error::msg(
                        ::alloc::__export::must_use({
                            let res = ::alloc::fmt::format(format_args!(
                                "Command is not of type `{0}`",
                                "ServiceConfig",
                            ));
                            res
                        }),
                    ));
                }
                Ok(value.unwrap_service_config())
            }
        }
        #[serde(rename_all = "lowercase")]
        pub enum ConfigFormat {
            #[default]
            Env,
            Properties,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for ConfigFormat {
            #[inline]
            fn clone(&self) -> ConfigFormat {
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for ConfigFormat {}
        #[automatically_derived]
        impl ::core::default::Default for ConfigFormat {
            #[inline]
            fn default() -> ConfigFormat {
                Self::Env
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for ConfigFormat {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        ConfigFormat::Env => "Env",
                        ConfigFormat::Properties => "Properties",
                    },
                )
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Ord for ConfigFormat {
            #[inline]
            fn cmp(&self, other: &ConfigFormat) -> ::core::cmp::Ordering {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                ::core::cmp::Ord::cmp(&__self_discr, &__arg1_discr)
            }
        }
        #[automatically_derived]
        impl ::core::cmp::PartialOrd for ConfigFormat {
            #[inline]
            fn partial_cmp(
                &self,
                other: &ConfigFormat,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                ::core::cmp::PartialOrd::partial_cmp(&__self_discr, &__arg1_discr)
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for ConfigFormat {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for ConfigFormat {
            #[inline]
            fn eq(&self, other: &ConfigFormat) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for ConfigFormat {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {}
        }
        #[automatically_derived]
        impl ::core::hash::Hash for ConfigFormat {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                ::core::hash::Hash::hash(&__self_discr, state)
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for ConfigFormat {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        ConfigFormat::Env => _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "ConfigFormat",
                            0u32,
                            "env",
                        ),
                        ConfigFormat::Properties => _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "ConfigFormat",
                            1u32,
                            "properties",
                        ),
                    }
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for ConfigFormat {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Err(_serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"variant index 0 <= i < 2",
                                )),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "env" => _serde::__private::Ok(__Field::__field0),
                                "properties" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                )),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"env" => _serde::__private::Ok(__Field::__field0),
                                b"properties" => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(_serde::de::Error::unknown_variant(
                                        __value, VARIANTS,
                                    ))
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<ConfigFormat>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = ConfigFormat;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum ConfigFormat",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match _serde::de::EnumAccess::variant(__data)? {
                                (__Field::__field0, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(ConfigFormat::Env)
                                }
                                (__Field::__field1, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(ConfigFormat::Properties)
                                }
                            }
                        }
                    }
                    #[doc(hidden)]
                    const VARIANTS: &'static [&'static str] = &["env", "properties"];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "ConfigFormat",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<ConfigFormat>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        impl<'q, DB: ::sqlx::Database> ::sqlx::encode::Encode<'q, DB> for ConfigFormat
        where
            &'q ::std::primitive::str: ::sqlx::encode::Encode<'q, DB>,
        {
            fn encode_by_ref(
                &self,
                buf: &mut <DB as ::sqlx::database::Database>::ArgumentBuffer<'q>,
            ) -> ::std::result::Result<::sqlx::encode::IsNull, ::sqlx::error::BoxDynError>
            {
                let val = match self {
                    ConfigFormat::Env => "Env",
                    ConfigFormat::Properties => "Properties",
                };
                <&::std::primitive::str as ::sqlx::encode::Encode<'q, DB>>::encode(val, buf)
            }
            fn size_hint(&self) -> ::std::primitive::usize {
                let val = match self {
                    ConfigFormat::Env => "Env",
                    ConfigFormat::Properties => "Properties",
                };
                <&::std::primitive::str as ::sqlx::encode::Encode<'q, DB>>::size_hint(&val)
            }
        }
        #[automatically_derived]
        impl<'r> ::sqlx::decode::Decode<'r, ::sqlx::sqlite::Sqlite> for ConfigFormat {
            fn decode(
                value: ::sqlx::sqlite::SqliteValueRef<'r>,
            ) -> ::std::result::Result<
                Self,
                ::std::boxed::Box<
                    dyn ::std::error::Error + 'static + ::std::marker::Send + ::std::marker::Sync,
                >,
            > {
                let value = <&'r ::std::primitive::str as ::sqlx::decode::Decode<
                    'r,
                    ::sqlx::sqlite::Sqlite,
                >>::decode(value)?;
                match value {
                    "Env" => ::std::result::Result::Ok(ConfigFormat::Env),
                    "Properties" => ::std::result::Result::Ok(ConfigFormat::Properties),
                    _ => Err(::alloc::__export::must_use({
                        let res = ::alloc::fmt::format(format_args!(
                            "invalid value {0:?} for enum {1}",
                            value, "ConfigFormat",
                        ));
                        res
                    })
                    .into()),
                }
            }
        }
        #[automatically_derived]
        impl sqlx::Type<::sqlx::Sqlite> for ConfigFormat {
            fn type_info() -> ::sqlx::sqlite::SqliteTypeInfo {
                <::std::primitive::str as ::sqlx::Type<sqlx::Sqlite>>::type_info()
            }
            fn compatible(ty: &::sqlx::sqlite::SqliteTypeInfo) -> ::std::primitive::bool {
                <&::std::primitive::str as ::sqlx::types::Type<sqlx::sqlite::Sqlite>>::compatible(
                    ty,
                )
            }
        }
        impl ::bincode::Encode for ConfigFormat {
            fn encode<__E: ::bincode::enc::Encoder>(
                &self,
                encoder: &mut __E,
            ) -> core::result::Result<(), ::bincode::error::EncodeError> {
                match self {
                    Self::Env => {
                        <u32 as ::bincode::Encode>::encode(&(0u32), encoder)?;
                        Ok(())
                    }
                    Self::Properties => {
                        <u32 as ::bincode::Encode>::encode(&(1u32), encoder)?;
                        Ok(())
                    }
                }
            }
        }
        impl ::bincode::Decode for ConfigFormat {
            fn decode<__D: ::bincode::de::Decoder>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, ::bincode::error::DecodeError> {
                let variant_index = <u32 as ::bincode::Decode>::decode(decoder)?;
                match variant_index {
                    0u32 => Ok(Self::Env {}),
                    1u32 => Ok(Self::Properties {}),
                    variant => Err(::bincode::error::DecodeError::UnexpectedVariant {
                        found: variant,
                        type_name: "ConfigFormat",
                        allowed: &::bincode::error::AllowedEnumVariants::Range { min: 0, max: 1 },
                    }),
                }
            }
        }
        impl<'__de> ::bincode::BorrowDecode<'__de> for ConfigFormat {
            fn borrow_decode<__D: ::bincode::de::BorrowDecoder<'__de>>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, ::bincode::error::DecodeError> {
                let variant_index = <u32 as ::bincode::Decode>::decode(decoder)?;
                match variant_index {
                    0u32 => Ok(Self::Env {}),
                    1u32 => Ok(Self::Properties {}),
                    variant => Err(::bincode::error::DecodeError::UnexpectedVariant {
                        found: variant,
                        type_name: "ConfigFormat",
                        allowed: &::bincode::error::AllowedEnumVariants::Range { min: 0, max: 1 },
                    }),
                }
            }
        }
        impl From<String> for ConfigFormat {
            fn from(value: String) -> Self {
                match value.as_str() {
                    "Env" => Self::Env,
                    "Properties" => Self::Properties,
                    _ => Self::Env,
                }
            }
        }
        impl From<Option<String>> for ConfigFormat {
            fn from(value: Option<String>) -> Self {
                if let Some(val) = value {
                    val.into()
                } else {
                    Self::Env
                }
            }
        }
    }
    pub mod dependency {
        use crate::commands::dependency_info::DependencyInfo;
        use crate::commands::manage_service::ServiceRef;
        use crate::commands::CommandPayload;
        use crate::{service_command, try_from};
        use bincode::{Decode, Encode};
        use serde::{Deserialize, Serialize};
        pub struct AddDependencyCommand {
            service: ServiceRef,
            dependent_service: ServiceRef,
            tunnel_enabled: bool,
        }
        impl AddDependencyCommand {
            pub fn new(
                service: impl Into<ServiceRef>,
                dependent_service: impl Into<ServiceRef>,
                tunnel_enabled: impl Into<bool>,
            ) -> Self {
                let service = service.into();
                let dependent_service = dependent_service.into();
                let tunnel_enabled = tunnel_enabled.into();
                Self {
                    service,
                    dependent_service,
                    tunnel_enabled,
                }
            }
        }
        impl From<AddDependencyCommand> for <AddDependencyCommand as crate::traits::ServiceCommand>::Input {
            fn from(command: AddDependencyCommand) -> Self {
                use crate::traits::ServiceCommand;
                command.into_payload()
            }
        }
        impl crate::traits::ServiceCommand for AddDependencyCommand {
            type Input = AddDependencyPayload;
            type Output = ();
            const COMMAND: crate::commands::Command = crate::commands::Command::AddDependency;
            fn into_payload(self) -> Self::Input {
                Self::Input {
                    service: self.service,
                    dependent_service: self.dependent_service,
                    tunnel_enabled: self.tunnel_enabled,
                }
            }
        }
        impl From<AddDependencyPayload> for AddDependencyCommand {
            fn from(input: AddDependencyPayload) -> Self {
                Self {
                    service: input.service,
                    dependent_service: input.dependent_service,
                    tunnel_enabled: input.tunnel_enabled,
                }
            }
        }
        pub struct RemoveDependencyCommand {
            service: ServiceRef,
            dependent_service: ServiceRef,
        }
        impl RemoveDependencyCommand {
            pub fn new(
                service: impl Into<ServiceRef>,
                dependent_service: impl Into<ServiceRef>,
            ) -> Self {
                let service = service.into();
                let dependent_service = dependent_service.into();
                Self {
                    service,
                    dependent_service,
                }
            }
        }
        impl From<RemoveDependencyCommand>
            for <RemoveDependencyCommand as crate::traits::ServiceCommand>::Input
        {
            fn from(command: RemoveDependencyCommand) -> Self {
                use crate::traits::ServiceCommand;
                command.into_payload()
            }
        }
        impl crate::traits::ServiceCommand for RemoveDependencyCommand {
            type Input = RemoveDependencyPayload;
            type Output = ();
            const COMMAND: crate::commands::Command = crate::commands::Command::RemoveDependency;
            fn into_payload(self) -> Self::Input {
                Self::Input {
                    service: self.service,
                    dependent_service: self.dependent_service,
                }
            }
        }
        impl From<RemoveDependencyPayload> for RemoveDependencyCommand {
            fn from(input: RemoveDependencyPayload) -> Self {
                Self {
                    service: input.service,
                    dependent_service: input.dependent_service,
                }
            }
        }
        pub struct ListDependenciesCommand(ServiceRef);
        impl ListDependenciesCommand {
            pub fn new(input: impl Into<ServiceRef>) -> Self {
                Self(input.into())
            }
        }
        impl crate::traits::ServiceCommand for ListDependenciesCommand {
            type Input = ServiceRef;
            type Output = ListDependenciesResponse;
            const COMMAND: crate::commands::Command = crate::commands::Command::ListDependencies;
            fn into_payload(self) -> Self::Input {
                self.0
            }
        }
        impl From<ListDependenciesCommand>
            for <ListDependenciesCommand as crate::traits::ServiceCommand>::Input
        {
            fn from(command: ListDependenciesCommand) -> Self {
                use crate::traits::ServiceCommand;
                command.into_payload()
            }
        }
        impl From<ServiceRef> for ListDependenciesCommand {
            fn from(input: ServiceRef) -> Self {
                Self::new(input)
            }
        }
        impl TryFrom<CommandPayload> for ListDependenciesResponse {
            type Error = ::anyhow::Error;
            fn try_from(value: CommandPayload) -> Result<Self, Self::Error> {
                #[allow(unused_imports)]
                use crate::commands::CommandPayload::Dependencies;
                if !value.is_dependencies() {
                    return ::anyhow::__private::Err(::anyhow::Error::msg(
                        ::alloc::__export::must_use({
                            let res = ::alloc::fmt::format(format_args!(
                                "Command is not of type `{0}`",
                                "Dependencies"
                            ));
                            res
                        }),
                    ));
                }
                Ok(value.unwrap_dependencies())
            }
        }
        pub struct AddDependencyPayload {
            pub service: ServiceRef,
            pub dependent_service: ServiceRef,
            pub tunnel_enabled: bool,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for AddDependencyPayload {
            #[inline]
            fn clone(&self) -> AddDependencyPayload {
                AddDependencyPayload {
                    service: ::core::clone::Clone::clone(&self.service),
                    dependent_service: ::core::clone::Clone::clone(&self.dependent_service),
                    tunnel_enabled: ::core::clone::Clone::clone(&self.tunnel_enabled),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for AddDependencyPayload {
            #[inline]
            fn default() -> AddDependencyPayload {
                AddDependencyPayload {
                    service: ::core::default::Default::default(),
                    dependent_service: ::core::default::Default::default(),
                    tunnel_enabled: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for AddDependencyPayload {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "AddDependencyPayload",
                    "service",
                    &self.service,
                    "dependent_service",
                    &self.dependent_service,
                    "tunnel_enabled",
                    &&self.tunnel_enabled,
                )
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Ord for AddDependencyPayload {
            #[inline]
            fn cmp(&self, other: &AddDependencyPayload) -> ::core::cmp::Ordering {
                match ::core::cmp::Ord::cmp(&self.service, &other.service) {
                    ::core::cmp::Ordering::Equal => {
                        match ::core::cmp::Ord::cmp(
                            &self.dependent_service,
                            &other.dependent_service,
                        ) {
                            ::core::cmp::Ordering::Equal => {
                                ::core::cmp::Ord::cmp(&self.tunnel_enabled, &other.tunnel_enabled)
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
        }
        #[automatically_derived]
        impl ::core::cmp::PartialOrd for AddDependencyPayload {
            #[inline]
            fn partial_cmp(
                &self,
                other: &AddDependencyPayload,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                match ::core::cmp::PartialOrd::partial_cmp(&self.service, &other.service) {
                    ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                        match ::core::cmp::PartialOrd::partial_cmp(
                            &self.dependent_service,
                            &other.dependent_service,
                        ) {
                            ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                                ::core::cmp::PartialOrd::partial_cmp(
                                    &self.tunnel_enabled,
                                    &other.tunnel_enabled,
                                )
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for AddDependencyPayload {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for AddDependencyPayload {
            #[inline]
            fn eq(&self, other: &AddDependencyPayload) -> bool {
                self.service == other.service
                    && self.dependent_service == other.dependent_service
                    && self.tunnel_enabled == other.tunnel_enabled
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for AddDependencyPayload {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<ServiceRef>;
                let _: ::core::cmp::AssertParamIsEq<bool>;
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for AddDependencyPayload {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.service, state);
                ::core::hash::Hash::hash(&self.dependent_service, state);
                ::core::hash::Hash::hash(&self.tunnel_enabled, state)
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for AddDependencyPayload {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "AddDependencyPayload",
                        false as usize + 1 + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "service",
                        &self.service,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "dependent_service",
                        &self.dependent_service,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "tunnel_enabled",
                        &self.tunnel_enabled,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for AddDependencyPayload {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "service" => _serde::__private::Ok(__Field::__field0),
                                "dependent_service" => _serde::__private::Ok(__Field::__field1),
                                "tunnel_enabled" => _serde::__private::Ok(__Field::__field2),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"service" => _serde::__private::Ok(__Field::__field0),
                                b"dependent_service" => _serde::__private::Ok(__Field::__field1),
                                b"tunnel_enabled" => _serde::__private::Ok(__Field::__field2),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<AddDependencyPayload>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = AddDependencyPayload;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct AddDependencyPayload",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<ServiceRef>(
                                &mut __seq,
                            )? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct AddDependencyPayload with 3 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<ServiceRef>(
                                &mut __seq,
                            )? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct AddDependencyPayload with 3 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 =
                                match _serde::de::SeqAccess::next_element::<bool>(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                2usize,
                                                &"struct AddDependencyPayload with 3 elements",
                                            ),
                                        );
                                    }
                                };
                            _serde::__private::Ok(AddDependencyPayload {
                                service: __field0,
                                dependent_service: __field1,
                                tunnel_enabled: __field2,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<ServiceRef> =
                                _serde::__private::None;
                            let mut __field1: _serde::__private::Option<ServiceRef> =
                                _serde::__private::None;
                            let mut __field2: _serde::__private::Option<bool> =
                                _serde::__private::None;
                            while let _serde::__private::Some(__key) =
                                _serde::de::MapAccess::next_key::<__Field>(&mut __map)?
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "service",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<ServiceRef>(
                                                &mut __map,
                                            )?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "dependent_service",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<ServiceRef>(
                                                &mut __map,
                                            )?,
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "tunnel_enabled",
                                                ),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        )?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("service")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("dependent_service")?
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("tunnel_enabled")?
                                }
                            };
                            _serde::__private::Ok(AddDependencyPayload {
                                service: __field0,
                                dependent_service: __field1,
                                tunnel_enabled: __field2,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] =
                        &["service", "dependent_service", "tunnel_enabled"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "AddDependencyPayload",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<AddDependencyPayload>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        impl ::bincode::Encode for AddDependencyPayload {
            fn encode<__E: ::bincode::enc::Encoder>(
                &self,
                encoder: &mut __E,
            ) -> core::result::Result<(), ::bincode::error::EncodeError> {
                ::bincode::Encode::encode(&self.service, encoder)?;
                ::bincode::Encode::encode(&self.dependent_service, encoder)?;
                ::bincode::Encode::encode(&self.tunnel_enabled, encoder)?;
                Ok(())
            }
        }
        impl ::bincode::Decode for AddDependencyPayload {
            fn decode<__D: ::bincode::de::Decoder>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, ::bincode::error::DecodeError> {
                Ok(Self {
                    service: ::bincode::Decode::decode(decoder)?,
                    dependent_service: ::bincode::Decode::decode(decoder)?,
                    tunnel_enabled: ::bincode::Decode::decode(decoder)?,
                })
            }
        }
        impl<'__de> ::bincode::BorrowDecode<'__de> for AddDependencyPayload {
            fn borrow_decode<__D: ::bincode::de::BorrowDecoder<'__de>>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, ::bincode::error::DecodeError> {
                Ok(Self {
                    service: ::bincode::BorrowDecode::borrow_decode(decoder)?,
                    dependent_service: ::bincode::BorrowDecode::borrow_decode(decoder)?,
                    tunnel_enabled: ::bincode::BorrowDecode::borrow_decode(decoder)?,
                })
            }
        }
        pub struct RemoveDependencyPayload {
            pub service: ServiceRef,
            pub dependent_service: ServiceRef,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for RemoveDependencyPayload {
            #[inline]
            fn clone(&self) -> RemoveDependencyPayload {
                RemoveDependencyPayload {
                    service: ::core::clone::Clone::clone(&self.service),
                    dependent_service: ::core::clone::Clone::clone(&self.dependent_service),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for RemoveDependencyPayload {
            #[inline]
            fn default() -> RemoveDependencyPayload {
                RemoveDependencyPayload {
                    service: ::core::default::Default::default(),
                    dependent_service: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for RemoveDependencyPayload {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "RemoveDependencyPayload",
                    "service",
                    &self.service,
                    "dependent_service",
                    &&self.dependent_service,
                )
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Ord for RemoveDependencyPayload {
            #[inline]
            fn cmp(&self, other: &RemoveDependencyPayload) -> ::core::cmp::Ordering {
                match ::core::cmp::Ord::cmp(&self.service, &other.service) {
                    ::core::cmp::Ordering::Equal => {
                        ::core::cmp::Ord::cmp(&self.dependent_service, &other.dependent_service)
                    }
                    cmp => cmp,
                }
            }
        }
        #[automatically_derived]
        impl ::core::cmp::PartialOrd for RemoveDependencyPayload {
            #[inline]
            fn partial_cmp(
                &self,
                other: &RemoveDependencyPayload,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                match ::core::cmp::PartialOrd::partial_cmp(&self.service, &other.service) {
                    ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                        ::core::cmp::PartialOrd::partial_cmp(
                            &self.dependent_service,
                            &other.dependent_service,
                        )
                    }
                    cmp => cmp,
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for RemoveDependencyPayload {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for RemoveDependencyPayload {
            #[inline]
            fn eq(&self, other: &RemoveDependencyPayload) -> bool {
                self.service == other.service && self.dependent_service == other.dependent_service
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for RemoveDependencyPayload {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<ServiceRef>;
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for RemoveDependencyPayload {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.service, state);
                ::core::hash::Hash::hash(&self.dependent_service, state)
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for RemoveDependencyPayload {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "RemoveDependencyPayload",
                        false as usize + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "service",
                        &self.service,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "dependent_service",
                        &self.dependent_service,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for RemoveDependencyPayload {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "service" => _serde::__private::Ok(__Field::__field0),
                                "dependent_service" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"service" => _serde::__private::Ok(__Field::__field0),
                                b"dependent_service" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<RemoveDependencyPayload>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = RemoveDependencyPayload;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct RemoveDependencyPayload",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<ServiceRef>(
                                &mut __seq,
                            )? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct RemoveDependencyPayload with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<ServiceRef>(
                                &mut __seq,
                            )? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct RemoveDependencyPayload with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(RemoveDependencyPayload {
                                service: __field0,
                                dependent_service: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<ServiceRef> =
                                _serde::__private::None;
                            let mut __field1: _serde::__private::Option<ServiceRef> =
                                _serde::__private::None;
                            while let _serde::__private::Some(__key) =
                                _serde::de::MapAccess::next_key::<__Field>(&mut __map)?
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "service",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<ServiceRef>(
                                                &mut __map,
                                            )?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "dependent_service",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<ServiceRef>(
                                                &mut __map,
                                            )?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        )?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("service")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("dependent_service")?
                                }
                            };
                            _serde::__private::Ok(RemoveDependencyPayload {
                                service: __field0,
                                dependent_service: __field1,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["service", "dependent_service"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "RemoveDependencyPayload",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<RemoveDependencyPayload>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        impl ::bincode::Encode for RemoveDependencyPayload {
            fn encode<__E: ::bincode::enc::Encoder>(
                &self,
                encoder: &mut __E,
            ) -> core::result::Result<(), ::bincode::error::EncodeError> {
                ::bincode::Encode::encode(&self.service, encoder)?;
                ::bincode::Encode::encode(&self.dependent_service, encoder)?;
                Ok(())
            }
        }
        impl ::bincode::Decode for RemoveDependencyPayload {
            fn decode<__D: ::bincode::de::Decoder>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, ::bincode::error::DecodeError> {
                Ok(Self {
                    service: ::bincode::Decode::decode(decoder)?,
                    dependent_service: ::bincode::Decode::decode(decoder)?,
                })
            }
        }
        impl<'__de> ::bincode::BorrowDecode<'__de> for RemoveDependencyPayload {
            fn borrow_decode<__D: ::bincode::de::BorrowDecoder<'__de>>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, ::bincode::error::DecodeError> {
                Ok(Self {
                    service: ::bincode::BorrowDecode::borrow_decode(decoder)?,
                    dependent_service: ::bincode::BorrowDecode::borrow_decode(decoder)?,
                })
            }
        }
        pub struct ListDependenciesResponse {
            pub service_name: String,
            pub dependencies: Vec<DependencyInfo>,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for ListDependenciesResponse {
            #[inline]
            fn clone(&self) -> ListDependenciesResponse {
                ListDependenciesResponse {
                    service_name: ::core::clone::Clone::clone(&self.service_name),
                    dependencies: ::core::clone::Clone::clone(&self.dependencies),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for ListDependenciesResponse {
            #[inline]
            fn default() -> ListDependenciesResponse {
                ListDependenciesResponse {
                    service_name: ::core::default::Default::default(),
                    dependencies: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for ListDependenciesResponse {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "ListDependenciesResponse",
                    "service_name",
                    &self.service_name,
                    "dependencies",
                    &&self.dependencies,
                )
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Ord for ListDependenciesResponse {
            #[inline]
            fn cmp(&self, other: &ListDependenciesResponse) -> ::core::cmp::Ordering {
                match ::core::cmp::Ord::cmp(&self.service_name, &other.service_name) {
                    ::core::cmp::Ordering::Equal => {
                        ::core::cmp::Ord::cmp(&self.dependencies, &other.dependencies)
                    }
                    cmp => cmp,
                }
            }
        }
        #[automatically_derived]
        impl ::core::cmp::PartialOrd for ListDependenciesResponse {
            #[inline]
            fn partial_cmp(
                &self,
                other: &ListDependenciesResponse,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                match ::core::cmp::PartialOrd::partial_cmp(&self.service_name, &other.service_name)
                {
                    ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                        ::core::cmp::PartialOrd::partial_cmp(
                            &self.dependencies,
                            &other.dependencies,
                        )
                    }
                    cmp => cmp,
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for ListDependenciesResponse {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for ListDependenciesResponse {
            #[inline]
            fn eq(&self, other: &ListDependenciesResponse) -> bool {
                self.service_name == other.service_name && self.dependencies == other.dependencies
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for ListDependenciesResponse {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<String>;
                let _: ::core::cmp::AssertParamIsEq<Vec<DependencyInfo>>;
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for ListDependenciesResponse {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.service_name, state);
                ::core::hash::Hash::hash(&self.dependencies, state)
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for ListDependenciesResponse {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "ListDependenciesResponse",
                        false as usize + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "service_name",
                        &self.service_name,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "dependencies",
                        &self.dependencies,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for ListDependenciesResponse {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "service_name" => _serde::__private::Ok(__Field::__field0),
                                "dependencies" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"service_name" => _serde::__private::Ok(__Field::__field0),
                                b"dependencies" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<ListDependenciesResponse>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = ListDependenciesResponse;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct ListDependenciesResponse",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 =
                                match _serde::de::SeqAccess::next_element::<String>(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct ListDependenciesResponse with 2 elements",
                                            ),
                                        );
                                    }
                                };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                Vec<DependencyInfo>,
                            >(&mut __seq)?
                            {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct ListDependenciesResponse with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(ListDependenciesResponse {
                                service_name: __field0,
                                dependencies: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> =
                                _serde::__private::None;
                            let mut __field1: _serde::__private::Option<Vec<DependencyInfo>> =
                                _serde::__private::None;
                            while let _serde::__private::Some(__key) =
                                _serde::de::MapAccess::next_key::<__Field>(&mut __map)?
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "service_name",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(
                                                &mut __map,
                                            )?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "dependencies",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<Vec<DependencyInfo>>(
                                                &mut __map,
                                            )?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        )?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("service_name")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("dependencies")?
                                }
                            };
                            _serde::__private::Ok(ListDependenciesResponse {
                                service_name: __field0,
                                dependencies: __field1,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["service_name", "dependencies"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "ListDependenciesResponse",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<ListDependenciesResponse>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        impl ::bincode::Encode for ListDependenciesResponse {
            fn encode<__E: ::bincode::enc::Encoder>(
                &self,
                encoder: &mut __E,
            ) -> core::result::Result<(), ::bincode::error::EncodeError> {
                ::bincode::Encode::encode(&self.service_name, encoder)?;
                ::bincode::Encode::encode(&self.dependencies, encoder)?;
                Ok(())
            }
        }
        impl ::bincode::Decode for ListDependenciesResponse {
            fn decode<__D: ::bincode::de::Decoder>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, ::bincode::error::DecodeError> {
                Ok(Self {
                    service_name: ::bincode::Decode::decode(decoder)?,
                    dependencies: ::bincode::Decode::decode(decoder)?,
                })
            }
        }
        impl<'__de> ::bincode::BorrowDecode<'__de> for ListDependenciesResponse {
            fn borrow_decode<__D: ::bincode::de::BorrowDecoder<'__de>>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, ::bincode::error::DecodeError> {
                Ok(Self {
                    service_name: ::bincode::BorrowDecode::borrow_decode(decoder)?,
                    dependencies: ::bincode::BorrowDecode::borrow_decode(decoder)?,
                })
            }
        }
    }
    pub mod dependency_info {
        use crate::commands::service_status::ServiceState;
        use bincode::{Decode, Encode};
        use serde::{Deserialize, Serialize};
        pub struct DependencyInfo {
            pub id: i64,
            pub name: String,
            pub tunnel_enabled: bool,
            pub state: ServiceState,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for DependencyInfo {
            #[inline]
            fn clone(&self) -> DependencyInfo {
                DependencyInfo {
                    id: ::core::clone::Clone::clone(&self.id),
                    name: ::core::clone::Clone::clone(&self.name),
                    tunnel_enabled: ::core::clone::Clone::clone(&self.tunnel_enabled),
                    state: ::core::clone::Clone::clone(&self.state),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for DependencyInfo {
            #[inline]
            fn default() -> DependencyInfo {
                DependencyInfo {
                    id: ::core::default::Default::default(),
                    name: ::core::default::Default::default(),
                    tunnel_enabled: ::core::default::Default::default(),
                    state: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for DependencyInfo {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field4_finish(
                    f,
                    "DependencyInfo",
                    "id",
                    &self.id,
                    "name",
                    &self.name,
                    "tunnel_enabled",
                    &self.tunnel_enabled,
                    "state",
                    &&self.state,
                )
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Ord for DependencyInfo {
            #[inline]
            fn cmp(&self, other: &DependencyInfo) -> ::core::cmp::Ordering {
                match ::core::cmp::Ord::cmp(&self.id, &other.id) {
                    ::core::cmp::Ordering::Equal => {
                        match ::core::cmp::Ord::cmp(&self.name, &other.name) {
                            ::core::cmp::Ordering::Equal => {
                                match ::core::cmp::Ord::cmp(
                                    &self.tunnel_enabled,
                                    &other.tunnel_enabled,
                                ) {
                                    ::core::cmp::Ordering::Equal => {
                                        ::core::cmp::Ord::cmp(&self.state, &other.state)
                                    }
                                    cmp => cmp,
                                }
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
        }
        #[automatically_derived]
        impl ::core::cmp::PartialOrd for DependencyInfo {
            #[inline]
            fn partial_cmp(
                &self,
                other: &DependencyInfo,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                match ::core::cmp::PartialOrd::partial_cmp(&self.id, &other.id) {
                    ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                        match ::core::cmp::PartialOrd::partial_cmp(&self.name, &other.name) {
                            ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                                match ::core::cmp::PartialOrd::partial_cmp(
                                    &self.tunnel_enabled,
                                    &other.tunnel_enabled,
                                ) {
                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                                        ::core::cmp::PartialOrd::partial_cmp(
                                            &self.state,
                                            &other.state,
                                        )
                                    }
                                    cmp => cmp,
                                }
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for DependencyInfo {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for DependencyInfo {
            #[inline]
            fn eq(&self, other: &DependencyInfo) -> bool {
                self.id == other.id
                    && self.name == other.name
                    && self.tunnel_enabled == other.tunnel_enabled
                    && self.state == other.state
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for DependencyInfo {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<i64>;
                let _: ::core::cmp::AssertParamIsEq<String>;
                let _: ::core::cmp::AssertParamIsEq<bool>;
                let _: ::core::cmp::AssertParamIsEq<ServiceState>;
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for DependencyInfo {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.id, state);
                ::core::hash::Hash::hash(&self.name, state);
                ::core::hash::Hash::hash(&self.tunnel_enabled, state);
                ::core::hash::Hash::hash(&self.state, state)
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for DependencyInfo {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "DependencyInfo",
                        false as usize + 1 + 1 + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "id",
                        &self.id,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "name",
                        &self.name,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "tunnel_enabled",
                        &self.tunnel_enabled,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "state",
                        &self.state,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for DependencyInfo {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "id" => _serde::__private::Ok(__Field::__field0),
                                "name" => _serde::__private::Ok(__Field::__field1),
                                "tunnel_enabled" => _serde::__private::Ok(__Field::__field2),
                                "state" => _serde::__private::Ok(__Field::__field3),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"id" => _serde::__private::Ok(__Field::__field0),
                                b"name" => _serde::__private::Ok(__Field::__field1),
                                b"tunnel_enabled" => _serde::__private::Ok(__Field::__field2),
                                b"state" => _serde::__private::Ok(__Field::__field3),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<DependencyInfo>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = DependencyInfo;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct DependencyInfo",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 =
                                match _serde::de::SeqAccess::next_element::<i64>(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct DependencyInfo with 4 elements",
                                            ),
                                        );
                                    }
                                };
                            let __field1 =
                                match _serde::de::SeqAccess::next_element::<String>(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct DependencyInfo with 4 elements",
                                            ),
                                        );
                                    }
                                };
                            let __field2 =
                                match _serde::de::SeqAccess::next_element::<bool>(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                2usize,
                                                &"struct DependencyInfo with 4 elements",
                                            ),
                                        );
                                    }
                                };
                            let __field3 = match _serde::de::SeqAccess::next_element::<ServiceState>(
                                &mut __seq,
                            )? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            3usize,
                                            &"struct DependencyInfo with 4 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(DependencyInfo {
                                id: __field0,
                                name: __field1,
                                tunnel_enabled: __field2,
                                state: __field3,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<i64> =
                                _serde::__private::None;
                            let mut __field1: _serde::__private::Option<String> =
                                _serde::__private::None;
                            let mut __field2: _serde::__private::Option<bool> =
                                _serde::__private::None;
                            let mut __field3: _serde::__private::Option<ServiceState> =
                                _serde::__private::None;
                            while let _serde::__private::Some(__key) =
                                _serde::de::MapAccess::next_key::<__Field>(&mut __map)?
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "id",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "name",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(
                                                &mut __map,
                                            )?,
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "tunnel_enabled",
                                                ),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field3 => {
                                        if _serde::__private::Option::is_some(&__field3) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "state",
                                                ),
                                            );
                                        }
                                        __field3 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<ServiceState>(
                                                &mut __map,
                                            )?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        )?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("id")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("name")?
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("tunnel_enabled")?
                                }
                            };
                            let __field3 = match __field3 {
                                _serde::__private::Some(__field3) => __field3,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("state")?
                                }
                            };
                            _serde::__private::Ok(DependencyInfo {
                                id: __field0,
                                name: __field1,
                                tunnel_enabled: __field2,
                                state: __field3,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] =
                        &["id", "name", "tunnel_enabled", "state"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "DependencyInfo",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<DependencyInfo>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        impl ::bincode::Encode for DependencyInfo {
            fn encode<__E: ::bincode::enc::Encoder>(
                &self,
                encoder: &mut __E,
            ) -> core::result::Result<(), ::bincode::error::EncodeError> {
                ::bincode::Encode::encode(&self.id, encoder)?;
                ::bincode::Encode::encode(&self.name, encoder)?;
                ::bincode::Encode::encode(&self.tunnel_enabled, encoder)?;
                ::bincode::Encode::encode(&self.state, encoder)?;
                Ok(())
            }
        }
        impl ::bincode::Decode for DependencyInfo {
            fn decode<__D: ::bincode::de::Decoder>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, ::bincode::error::DecodeError> {
                Ok(Self {
                    id: ::bincode::Decode::decode(decoder)?,
                    name: ::bincode::Decode::decode(decoder)?,
                    tunnel_enabled: ::bincode::Decode::decode(decoder)?,
                    state: ::bincode::Decode::decode(decoder)?,
                })
            }
        }
        impl<'__de> ::bincode::BorrowDecode<'__de> for DependencyInfo {
            fn borrow_decode<__D: ::bincode::de::BorrowDecoder<'__de>>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, ::bincode::error::DecodeError> {
                Ok(Self {
                    id: ::bincode::BorrowDecode::borrow_decode(decoder)?,
                    name: ::bincode::BorrowDecode::borrow_decode(decoder)?,
                    tunnel_enabled: ::bincode::BorrowDecode::borrow_decode(decoder)?,
                    state: ::bincode::BorrowDecode::borrow_decode(decoder)?,
                })
            }
        }
    }
    pub mod error {
        use crate::commands::CommandPayload;
        use crate::try_from;
        use bincode::{Decode, Encode};
        use serde::{Deserialize, Serialize};
        pub struct ErrorPayload {
            pub code: u32,
            pub message: String,
            #[serde(skip_serializing_if = "Option::is_none")]
            pub details: Option<String>,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for ErrorPayload {
            #[inline]
            fn clone(&self) -> ErrorPayload {
                ErrorPayload {
                    code: ::core::clone::Clone::clone(&self.code),
                    message: ::core::clone::Clone::clone(&self.message),
                    details: ::core::clone::Clone::clone(&self.details),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for ErrorPayload {
            #[inline]
            fn default() -> ErrorPayload {
                ErrorPayload {
                    code: ::core::default::Default::default(),
                    message: ::core::default::Default::default(),
                    details: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for ErrorPayload {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "ErrorPayload",
                    "code",
                    &self.code,
                    "message",
                    &self.message,
                    "details",
                    &&self.details,
                )
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Ord for ErrorPayload {
            #[inline]
            fn cmp(&self, other: &ErrorPayload) -> ::core::cmp::Ordering {
                match ::core::cmp::Ord::cmp(&self.code, &other.code) {
                    ::core::cmp::Ordering::Equal => {
                        match ::core::cmp::Ord::cmp(&self.message, &other.message) {
                            ::core::cmp::Ordering::Equal => {
                                ::core::cmp::Ord::cmp(&self.details, &other.details)
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
        }
        #[automatically_derived]
        impl ::core::cmp::PartialOrd for ErrorPayload {
            #[inline]
            fn partial_cmp(
                &self,
                other: &ErrorPayload,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                match ::core::cmp::PartialOrd::partial_cmp(&self.code, &other.code) {
                    ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                        match ::core::cmp::PartialOrd::partial_cmp(&self.message, &other.message) {
                            ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                                ::core::cmp::PartialOrd::partial_cmp(&self.details, &other.details)
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for ErrorPayload {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for ErrorPayload {
            #[inline]
            fn eq(&self, other: &ErrorPayload) -> bool {
                self.code == other.code
                    && self.message == other.message
                    && self.details == other.details
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for ErrorPayload {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<u32>;
                let _: ::core::cmp::AssertParamIsEq<String>;
                let _: ::core::cmp::AssertParamIsEq<Option<String>>;
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for ErrorPayload {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.code, state);
                ::core::hash::Hash::hash(&self.message, state);
                ::core::hash::Hash::hash(&self.details, state)
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for ErrorPayload {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "ErrorPayload",
                        false as usize + 1 + 1 + if Option::is_none(&self.details) { 0 } else { 1 },
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "code",
                        &self.code,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "message",
                        &self.message,
                    )?;
                    if !Option::is_none(&self.details) {
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "details",
                            &self.details,
                        )?;
                    } else {
                        _serde::ser::SerializeStruct::skip_field(&mut __serde_state, "details")?;
                    }
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for ErrorPayload {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "code" => _serde::__private::Ok(__Field::__field0),
                                "message" => _serde::__private::Ok(__Field::__field1),
                                "details" => _serde::__private::Ok(__Field::__field2),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"code" => _serde::__private::Ok(__Field::__field0),
                                b"message" => _serde::__private::Ok(__Field::__field1),
                                b"details" => _serde::__private::Ok(__Field::__field2),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<ErrorPayload>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = ErrorPayload;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct ErrorPayload",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 =
                                match _serde::de::SeqAccess::next_element::<u32>(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct ErrorPayload with 3 elements",
                                            ),
                                        );
                                    }
                                };
                            let __field1 =
                                match _serde::de::SeqAccess::next_element::<String>(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct ErrorPayload with 3 elements",
                                            ),
                                        );
                                    }
                                };
                            let __field2 = match _serde::de::SeqAccess::next_element::<
                                Option<String>,
                            >(&mut __seq)?
                            {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct ErrorPayload with 3 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(ErrorPayload {
                                code: __field0,
                                message: __field1,
                                details: __field2,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<u32> =
                                _serde::__private::None;
                            let mut __field1: _serde::__private::Option<String> =
                                _serde::__private::None;
                            let mut __field2: _serde::__private::Option<Option<String>> =
                                _serde::__private::None;
                            while let _serde::__private::Some(__key) =
                                _serde::de::MapAccess::next_key::<__Field>(&mut __map)?
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "code",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<u32>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "message",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(
                                                &mut __map,
                                            )?,
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "details",
                                                ),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<Option<String>>(
                                                &mut __map,
                                            )?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        )?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("code")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("message")?
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("details")?
                                }
                            };
                            _serde::__private::Ok(ErrorPayload {
                                code: __field0,
                                message: __field1,
                                details: __field2,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["code", "message", "details"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "ErrorPayload",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<ErrorPayload>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        impl ::bincode::Encode for ErrorPayload {
            fn encode<__E: ::bincode::enc::Encoder>(
                &self,
                encoder: &mut __E,
            ) -> core::result::Result<(), ::bincode::error::EncodeError> {
                ::bincode::Encode::encode(&self.code, encoder)?;
                ::bincode::Encode::encode(&self.message, encoder)?;
                ::bincode::Encode::encode(&self.details, encoder)?;
                Ok(())
            }
        }
        impl ::bincode::Decode for ErrorPayload {
            fn decode<__D: ::bincode::de::Decoder>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, ::bincode::error::DecodeError> {
                Ok(Self {
                    code: ::bincode::Decode::decode(decoder)?,
                    message: ::bincode::Decode::decode(decoder)?,
                    details: ::bincode::Decode::decode(decoder)?,
                })
            }
        }
        impl<'__de> ::bincode::BorrowDecode<'__de> for ErrorPayload {
            fn borrow_decode<__D: ::bincode::de::BorrowDecoder<'__de>>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, ::bincode::error::DecodeError> {
                Ok(Self {
                    code: ::bincode::BorrowDecode::borrow_decode(decoder)?,
                    message: ::bincode::BorrowDecode::borrow_decode(decoder)?,
                    details: ::bincode::BorrowDecode::borrow_decode(decoder)?,
                })
            }
        }
        impl TryFrom<CommandPayload> for ErrorPayload {
            type Error = ::anyhow::Error;
            fn try_from(value: CommandPayload) -> Result<Self, Self::Error> {
                #[allow(unused_imports)]
                use crate::commands::CommandPayload::Error;
                if !value.is_error() {
                    return ::anyhow::__private::Err(::anyhow::Error::msg(
                        ::alloc::__export::must_use({
                            let res = ::alloc::fmt::format(format_args!(
                                "Command is not of type `{0}`",
                                "Error"
                            ));
                            res
                        }),
                    ));
                }
                Ok(value.unwrap_error())
            }
        }
    }
    pub mod git {
        use crate::commands::manage_service::ServiceRef;
        use crate::service_command;
        use bincode::{Decode, Encode};
        use serde::{Deserialize, Serialize};
        pub struct CheckoutPayload {
            pub service: ServiceRef,
            pub branch: String,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for CheckoutPayload {
            #[inline]
            fn clone(&self) -> CheckoutPayload {
                CheckoutPayload {
                    service: ::core::clone::Clone::clone(&self.service),
                    branch: ::core::clone::Clone::clone(&self.branch),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for CheckoutPayload {
            #[inline]
            fn default() -> CheckoutPayload {
                CheckoutPayload {
                    service: ::core::default::Default::default(),
                    branch: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for CheckoutPayload {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "CheckoutPayload",
                    "service",
                    &self.service,
                    "branch",
                    &&self.branch,
                )
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Ord for CheckoutPayload {
            #[inline]
            fn cmp(&self, other: &CheckoutPayload) -> ::core::cmp::Ordering {
                match ::core::cmp::Ord::cmp(&self.service, &other.service) {
                    ::core::cmp::Ordering::Equal => {
                        ::core::cmp::Ord::cmp(&self.branch, &other.branch)
                    }
                    cmp => cmp,
                }
            }
        }
        #[automatically_derived]
        impl ::core::cmp::PartialOrd for CheckoutPayload {
            #[inline]
            fn partial_cmp(
                &self,
                other: &CheckoutPayload,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                match ::core::cmp::PartialOrd::partial_cmp(&self.service, &other.service) {
                    ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                        ::core::cmp::PartialOrd::partial_cmp(&self.branch, &other.branch)
                    }
                    cmp => cmp,
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for CheckoutPayload {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for CheckoutPayload {
            #[inline]
            fn eq(&self, other: &CheckoutPayload) -> bool {
                self.service == other.service && self.branch == other.branch
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for CheckoutPayload {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<ServiceRef>;
                let _: ::core::cmp::AssertParamIsEq<String>;
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for CheckoutPayload {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.service, state);
                ::core::hash::Hash::hash(&self.branch, state)
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for CheckoutPayload {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "CheckoutPayload",
                        false as usize + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "service",
                        &self.service,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "branch",
                        &self.branch,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for CheckoutPayload {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "service" => _serde::__private::Ok(__Field::__field0),
                                "branch" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"service" => _serde::__private::Ok(__Field::__field0),
                                b"branch" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<CheckoutPayload>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = CheckoutPayload;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct CheckoutPayload",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<ServiceRef>(
                                &mut __seq,
                            )? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct CheckoutPayload with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 =
                                match _serde::de::SeqAccess::next_element::<String>(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct CheckoutPayload with 2 elements",
                                            ),
                                        );
                                    }
                                };
                            _serde::__private::Ok(CheckoutPayload {
                                service: __field0,
                                branch: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<ServiceRef> =
                                _serde::__private::None;
                            let mut __field1: _serde::__private::Option<String> =
                                _serde::__private::None;
                            while let _serde::__private::Some(__key) =
                                _serde::de::MapAccess::next_key::<__Field>(&mut __map)?
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "service",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<ServiceRef>(
                                                &mut __map,
                                            )?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "branch",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(
                                                &mut __map,
                                            )?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        )?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("service")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("branch")?
                                }
                            };
                            _serde::__private::Ok(CheckoutPayload {
                                service: __field0,
                                branch: __field1,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["service", "branch"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "CheckoutPayload",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<CheckoutPayload>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        impl ::bincode::Encode for CheckoutPayload {
            fn encode<__E: ::bincode::enc::Encoder>(
                &self,
                encoder: &mut __E,
            ) -> core::result::Result<(), ::bincode::error::EncodeError> {
                ::bincode::Encode::encode(&self.service, encoder)?;
                ::bincode::Encode::encode(&self.branch, encoder)?;
                Ok(())
            }
        }
        impl ::bincode::Decode for CheckoutPayload {
            fn decode<__D: ::bincode::de::Decoder>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, ::bincode::error::DecodeError> {
                Ok(Self {
                    service: ::bincode::Decode::decode(decoder)?,
                    branch: ::bincode::Decode::decode(decoder)?,
                })
            }
        }
        impl<'__de> ::bincode::BorrowDecode<'__de> for CheckoutPayload {
            fn borrow_decode<__D: ::bincode::de::BorrowDecoder<'__de>>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, ::bincode::error::DecodeError> {
                Ok(Self {
                    service: ::bincode::BorrowDecode::borrow_decode(decoder)?,
                    branch: ::bincode::BorrowDecode::borrow_decode(decoder)?,
                })
            }
        }
        pub struct RepoStatus {
            pub current_branch: String,
            pub is_dirty: bool,
            pub pending_changes: Vec<String>,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for RepoStatus {
            #[inline]
            fn clone(&self) -> RepoStatus {
                RepoStatus {
                    current_branch: ::core::clone::Clone::clone(&self.current_branch),
                    is_dirty: ::core::clone::Clone::clone(&self.is_dirty),
                    pending_changes: ::core::clone::Clone::clone(&self.pending_changes),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for RepoStatus {
            #[inline]
            fn default() -> RepoStatus {
                RepoStatus {
                    current_branch: ::core::default::Default::default(),
                    is_dirty: ::core::default::Default::default(),
                    pending_changes: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for RepoStatus {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "RepoStatus",
                    "current_branch",
                    &self.current_branch,
                    "is_dirty",
                    &self.is_dirty,
                    "pending_changes",
                    &&self.pending_changes,
                )
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Ord for RepoStatus {
            #[inline]
            fn cmp(&self, other: &RepoStatus) -> ::core::cmp::Ordering {
                match ::core::cmp::Ord::cmp(&self.current_branch, &other.current_branch) {
                    ::core::cmp::Ordering::Equal => {
                        match ::core::cmp::Ord::cmp(&self.is_dirty, &other.is_dirty) {
                            ::core::cmp::Ordering::Equal => {
                                ::core::cmp::Ord::cmp(&self.pending_changes, &other.pending_changes)
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
        }
        #[automatically_derived]
        impl ::core::cmp::PartialOrd for RepoStatus {
            #[inline]
            fn partial_cmp(
                &self,
                other: &RepoStatus,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                match ::core::cmp::PartialOrd::partial_cmp(
                    &self.current_branch,
                    &other.current_branch,
                ) {
                    ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                        match ::core::cmp::PartialOrd::partial_cmp(&self.is_dirty, &other.is_dirty)
                        {
                            ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                                ::core::cmp::PartialOrd::partial_cmp(
                                    &self.pending_changes,
                                    &other.pending_changes,
                                )
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for RepoStatus {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for RepoStatus {
            #[inline]
            fn eq(&self, other: &RepoStatus) -> bool {
                self.current_branch == other.current_branch
                    && self.is_dirty == other.is_dirty
                    && self.pending_changes == other.pending_changes
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for RepoStatus {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<String>;
                let _: ::core::cmp::AssertParamIsEq<bool>;
                let _: ::core::cmp::AssertParamIsEq<Vec<String>>;
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for RepoStatus {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.current_branch, state);
                ::core::hash::Hash::hash(&self.is_dirty, state);
                ::core::hash::Hash::hash(&self.pending_changes, state)
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for RepoStatus {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "RepoStatus",
                        false as usize + 1 + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "current_branch",
                        &self.current_branch,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "is_dirty",
                        &self.is_dirty,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "pending_changes",
                        &self.pending_changes,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for RepoStatus {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "current_branch" => _serde::__private::Ok(__Field::__field0),
                                "is_dirty" => _serde::__private::Ok(__Field::__field1),
                                "pending_changes" => _serde::__private::Ok(__Field::__field2),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"current_branch" => _serde::__private::Ok(__Field::__field0),
                                b"is_dirty" => _serde::__private::Ok(__Field::__field1),
                                b"pending_changes" => _serde::__private::Ok(__Field::__field2),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<RepoStatus>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = RepoStatus;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct RepoStatus",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 =
                                match _serde::de::SeqAccess::next_element::<String>(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct RepoStatus with 3 elements",
                                            ),
                                        );
                                    }
                                };
                            let __field1 =
                                match _serde::de::SeqAccess::next_element::<bool>(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct RepoStatus with 3 elements",
                                            ),
                                        );
                                    }
                                };
                            let __field2 = match _serde::de::SeqAccess::next_element::<Vec<String>>(
                                &mut __seq,
                            )? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct RepoStatus with 3 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(RepoStatus {
                                current_branch: __field0,
                                is_dirty: __field1,
                                pending_changes: __field2,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> =
                                _serde::__private::None;
                            let mut __field1: _serde::__private::Option<bool> =
                                _serde::__private::None;
                            let mut __field2: _serde::__private::Option<Vec<String>> =
                                _serde::__private::None;
                            while let _serde::__private::Some(__key) =
                                _serde::de::MapAccess::next_key::<__Field>(&mut __map)?
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "current_branch",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(
                                                &mut __map,
                                            )?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "is_dirty",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "pending_changes",
                                                ),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<Vec<String>>(
                                                &mut __map,
                                            )?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        )?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("current_branch")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("is_dirty")?
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("pending_changes")?
                                }
                            };
                            _serde::__private::Ok(RepoStatus {
                                current_branch: __field0,
                                is_dirty: __field1,
                                pending_changes: __field2,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] =
                        &["current_branch", "is_dirty", "pending_changes"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "RepoStatus",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<RepoStatus>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        impl ::bincode::Encode for RepoStatus {
            fn encode<__E: ::bincode::enc::Encoder>(
                &self,
                encoder: &mut __E,
            ) -> core::result::Result<(), ::bincode::error::EncodeError> {
                ::bincode::Encode::encode(&self.current_branch, encoder)?;
                ::bincode::Encode::encode(&self.is_dirty, encoder)?;
                ::bincode::Encode::encode(&self.pending_changes, encoder)?;
                Ok(())
            }
        }
        impl ::bincode::Decode for RepoStatus {
            fn decode<__D: ::bincode::de::Decoder>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, ::bincode::error::DecodeError> {
                Ok(Self {
                    current_branch: ::bincode::Decode::decode(decoder)?,
                    is_dirty: ::bincode::Decode::decode(decoder)?,
                    pending_changes: ::bincode::Decode::decode(decoder)?,
                })
            }
        }
        impl<'__de> ::bincode::BorrowDecode<'__de> for RepoStatus {
            fn borrow_decode<__D: ::bincode::de::BorrowDecoder<'__de>>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, ::bincode::error::DecodeError> {
                Ok(Self {
                    current_branch: ::bincode::BorrowDecode::borrow_decode(decoder)?,
                    is_dirty: ::bincode::BorrowDecode::borrow_decode(decoder)?,
                    pending_changes: ::bincode::BorrowDecode::borrow_decode(decoder)?,
                })
            }
        }
        pub struct CheckoutCommand {
            service: ServiceRef,
            branch: String,
        }
        impl CheckoutCommand {
            pub fn new(service: impl Into<ServiceRef>, branch: impl Into<String>) -> Self {
                let service = service.into();
                let branch = branch.into();
                Self { service, branch }
            }
        }
        impl From<CheckoutCommand> for <CheckoutCommand as crate::traits::ServiceCommand>::Input {
            fn from(command: CheckoutCommand) -> Self {
                use crate::traits::ServiceCommand;
                command.into_payload()
            }
        }
        impl crate::traits::ServiceCommand for CheckoutCommand {
            type Input = CheckoutPayload;
            type Output = ();
            const COMMAND: crate::commands::Command = crate::commands::Command::CheckoutBranch;
            fn into_payload(self) -> Self::Input {
                Self::Input {
                    service: self.service,
                    branch: self.branch,
                }
            }
        }
        impl From<CheckoutPayload> for CheckoutCommand {
            fn from(input: CheckoutPayload) -> Self {
                Self {
                    service: input.service,
                    branch: input.branch,
                }
            }
        }
        pub struct GetRepoStatusCommand(ServiceRef);
        impl GetRepoStatusCommand {
            pub fn new(input: impl Into<ServiceRef>) -> Self {
                Self(input.into())
            }
        }
        impl crate::traits::ServiceCommand for GetRepoStatusCommand {
            type Input = ServiceRef;
            type Output = RepoStatus;
            const COMMAND: crate::commands::Command = crate::commands::Command::GetRepoStatus;
            fn into_payload(self) -> Self::Input {
                self.0
            }
        }
        impl From<GetRepoStatusCommand> for <GetRepoStatusCommand as crate::traits::ServiceCommand>::Input {
            fn from(command: GetRepoStatusCommand) -> Self {
                use crate::traits::ServiceCommand;
                command.into_payload()
            }
        }
        impl From<ServiceRef> for GetRepoStatusCommand {
            fn from(input: ServiceRef) -> Self {
                Self::new(input)
            }
        }
    }
    pub mod list_services {
        use crate::commands::service_status::ServiceState;
        use crate::commands::CommandPayload;
        use crate::{service_command, try_from};
        use bincode::{Decode, Encode};
        use derive_more::AsRef;
        use serde::{Deserialize, Serialize};
        pub struct ListServicesResponse {
            pub services: Vec<ServiceInfo>,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for ListServicesResponse {
            #[inline]
            fn clone(&self) -> ListServicesResponse {
                ListServicesResponse {
                    services: ::core::clone::Clone::clone(&self.services),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for ListServicesResponse {
            #[inline]
            fn default() -> ListServicesResponse {
                ListServicesResponse {
                    services: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for ListServicesResponse {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "ListServicesResponse",
                    "services",
                    &&self.services,
                )
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Ord for ListServicesResponse {
            #[inline]
            fn cmp(&self, other: &ListServicesResponse) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.services, &other.services)
            }
        }
        #[automatically_derived]
        impl ::core::cmp::PartialOrd for ListServicesResponse {
            #[inline]
            fn partial_cmp(
                &self,
                other: &ListServicesResponse,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.services, &other.services)
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for ListServicesResponse {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for ListServicesResponse {
            #[inline]
            fn eq(&self, other: &ListServicesResponse) -> bool {
                self.services == other.services
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for ListServicesResponse {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<Vec<ServiceInfo>>;
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for ListServicesResponse {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.services, state)
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for ListServicesResponse {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "ListServicesResponse",
                        false as usize + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "services",
                        &self.services,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for ListServicesResponse {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "services" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"services" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<ListServicesResponse>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = ListServicesResponse;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct ListServicesResponse",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                Vec<ServiceInfo>,
                            >(&mut __seq)?
                            {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct ListServicesResponse with 1 element",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(ListServicesResponse { services: __field0 })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<Vec<ServiceInfo>> =
                                _serde::__private::None;
                            while let _serde::__private::Some(__key) =
                                _serde::de::MapAccess::next_key::<__Field>(&mut __map)?
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "services",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<Vec<ServiceInfo>>(
                                                &mut __map,
                                            )?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        )?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("services")?
                                }
                            };
                            _serde::__private::Ok(ListServicesResponse { services: __field0 })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["services"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "ListServicesResponse",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<ListServicesResponse>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        impl ::bincode::Encode for ListServicesResponse {
            fn encode<__E: ::bincode::enc::Encoder>(
                &self,
                encoder: &mut __E,
            ) -> core::result::Result<(), ::bincode::error::EncodeError> {
                ::bincode::Encode::encode(&self.services, encoder)?;
                Ok(())
            }
        }
        impl ::bincode::Decode for ListServicesResponse {
            fn decode<__D: ::bincode::de::Decoder>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, ::bincode::error::DecodeError> {
                Ok(Self {
                    services: ::bincode::Decode::decode(decoder)?,
                })
            }
        }
        impl<'__de> ::bincode::BorrowDecode<'__de> for ListServicesResponse {
            fn borrow_decode<__D: ::bincode::de::BorrowDecoder<'__de>>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, ::bincode::error::DecodeError> {
                Ok(Self {
                    services: ::bincode::BorrowDecode::borrow_decode(decoder)?,
                })
            }
        }
        #[automatically_derived]
        impl derive_more::AsRef<Vec<ServiceInfo>> for ListServicesResponse {
            #[inline]
            fn as_ref(&self) -> &Vec<ServiceInfo> {
                &self.services
            }
        }
        pub struct ListServicesCommand;
        impl ::std::default::Default for ListServicesCommand {
            fn default() -> Self {
                Self
            }
        }
        impl ListServicesCommand {
            pub fn new() -> Self {
                ::std::default::Default::default()
            }
        }
        impl crate::traits::ServiceCommand for ListServicesCommand {
            type Input = ();
            type Output = ListServicesResponse;
            const COMMAND: crate::commands::Command = crate::commands::Command::ListServices;
            fn into_payload(self) -> Self::Input {}
        }
        impl TryFrom<CommandPayload> for ListServicesResponse {
            type Error = ::anyhow::Error;
            fn try_from(value: CommandPayload) -> Result<Self, Self::Error> {
                #[allow(unused_imports)]
                use crate::commands::CommandPayload::ListServices;
                if !value.is_list_services() {
                    return ::anyhow::__private::Err(::anyhow::Error::msg(
                        ::alloc::__export::must_use({
                            let res = ::alloc::fmt::format(format_args!(
                                "Command is not of type `{0}`",
                                "ListServices"
                            ));
                            res
                        }),
                    ));
                }
                Ok(value.unwrap_list_services())
            }
        }
        impl<T: Into<ServiceInfo>> FromIterator<T> for ListServicesResponse {
            fn from_iter<I: IntoIterator<Item = T>>(iter: I) -> Self {
                ListServicesResponse {
                    services: iter.into_iter().map(Into::into).collect(),
                }
            }
        }
        pub struct ServiceInfo {
            pub name: String,
            pub state: ServiceState,
            pub port: i64,
            pub has_dependencies: bool,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for ServiceInfo {
            #[inline]
            fn clone(&self) -> ServiceInfo {
                ServiceInfo {
                    name: ::core::clone::Clone::clone(&self.name),
                    state: ::core::clone::Clone::clone(&self.state),
                    port: ::core::clone::Clone::clone(&self.port),
                    has_dependencies: ::core::clone::Clone::clone(&self.has_dependencies),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for ServiceInfo {
            #[inline]
            fn default() -> ServiceInfo {
                ServiceInfo {
                    name: ::core::default::Default::default(),
                    state: ::core::default::Default::default(),
                    port: ::core::default::Default::default(),
                    has_dependencies: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for ServiceInfo {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field4_finish(
                    f,
                    "ServiceInfo",
                    "name",
                    &self.name,
                    "state",
                    &self.state,
                    "port",
                    &self.port,
                    "has_dependencies",
                    &&self.has_dependencies,
                )
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Ord for ServiceInfo {
            #[inline]
            fn cmp(&self, other: &ServiceInfo) -> ::core::cmp::Ordering {
                match ::core::cmp::Ord::cmp(&self.name, &other.name) {
                    ::core::cmp::Ordering::Equal => {
                        match ::core::cmp::Ord::cmp(&self.state, &other.state) {
                            ::core::cmp::Ordering::Equal => {
                                match ::core::cmp::Ord::cmp(&self.port, &other.port) {
                                    ::core::cmp::Ordering::Equal => ::core::cmp::Ord::cmp(
                                        &self.has_dependencies,
                                        &other.has_dependencies,
                                    ),
                                    cmp => cmp,
                                }
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
        }
        #[automatically_derived]
        impl ::core::cmp::PartialOrd for ServiceInfo {
            #[inline]
            fn partial_cmp(
                &self,
                other: &ServiceInfo,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                match ::core::cmp::PartialOrd::partial_cmp(&self.name, &other.name) {
                    ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                        match ::core::cmp::PartialOrd::partial_cmp(&self.state, &other.state) {
                            ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                                match ::core::cmp::PartialOrd::partial_cmp(&self.port, &other.port)
                                {
                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                                        ::core::cmp::PartialOrd::partial_cmp(
                                            &self.has_dependencies,
                                            &other.has_dependencies,
                                        )
                                    }
                                    cmp => cmp,
                                }
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for ServiceInfo {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for ServiceInfo {
            #[inline]
            fn eq(&self, other: &ServiceInfo) -> bool {
                self.name == other.name
                    && self.state == other.state
                    && self.port == other.port
                    && self.has_dependencies == other.has_dependencies
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for ServiceInfo {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<String>;
                let _: ::core::cmp::AssertParamIsEq<ServiceState>;
                let _: ::core::cmp::AssertParamIsEq<i64>;
                let _: ::core::cmp::AssertParamIsEq<bool>;
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for ServiceInfo {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.name, state);
                ::core::hash::Hash::hash(&self.state, state);
                ::core::hash::Hash::hash(&self.port, state);
                ::core::hash::Hash::hash(&self.has_dependencies, state)
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for ServiceInfo {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "ServiceInfo",
                        false as usize + 1 + 1 + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "name",
                        &self.name,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "state",
                        &self.state,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "port",
                        &self.port,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "has_dependencies",
                        &self.has_dependencies,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for ServiceInfo {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "name" => _serde::__private::Ok(__Field::__field0),
                                "state" => _serde::__private::Ok(__Field::__field1),
                                "port" => _serde::__private::Ok(__Field::__field2),
                                "has_dependencies" => _serde::__private::Ok(__Field::__field3),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"name" => _serde::__private::Ok(__Field::__field0),
                                b"state" => _serde::__private::Ok(__Field::__field1),
                                b"port" => _serde::__private::Ok(__Field::__field2),
                                b"has_dependencies" => _serde::__private::Ok(__Field::__field3),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<ServiceInfo>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = ServiceInfo;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct ServiceInfo",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 =
                                match _serde::de::SeqAccess::next_element::<String>(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct ServiceInfo with 4 elements",
                                            ),
                                        );
                                    }
                                };
                            let __field1 = match _serde::de::SeqAccess::next_element::<ServiceState>(
                                &mut __seq,
                            )? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct ServiceInfo with 4 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 =
                                match _serde::de::SeqAccess::next_element::<i64>(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                2usize,
                                                &"struct ServiceInfo with 4 elements",
                                            ),
                                        );
                                    }
                                };
                            let __field3 =
                                match _serde::de::SeqAccess::next_element::<bool>(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                3usize,
                                                &"struct ServiceInfo with 4 elements",
                                            ),
                                        );
                                    }
                                };
                            _serde::__private::Ok(ServiceInfo {
                                name: __field0,
                                state: __field1,
                                port: __field2,
                                has_dependencies: __field3,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> =
                                _serde::__private::None;
                            let mut __field1: _serde::__private::Option<ServiceState> =
                                _serde::__private::None;
                            let mut __field2: _serde::__private::Option<i64> =
                                _serde::__private::None;
                            let mut __field3: _serde::__private::Option<bool> =
                                _serde::__private::None;
                            while let _serde::__private::Some(__key) =
                                _serde::de::MapAccess::next_key::<__Field>(&mut __map)?
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "name",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(
                                                &mut __map,
                                            )?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "state",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<ServiceState>(
                                                &mut __map,
                                            )?,
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "port",
                                                ),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field3 => {
                                        if _serde::__private::Option::is_some(&__field3) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "has_dependencies",
                                                ),
                                            );
                                        }
                                        __field3 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        )?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("name")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("state")?
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("port")?
                                }
                            };
                            let __field3 = match __field3 {
                                _serde::__private::Some(__field3) => __field3,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("has_dependencies")?
                                }
                            };
                            _serde::__private::Ok(ServiceInfo {
                                name: __field0,
                                state: __field1,
                                port: __field2,
                                has_dependencies: __field3,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] =
                        &["name", "state", "port", "has_dependencies"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "ServiceInfo",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<ServiceInfo>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        impl ::bincode::Encode for ServiceInfo {
            fn encode<__E: ::bincode::enc::Encoder>(
                &self,
                encoder: &mut __E,
            ) -> core::result::Result<(), ::bincode::error::EncodeError> {
                ::bincode::Encode::encode(&self.name, encoder)?;
                ::bincode::Encode::encode(&self.state, encoder)?;
                ::bincode::Encode::encode(&self.port, encoder)?;
                ::bincode::Encode::encode(&self.has_dependencies, encoder)?;
                Ok(())
            }
        }
        impl ::bincode::Decode for ServiceInfo {
            fn decode<__D: ::bincode::de::Decoder>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, ::bincode::error::DecodeError> {
                Ok(Self {
                    name: ::bincode::Decode::decode(decoder)?,
                    state: ::bincode::Decode::decode(decoder)?,
                    port: ::bincode::Decode::decode(decoder)?,
                    has_dependencies: ::bincode::Decode::decode(decoder)?,
                })
            }
        }
        impl<'__de> ::bincode::BorrowDecode<'__de> for ServiceInfo {
            fn borrow_decode<__D: ::bincode::de::BorrowDecoder<'__de>>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, ::bincode::error::DecodeError> {
                Ok(Self {
                    name: ::bincode::BorrowDecode::borrow_decode(decoder)?,
                    state: ::bincode::BorrowDecode::borrow_decode(decoder)?,
                    port: ::bincode::BorrowDecode::borrow_decode(decoder)?,
                    has_dependencies: ::bincode::BorrowDecode::borrow_decode(decoder)?,
                })
            }
        }
    }
    pub mod manage_service {
        use crate::service_command;
        use bincode::{Decode, Encode};
        use derive_more::{Display, From, TryFrom};
        use serde::{Deserialize, Serialize};
        use std::collections::HashMap;
        use std::str::FromStr;
        pub struct StartServiceCommand {
            service: ServiceRef,
            env_vars: HashMap<String, String>,
        }
        impl StartServiceCommand {
            pub fn new(
                service: impl Into<ServiceRef>,
                env_vars: impl Into<HashMap<String, String>>,
            ) -> Self {
                let service = service.into();
                let env_vars = env_vars.into();
                Self { service, env_vars }
            }
        }
        impl From<StartServiceCommand> for <StartServiceCommand as crate::traits::ServiceCommand>::Input {
            fn from(command: StartServiceCommand) -> Self {
                use crate::traits::ServiceCommand;
                command.into_payload()
            }
        }
        impl crate::traits::ServiceCommand for StartServiceCommand {
            type Input = StartServicePayload;
            type Output = ();
            const COMMAND: crate::commands::Command = crate::commands::Command::StartService;
            fn into_payload(self) -> Self::Input {
                Self::Input {
                    service: self.service,
                    env_vars: self.env_vars,
                }
            }
        }
        impl From<StartServicePayload> for StartServiceCommand {
            fn from(input: StartServicePayload) -> Self {
                Self {
                    service: input.service,
                    env_vars: input.env_vars,
                }
            }
        }
        pub struct RestartServiceCommand {
            service: ServiceRef,
            env_vars: HashMap<String, String>,
        }
        impl RestartServiceCommand {
            pub fn new(
                service: impl Into<ServiceRef>,
                env_vars: impl Into<HashMap<String, String>>,
            ) -> Self {
                let service = service.into();
                let env_vars = env_vars.into();
                Self { service, env_vars }
            }
        }
        impl From<RestartServiceCommand>
            for <RestartServiceCommand as crate::traits::ServiceCommand>::Input
        {
            fn from(command: RestartServiceCommand) -> Self {
                use crate::traits::ServiceCommand;
                command.into_payload()
            }
        }
        impl crate::traits::ServiceCommand for RestartServiceCommand {
            type Input = StartServicePayload;
            type Output = ();
            const COMMAND: crate::commands::Command = crate::commands::Command::RestartService;
            fn into_payload(self) -> Self::Input {
                Self::Input {
                    service: self.service,
                    env_vars: self.env_vars,
                }
            }
        }
        impl From<StartServicePayload> for RestartServiceCommand {
            fn from(input: StartServicePayload) -> Self {
                Self {
                    service: input.service,
                    env_vars: input.env_vars,
                }
            }
        }
        pub struct StopServiceCommand(ServiceRef);
        impl StopServiceCommand {
            pub fn new(input: impl Into<ServiceRef>) -> Self {
                Self(input.into())
            }
        }
        impl crate::traits::ServiceCommand for StopServiceCommand {
            type Input = ServiceRef;
            type Output = ();
            const COMMAND: crate::commands::Command = crate::commands::Command::StopService;
            fn into_payload(self) -> Self::Input {
                self.0
            }
        }
        impl From<StopServiceCommand> for <StopServiceCommand as crate::traits::ServiceCommand>::Input {
            fn from(command: StopServiceCommand) -> Self {
                use crate::traits::ServiceCommand;
                command.into_payload()
            }
        }
        impl From<ServiceRef> for StopServiceCommand {
            fn from(input: ServiceRef) -> Self {
                Self::new(input)
            }
        }
        pub struct RemoveServiceCommand(ServiceRef);
        impl RemoveServiceCommand {
            pub fn new(input: impl Into<ServiceRef>) -> Self {
                Self(input.into())
            }
        }
        impl crate::traits::ServiceCommand for RemoveServiceCommand {
            type Input = ServiceRef;
            type Output = ();
            const COMMAND: crate::commands::Command = crate::commands::Command::RemoveService;
            fn into_payload(self) -> Self::Input {
                self.0
            }
        }
        impl From<RemoveServiceCommand> for <RemoveServiceCommand as crate::traits::ServiceCommand>::Input {
            fn from(command: RemoveServiceCommand) -> Self {
                use crate::traits::ServiceCommand;
                command.into_payload()
            }
        }
        impl From<ServiceRef> for RemoveServiceCommand {
            fn from(input: ServiceRef) -> Self {
                Self::new(input)
            }
        }
        pub struct StartServicePayload {
            #[serde(flatten)]
            pub service: ServiceRef,
            pub env_vars: HashMap<String, String>,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for StartServicePayload {
            #[inline]
            fn clone(&self) -> StartServicePayload {
                StartServicePayload {
                    service: ::core::clone::Clone::clone(&self.service),
                    env_vars: ::core::clone::Clone::clone(&self.env_vars),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for StartServicePayload {
            #[inline]
            fn default() -> StartServicePayload {
                StartServicePayload {
                    service: ::core::default::Default::default(),
                    env_vars: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for StartServicePayload {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "StartServicePayload",
                    "service",
                    &self.service,
                    "env_vars",
                    &&self.env_vars,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for StartServicePayload {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for StartServicePayload {
            #[inline]
            fn eq(&self, other: &StartServicePayload) -> bool {
                self.service == other.service && self.env_vars == other.env_vars
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for StartServicePayload {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<ServiceRef>;
                let _: ::core::cmp::AssertParamIsEq<HashMap<String, String>>;
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for StartServicePayload {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state =
                        _serde::Serializer::serialize_map(__serializer, _serde::__private::None)?;
                    _serde::Serialize::serialize(
                        &&self.service,
                        _serde::__private::ser::FlatMapSerializer(&mut __serde_state),
                    )?;
                    _serde::ser::SerializeMap::serialize_entry(
                        &mut __serde_state,
                        "env_vars",
                        &self.env_vars,
                    )?;
                    _serde::ser::SerializeMap::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for StartServicePayload {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field<'de> {
                        __field1,
                        __other(_serde::__private::de::Content<'de>),
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field<'de>;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_bool<__E>(
                            self,
                            __value: bool,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(__Field::__other(
                                _serde::__private::de::Content::Bool(__value),
                            ))
                        }
                        fn visit_i8<__E>(
                            self,
                            __value: i8,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(__Field::__other(
                                _serde::__private::de::Content::I8(__value),
                            ))
                        }
                        fn visit_i16<__E>(
                            self,
                            __value: i16,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(__Field::__other(
                                _serde::__private::de::Content::I16(__value),
                            ))
                        }
                        fn visit_i32<__E>(
                            self,
                            __value: i32,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(__Field::__other(
                                _serde::__private::de::Content::I32(__value),
                            ))
                        }
                        fn visit_i64<__E>(
                            self,
                            __value: i64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(__Field::__other(
                                _serde::__private::de::Content::I64(__value),
                            ))
                        }
                        fn visit_u8<__E>(
                            self,
                            __value: u8,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(__Field::__other(
                                _serde::__private::de::Content::U8(__value),
                            ))
                        }
                        fn visit_u16<__E>(
                            self,
                            __value: u16,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(__Field::__other(
                                _serde::__private::de::Content::U16(__value),
                            ))
                        }
                        fn visit_u32<__E>(
                            self,
                            __value: u32,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(__Field::__other(
                                _serde::__private::de::Content::U32(__value),
                            ))
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(__Field::__other(
                                _serde::__private::de::Content::U64(__value),
                            ))
                        }
                        fn visit_f32<__E>(
                            self,
                            __value: f32,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(__Field::__other(
                                _serde::__private::de::Content::F32(__value),
                            ))
                        }
                        fn visit_f64<__E>(
                            self,
                            __value: f64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(__Field::__other(
                                _serde::__private::de::Content::F64(__value),
                            ))
                        }
                        fn visit_char<__E>(
                            self,
                            __value: char,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(__Field::__other(
                                _serde::__private::de::Content::Char(__value),
                            ))
                        }
                        fn visit_unit<__E>(self) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(__Field::__other(
                                _serde::__private::de::Content::Unit,
                            ))
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "env_vars" => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    let __value = _serde::__private::de::Content::String(
                                        _serde::__private::ToString::to_string(__value),
                                    );
                                    _serde::__private::Ok(__Field::__other(__value))
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"env_vars" => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    let __value =
                                        _serde::__private::de::Content::ByteBuf(__value.to_vec());
                                    _serde::__private::Ok(__Field::__other(__value))
                                }
                            }
                        }
                        fn visit_borrowed_str<__E>(
                            self,
                            __value: &'de str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "env_vars" => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    let __value = _serde::__private::de::Content::Str(__value);
                                    _serde::__private::Ok(__Field::__other(__value))
                                }
                            }
                        }
                        fn visit_borrowed_bytes<__E>(
                            self,
                            __value: &'de [u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"env_vars" => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    let __value = _serde::__private::de::Content::Bytes(__value);
                                    _serde::__private::Ok(__Field::__other(__value))
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field<'de> {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<StartServicePayload>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = StartServicePayload;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct StartServicePayload",
                            )
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field1: _serde::__private::Option<HashMap<String, String>> =
                                _serde::__private::None;
                            let mut __collect = _serde::__private::Vec::<
                                _serde::__private::Option<(
                                    _serde::__private::de::Content,
                                    _serde::__private::de::Content,
                                )>,
                            >::new();
                            while let _serde::__private::Some(__key) =
                                _serde::de::MapAccess::next_key::<__Field>(&mut __map)?
                            {
                                match __key {
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "env_vars",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                HashMap<String, String>,
                                            >(
                                                &mut __map
                                            )?,
                                        );
                                    }
                                    __Field::__other(__name) => {
                                        __collect.push(_serde::__private::Some((
                                            __name,
                                            _serde::de::MapAccess::next_value(&mut __map)?,
                                        )));
                                    }
                                }
                            }
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("env_vars")?
                                }
                            };
                            let __field0: ServiceRef = _serde::de::Deserialize::deserialize(
                                _serde::__private::de::FlatMapDeserializer(
                                    &mut __collect,
                                    _serde::__private::PhantomData,
                                ),
                            )?;
                            _serde::__private::Ok(StartServicePayload {
                                service: __field0,
                                env_vars: __field1,
                            })
                        }
                    }
                    _serde::Deserializer::deserialize_map(
                        __deserializer,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<StartServicePayload>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        impl ::bincode::Encode for StartServicePayload {
            fn encode<__E: ::bincode::enc::Encoder>(
                &self,
                encoder: &mut __E,
            ) -> core::result::Result<(), ::bincode::error::EncodeError> {
                ::bincode::Encode::encode(&self.service, encoder)?;
                ::bincode::Encode::encode(&self.env_vars, encoder)?;
                Ok(())
            }
        }
        impl ::bincode::Decode for StartServicePayload {
            fn decode<__D: ::bincode::de::Decoder>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, ::bincode::error::DecodeError> {
                Ok(Self {
                    service: ::bincode::Decode::decode(decoder)?,
                    env_vars: ::bincode::Decode::decode(decoder)?,
                })
            }
        }
        impl<'__de> ::bincode::BorrowDecode<'__de> for StartServicePayload {
            fn borrow_decode<__D: ::bincode::de::BorrowDecoder<'__de>>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, ::bincode::error::DecodeError> {
                Ok(Self {
                    service: ::bincode::BorrowDecode::borrow_decode(decoder)?,
                    env_vars: ::bincode::BorrowDecode::borrow_decode(decoder)?,
                })
            }
        }
        pub enum ServiceRef {
            #[try_from(Option<i64>)]
            Id(i64),
            #[try_from(Option<String>, Option<&str>)]
            Name(String),
        }
        #[automatically_derived]
        impl ::core::clone::Clone for ServiceRef {
            #[inline]
            fn clone(&self) -> ServiceRef {
                match self {
                    ServiceRef::Id(__self_0) => {
                        ServiceRef::Id(::core::clone::Clone::clone(__self_0))
                    }
                    ServiceRef::Name(__self_0) => {
                        ServiceRef::Name(::core::clone::Clone::clone(__self_0))
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for ServiceRef {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    ServiceRef::Id(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Id", &__self_0)
                    }
                    ServiceRef::Name(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Name", &__self_0)
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Ord for ServiceRef {
            #[inline]
            fn cmp(&self, other: &ServiceRef) -> ::core::cmp::Ordering {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                match ::core::cmp::Ord::cmp(&__self_discr, &__arg1_discr) {
                    ::core::cmp::Ordering::Equal => match (self, other) {
                        (ServiceRef::Id(__self_0), ServiceRef::Id(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (ServiceRef::Name(__self_0), ServiceRef::Name(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    },
                    cmp => cmp,
                }
            }
        }
        #[automatically_derived]
        impl ::core::cmp::PartialOrd for ServiceRef {
            #[inline]
            fn partial_cmp(
                &self,
                other: &ServiceRef,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                match (self, other) {
                    (ServiceRef::Id(__self_0), ServiceRef::Id(__arg1_0)) => {
                        ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                    }
                    (ServiceRef::Name(__self_0), ServiceRef::Name(__arg1_0)) => {
                        ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                    }
                    _ => ::core::cmp::PartialOrd::partial_cmp(&__self_discr, &__arg1_discr),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for ServiceRef {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for ServiceRef {
            #[inline]
            fn eq(&self, other: &ServiceRef) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
                    && match (self, other) {
                        (ServiceRef::Id(__self_0), ServiceRef::Id(__arg1_0)) => {
                            __self_0 == __arg1_0
                        }
                        (ServiceRef::Name(__self_0), ServiceRef::Name(__arg1_0)) => {
                            __self_0 == __arg1_0
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for ServiceRef {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<i64>;
                let _: ::core::cmp::AssertParamIsEq<String>;
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for ServiceRef {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                ::core::hash::Hash::hash(&__self_discr, state);
                match self {
                    ServiceRef::Id(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                    ServiceRef::Name(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for ServiceRef {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        ServiceRef::Id(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "ServiceRef",
                                0u32,
                                "Id",
                                __field0,
                            )
                        }
                        ServiceRef::Name(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "ServiceRef",
                                1u32,
                                "Name",
                                __field0,
                            )
                        }
                    }
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for ServiceRef {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Err(_serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"variant index 0 <= i < 2",
                                )),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "Id" => _serde::__private::Ok(__Field::__field0),
                                "Name" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                )),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"Id" => _serde::__private::Ok(__Field::__field0),
                                b"Name" => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(_serde::de::Error::unknown_variant(
                                        __value, VARIANTS,
                                    ))
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<ServiceRef>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = ServiceRef;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter, "enum ServiceRef")
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match _serde::de::EnumAccess::variant(__data)? {
                                (__Field::__field0, __variant) => _serde::__private::Result::map(
                                    _serde::de::VariantAccess::newtype_variant::<i64>(__variant),
                                    ServiceRef::Id,
                                ),
                                (__Field::__field1, __variant) => _serde::__private::Result::map(
                                    _serde::de::VariantAccess::newtype_variant::<String>(__variant),
                                    ServiceRef::Name,
                                ),
                            }
                        }
                    }
                    #[doc(hidden)]
                    const VARIANTS: &'static [&'static str] = &["Id", "Name"];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "ServiceRef",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<ServiceRef>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        impl ::bincode::Encode for ServiceRef {
            fn encode<__E: ::bincode::enc::Encoder>(
                &self,
                encoder: &mut __E,
            ) -> core::result::Result<(), ::bincode::error::EncodeError> {
                match self {
                    Self::Id(field_0) => {
                        <u32 as ::bincode::Encode>::encode(&(0u32), encoder)?;
                        ::bincode::Encode::encode(field_0, encoder)?;
                        Ok(())
                    }
                    Self::Name(field_0) => {
                        <u32 as ::bincode::Encode>::encode(&(1u32), encoder)?;
                        ::bincode::Encode::encode(field_0, encoder)?;
                        Ok(())
                    }
                }
            }
        }
        impl ::bincode::Decode for ServiceRef {
            fn decode<__D: ::bincode::de::Decoder>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, ::bincode::error::DecodeError> {
                let variant_index = <u32 as ::bincode::Decode>::decode(decoder)?;
                match variant_index {
                    0u32 => Ok(Self::Id {
                        0: ::bincode::Decode::decode(decoder)?,
                    }),
                    1u32 => Ok(Self::Name {
                        0: ::bincode::Decode::decode(decoder)?,
                    }),
                    variant => Err(::bincode::error::DecodeError::UnexpectedVariant {
                        found: variant,
                        type_name: "ServiceRef",
                        allowed: &::bincode::error::AllowedEnumVariants::Range { min: 0, max: 1 },
                    }),
                }
            }
        }
        impl<'__de> ::bincode::BorrowDecode<'__de> for ServiceRef {
            fn borrow_decode<__D: ::bincode::de::BorrowDecoder<'__de>>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, ::bincode::error::DecodeError> {
                let variant_index = <u32 as ::bincode::Decode>::decode(decoder)?;
                match variant_index {
                    0u32 => Ok(Self::Id {
                        0: ::bincode::BorrowDecode::borrow_decode(decoder)?,
                    }),
                    1u32 => Ok(Self::Name {
                        0: ::bincode::BorrowDecode::borrow_decode(decoder)?,
                    }),
                    variant => Err(::bincode::error::DecodeError::UnexpectedVariant {
                        found: variant,
                        type_name: "ServiceRef",
                        allowed: &::bincode::error::AllowedEnumVariants::Range { min: 0, max: 1 },
                    }),
                }
            }
        }
        #[automatically_derived]
        impl derive_more::From<(i64)> for ServiceRef {
            #[inline]
            fn from(value: (i64)) -> Self {
                ServiceRef::Id(value)
            }
        }
        #[automatically_derived]
        impl derive_more::From<(String)> for ServiceRef {
            #[inline]
            fn from(value: (String)) -> Self {
                ServiceRef::Name(value)
            }
        }
        #[automatically_derived]
        impl derive_more::Display for ServiceRef {
            fn fmt(
                &self,
                __derive_more_f: &mut derive_more::core::fmt::Formatter<'_>,
            ) -> derive_more::core::fmt::Result {
                match self {
                    Self::Id(_0) => derive_more::core::fmt::Display::fmt(_0, __derive_more_f),
                    Self::Name(_0) => derive_more::core::fmt::Display::fmt(_0, __derive_more_f),
                }
            }
        }
        impl Default for ServiceRef {
            fn default() -> Self {
                Self::Id(1)
            }
        }
        impl FromStr for ServiceRef {
            type Err = anyhow::Error;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                if let Ok(id) = s.parse() {
                    Ok(Self::Id(id))
                } else {
                    Ok(Self::Name(s.to_owned()))
                }
            }
        }
    }
    pub mod service_status {
        use crate::commands::dependency_info::DependencyInfo;
        use crate::commands::manage_service::ServiceRef;
        use crate::commands::CommandPayload;
        use crate::{service_command, try_from};
        use bincode::{Decode, Encode};
        use derive_more::Display;
        use serde::{Deserialize, Serialize};
        use sqlx::Type;
        pub struct GetServiceStatus(ServiceRef);
        impl GetServiceStatus {
            pub fn new(input: impl Into<ServiceRef>) -> Self {
                Self(input.into())
            }
        }
        impl crate::traits::ServiceCommand for GetServiceStatus {
            type Input = ServiceRef;
            type Output = ServiceStatus;
            const COMMAND: crate::commands::Command = crate::commands::Command::GetServiceStatus;
            fn into_payload(self) -> Self::Input {
                self.0
            }
        }
        impl From<GetServiceStatus> for <GetServiceStatus as crate::traits::ServiceCommand>::Input {
            fn from(command: GetServiceStatus) -> Self {
                use crate::traits::ServiceCommand;
                command.into_payload()
            }
        }
        impl From<ServiceRef> for GetServiceStatus {
            fn from(input: ServiceRef) -> Self {
                Self::new(input)
            }
        }
        pub struct ServiceStatus {
            pub id: i64,
            pub name: String,
            pub state: ServiceState,
            #[serde(skip_serializing_if = "Option::is_none")]
            pub config_id: Option<i64>,
            pub port: i64,
            pub repo_url: String,
            pub repo_path: String,
            pub dependencies: Vec<DependencyInfo>,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for ServiceStatus {
            #[inline]
            fn clone(&self) -> ServiceStatus {
                ServiceStatus {
                    id: ::core::clone::Clone::clone(&self.id),
                    name: ::core::clone::Clone::clone(&self.name),
                    state: ::core::clone::Clone::clone(&self.state),
                    config_id: ::core::clone::Clone::clone(&self.config_id),
                    port: ::core::clone::Clone::clone(&self.port),
                    repo_url: ::core::clone::Clone::clone(&self.repo_url),
                    repo_path: ::core::clone::Clone::clone(&self.repo_path),
                    dependencies: ::core::clone::Clone::clone(&self.dependencies),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for ServiceStatus {
            #[inline]
            fn default() -> ServiceStatus {
                ServiceStatus {
                    id: ::core::default::Default::default(),
                    name: ::core::default::Default::default(),
                    state: ::core::default::Default::default(),
                    config_id: ::core::default::Default::default(),
                    port: ::core::default::Default::default(),
                    repo_url: ::core::default::Default::default(),
                    repo_path: ::core::default::Default::default(),
                    dependencies: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for ServiceStatus {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "id",
                    "name",
                    "state",
                    "config_id",
                    "port",
                    "repo_url",
                    "repo_path",
                    "dependencies",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.id,
                    &self.name,
                    &self.state,
                    &self.config_id,
                    &self.port,
                    &self.repo_url,
                    &self.repo_path,
                    &&self.dependencies,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "ServiceStatus",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Ord for ServiceStatus {
            #[inline]
            fn cmp(&self, other: &ServiceStatus) -> ::core::cmp::Ordering {
                match ::core::cmp::Ord::cmp(&self.id, &other.id) {
                    ::core::cmp::Ordering::Equal => {
                        match ::core::cmp::Ord::cmp(&self.name, &other.name) {
                            ::core::cmp::Ordering::Equal => {
                                match ::core::cmp::Ord::cmp(&self.state, &other.state) {
                                    ::core::cmp::Ordering::Equal => {
                                        match ::core::cmp::Ord::cmp(
                                            &self.config_id,
                                            &other.config_id,
                                        ) {
                                            ::core::cmp::Ordering::Equal => {
                                                match ::core::cmp::Ord::cmp(&self.port, &other.port) {
                                                    ::core::cmp::Ordering::Equal => {
                                                        match ::core::cmp::Ord::cmp(
                                                            &self.repo_url,
                                                            &other.repo_url,
                                                        ) {
                                                            ::core::cmp::Ordering::Equal => {
                                                                match ::core::cmp::Ord::cmp(
                                                                    &self.repo_path,
                                                                    &other.repo_path,
                                                                ) {
                                                                    ::core::cmp::Ordering::Equal => {
                                                                        ::core::cmp::Ord::cmp(
                                                                            &self.dependencies,
                                                                            &other.dependencies,
                                                                        )
                                                                    }
                                                                    cmp => cmp,
                                                                }
                                                            }
                                                            cmp => cmp,
                                                        }
                                                    }
                                                    cmp => cmp,
                                                }
                                            }
                                            cmp => cmp,
                                        }
                                    }
                                    cmp => cmp,
                                }
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
        }
        #[automatically_derived]
        impl ::core::cmp::PartialOrd for ServiceStatus {
            #[inline]
            fn partial_cmp(
                &self,
                other: &ServiceStatus,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                match ::core::cmp::PartialOrd::partial_cmp(&self.id, &other.id) {
                    ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                        match ::core::cmp::PartialOrd::partial_cmp(&self.name, &other.name) {
                            ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                                match ::core::cmp::PartialOrd::partial_cmp(
                                    &self.state,
                                    &other.state,
                                ) {
                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                                        match ::core::cmp::PartialOrd::partial_cmp(
                                            &self.config_id,
                                            &other.config_id,
                                        ) {
                                            ::core::option::Option::Some(
                                                ::core::cmp::Ordering::Equal,
                                            ) => {
                                                match ::core::cmp::PartialOrd::partial_cmp(
                                                    &self.port,
                                                    &other.port,
                                                ) {
                                                    ::core::option::Option::Some(
                                                        ::core::cmp::Ordering::Equal,
                                                    ) => {
                                                        match ::core::cmp::PartialOrd::partial_cmp(
                                                            &self.repo_url,
                                                            &other.repo_url,
                                                        ) {
                                                            ::core::option::Option::Some(
                                                                ::core::cmp::Ordering::Equal,
                                                            ) => {
                                                                match ::core::cmp::PartialOrd::partial_cmp(
                                                                    &self.repo_path,
                                                                    &other.repo_path,
                                                                ) {
                                                                    ::core::option::Option::Some(
                                                                        ::core::cmp::Ordering::Equal,
                                                                    ) => {
                                                                        ::core::cmp::PartialOrd::partial_cmp(
                                                                            &self.dependencies,
                                                                            &other.dependencies,
                                                                        )
                                                                    }
                                                                    cmp => cmp,
                                                                }
                                                            }
                                                            cmp => cmp,
                                                        }
                                                    }
                                                    cmp => cmp,
                                                }
                                            }
                                            cmp => cmp,
                                        }
                                    }
                                    cmp => cmp,
                                }
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for ServiceStatus {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for ServiceStatus {
            #[inline]
            fn eq(&self, other: &ServiceStatus) -> bool {
                self.id == other.id
                    && self.name == other.name
                    && self.state == other.state
                    && self.config_id == other.config_id
                    && self.port == other.port
                    && self.repo_url == other.repo_url
                    && self.repo_path == other.repo_path
                    && self.dependencies == other.dependencies
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for ServiceStatus {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<i64>;
                let _: ::core::cmp::AssertParamIsEq<String>;
                let _: ::core::cmp::AssertParamIsEq<ServiceState>;
                let _: ::core::cmp::AssertParamIsEq<Option<i64>>;
                let _: ::core::cmp::AssertParamIsEq<Vec<DependencyInfo>>;
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for ServiceStatus {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.id, state);
                ::core::hash::Hash::hash(&self.name, state);
                ::core::hash::Hash::hash(&self.state, state);
                ::core::hash::Hash::hash(&self.config_id, state);
                ::core::hash::Hash::hash(&self.port, state);
                ::core::hash::Hash::hash(&self.repo_url, state);
                ::core::hash::Hash::hash(&self.repo_path, state);
                ::core::hash::Hash::hash(&self.dependencies, state)
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for ServiceStatus {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "ServiceStatus",
                        false as usize
                            + 1
                            + 1
                            + 1
                            + if Option::is_none(&self.config_id) {
                                0
                            } else {
                                1
                            }
                            + 1
                            + 1
                            + 1
                            + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "id",
                        &self.id,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "name",
                        &self.name,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "state",
                        &self.state,
                    )?;
                    if !Option::is_none(&self.config_id) {
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "config_id",
                            &self.config_id,
                        )?;
                    } else {
                        _serde::ser::SerializeStruct::skip_field(&mut __serde_state, "config_id")?;
                    }
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "port",
                        &self.port,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "repo_url",
                        &self.repo_url,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "repo_path",
                        &self.repo_path,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "dependencies",
                        &self.dependencies,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for ServiceStatus {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __field4,
                        __field5,
                        __field6,
                        __field7,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                4u64 => _serde::__private::Ok(__Field::__field4),
                                5u64 => _serde::__private::Ok(__Field::__field5),
                                6u64 => _serde::__private::Ok(__Field::__field6),
                                7u64 => _serde::__private::Ok(__Field::__field7),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "id" => _serde::__private::Ok(__Field::__field0),
                                "name" => _serde::__private::Ok(__Field::__field1),
                                "state" => _serde::__private::Ok(__Field::__field2),
                                "config_id" => _serde::__private::Ok(__Field::__field3),
                                "port" => _serde::__private::Ok(__Field::__field4),
                                "repo_url" => _serde::__private::Ok(__Field::__field5),
                                "repo_path" => _serde::__private::Ok(__Field::__field6),
                                "dependencies" => _serde::__private::Ok(__Field::__field7),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"id" => _serde::__private::Ok(__Field::__field0),
                                b"name" => _serde::__private::Ok(__Field::__field1),
                                b"state" => _serde::__private::Ok(__Field::__field2),
                                b"config_id" => _serde::__private::Ok(__Field::__field3),
                                b"port" => _serde::__private::Ok(__Field::__field4),
                                b"repo_url" => _serde::__private::Ok(__Field::__field5),
                                b"repo_path" => _serde::__private::Ok(__Field::__field6),
                                b"dependencies" => _serde::__private::Ok(__Field::__field7),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<ServiceStatus>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = ServiceStatus;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct ServiceStatus",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 =
                                match _serde::de::SeqAccess::next_element::<i64>(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct ServiceStatus with 8 elements",
                                            ),
                                        );
                                    }
                                };
                            let __field1 =
                                match _serde::de::SeqAccess::next_element::<String>(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct ServiceStatus with 8 elements",
                                            ),
                                        );
                                    }
                                };
                            let __field2 = match _serde::de::SeqAccess::next_element::<ServiceState>(
                                &mut __seq,
                            )? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct ServiceStatus with 8 elements",
                                        ),
                                    );
                                }
                            };
                            let __field3 = match _serde::de::SeqAccess::next_element::<Option<i64>>(
                                &mut __seq,
                            )? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            3usize,
                                            &"struct ServiceStatus with 8 elements",
                                        ),
                                    );
                                }
                            };
                            let __field4 =
                                match _serde::de::SeqAccess::next_element::<i64>(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                4usize,
                                                &"struct ServiceStatus with 8 elements",
                                            ),
                                        );
                                    }
                                };
                            let __field5 =
                                match _serde::de::SeqAccess::next_element::<String>(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                5usize,
                                                &"struct ServiceStatus with 8 elements",
                                            ),
                                        );
                                    }
                                };
                            let __field6 =
                                match _serde::de::SeqAccess::next_element::<String>(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                6usize,
                                                &"struct ServiceStatus with 8 elements",
                                            ),
                                        );
                                    }
                                };
                            let __field7 = match _serde::de::SeqAccess::next_element::<
                                Vec<DependencyInfo>,
                            >(&mut __seq)?
                            {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            7usize,
                                            &"struct ServiceStatus with 8 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(ServiceStatus {
                                id: __field0,
                                name: __field1,
                                state: __field2,
                                config_id: __field3,
                                port: __field4,
                                repo_url: __field5,
                                repo_path: __field6,
                                dependencies: __field7,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<i64> =
                                _serde::__private::None;
                            let mut __field1: _serde::__private::Option<String> =
                                _serde::__private::None;
                            let mut __field2: _serde::__private::Option<ServiceState> =
                                _serde::__private::None;
                            let mut __field3: _serde::__private::Option<Option<i64>> =
                                _serde::__private::None;
                            let mut __field4: _serde::__private::Option<i64> =
                                _serde::__private::None;
                            let mut __field5: _serde::__private::Option<String> =
                                _serde::__private::None;
                            let mut __field6: _serde::__private::Option<String> =
                                _serde::__private::None;
                            let mut __field7: _serde::__private::Option<Vec<DependencyInfo>> =
                                _serde::__private::None;
                            while let _serde::__private::Some(__key) =
                                _serde::de::MapAccess::next_key::<__Field>(&mut __map)?
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "id",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "name",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(
                                                &mut __map,
                                            )?,
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "state",
                                                ),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<ServiceState>(
                                                &mut __map,
                                            )?,
                                        );
                                    }
                                    __Field::__field3 => {
                                        if _serde::__private::Option::is_some(&__field3) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "config_id",
                                                ),
                                            );
                                        }
                                        __field3 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<Option<i64>>(
                                                &mut __map,
                                            )?,
                                        );
                                    }
                                    __Field::__field4 => {
                                        if _serde::__private::Option::is_some(&__field4) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "port",
                                                ),
                                            );
                                        }
                                        __field4 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field5 => {
                                        if _serde::__private::Option::is_some(&__field5) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "repo_url",
                                                ),
                                            );
                                        }
                                        __field5 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(
                                                &mut __map,
                                            )?,
                                        );
                                    }
                                    __Field::__field6 => {
                                        if _serde::__private::Option::is_some(&__field6) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "repo_path",
                                                ),
                                            );
                                        }
                                        __field6 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(
                                                &mut __map,
                                            )?,
                                        );
                                    }
                                    __Field::__field7 => {
                                        if _serde::__private::Option::is_some(&__field7) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "dependencies",
                                                ),
                                            );
                                        }
                                        __field7 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<Vec<DependencyInfo>>(
                                                &mut __map,
                                            )?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        )?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("id")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("name")?
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("state")?
                                }
                            };
                            let __field3 = match __field3 {
                                _serde::__private::Some(__field3) => __field3,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("config_id")?
                                }
                            };
                            let __field4 = match __field4 {
                                _serde::__private::Some(__field4) => __field4,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("port")?
                                }
                            };
                            let __field5 = match __field5 {
                                _serde::__private::Some(__field5) => __field5,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("repo_url")?
                                }
                            };
                            let __field6 = match __field6 {
                                _serde::__private::Some(__field6) => __field6,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("repo_path")?
                                }
                            };
                            let __field7 = match __field7 {
                                _serde::__private::Some(__field7) => __field7,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("dependencies")?
                                }
                            };
                            _serde::__private::Ok(ServiceStatus {
                                id: __field0,
                                name: __field1,
                                state: __field2,
                                config_id: __field3,
                                port: __field4,
                                repo_url: __field5,
                                repo_path: __field6,
                                dependencies: __field7,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[
                        "id",
                        "name",
                        "state",
                        "config_id",
                        "port",
                        "repo_url",
                        "repo_path",
                        "dependencies",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "ServiceStatus",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<ServiceStatus>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        impl ::bincode::Encode for ServiceStatus {
            fn encode<__E: ::bincode::enc::Encoder>(
                &self,
                encoder: &mut __E,
            ) -> core::result::Result<(), ::bincode::error::EncodeError> {
                ::bincode::Encode::encode(&self.id, encoder)?;
                ::bincode::Encode::encode(&self.name, encoder)?;
                ::bincode::Encode::encode(&self.state, encoder)?;
                ::bincode::Encode::encode(&self.config_id, encoder)?;
                ::bincode::Encode::encode(&self.port, encoder)?;
                ::bincode::Encode::encode(&self.repo_url, encoder)?;
                ::bincode::Encode::encode(&self.repo_path, encoder)?;
                ::bincode::Encode::encode(&self.dependencies, encoder)?;
                Ok(())
            }
        }
        impl ::bincode::Decode for ServiceStatus {
            fn decode<__D: ::bincode::de::Decoder>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, ::bincode::error::DecodeError> {
                Ok(Self {
                    id: ::bincode::Decode::decode(decoder)?,
                    name: ::bincode::Decode::decode(decoder)?,
                    state: ::bincode::Decode::decode(decoder)?,
                    config_id: ::bincode::Decode::decode(decoder)?,
                    port: ::bincode::Decode::decode(decoder)?,
                    repo_url: ::bincode::Decode::decode(decoder)?,
                    repo_path: ::bincode::Decode::decode(decoder)?,
                    dependencies: ::bincode::Decode::decode(decoder)?,
                })
            }
        }
        impl<'__de> ::bincode::BorrowDecode<'__de> for ServiceStatus {
            fn borrow_decode<__D: ::bincode::de::BorrowDecoder<'__de>>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, ::bincode::error::DecodeError> {
                Ok(Self {
                    id: ::bincode::BorrowDecode::borrow_decode(decoder)?,
                    name: ::bincode::BorrowDecode::borrow_decode(decoder)?,
                    state: ::bincode::BorrowDecode::borrow_decode(decoder)?,
                    config_id: ::bincode::BorrowDecode::borrow_decode(decoder)?,
                    port: ::bincode::BorrowDecode::borrow_decode(decoder)?,
                    repo_url: ::bincode::BorrowDecode::borrow_decode(decoder)?,
                    repo_path: ::bincode::BorrowDecode::borrow_decode(decoder)?,
                    dependencies: ::bincode::BorrowDecode::borrow_decode(decoder)?,
                })
            }
        }
        impl TryFrom<CommandPayload> for ServiceStatus {
            type Error = ::anyhow::Error;
            fn try_from(value: CommandPayload) -> Result<Self, Self::Error> {
                #[allow(unused_imports)]
                use crate::commands::CommandPayload::Status;
                if !value.is_status() {
                    return ::anyhow::__private::Err(::anyhow::Error::msg(
                        ::alloc::__export::must_use({
                            let res = ::alloc::fmt::format(format_args!(
                                "Command is not of type `{0}`",
                                "Status"
                            ));
                            res
                        }),
                    ));
                }
                Ok(value.unwrap_status())
            }
        }
        pub enum ServiceState {
            Starting,
            Running,
            Stopping,
            #[default]
            Stopped,
            Failed,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for ServiceState {
            #[inline]
            fn clone(&self) -> ServiceState {
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for ServiceState {}
        #[automatically_derived]
        impl ::core::default::Default for ServiceState {
            #[inline]
            fn default() -> ServiceState {
                Self::Stopped
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for ServiceState {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        ServiceState::Starting => "Starting",
                        ServiceState::Running => "Running",
                        ServiceState::Stopping => "Stopping",
                        ServiceState::Stopped => "Stopped",
                        ServiceState::Failed => "Failed",
                    },
                )
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Ord for ServiceState {
            #[inline]
            fn cmp(&self, other: &ServiceState) -> ::core::cmp::Ordering {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                ::core::cmp::Ord::cmp(&__self_discr, &__arg1_discr)
            }
        }
        #[automatically_derived]
        impl ::core::cmp::PartialOrd for ServiceState {
            #[inline]
            fn partial_cmp(
                &self,
                other: &ServiceState,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                ::core::cmp::PartialOrd::partial_cmp(&__self_discr, &__arg1_discr)
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for ServiceState {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for ServiceState {
            #[inline]
            fn eq(&self, other: &ServiceState) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for ServiceState {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {}
        }
        #[automatically_derived]
        impl ::core::hash::Hash for ServiceState {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                ::core::hash::Hash::hash(&__self_discr, state)
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for ServiceState {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        ServiceState::Starting => _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "ServiceState",
                            0u32,
                            "Starting",
                        ),
                        ServiceState::Running => _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "ServiceState",
                            1u32,
                            "Running",
                        ),
                        ServiceState::Stopping => _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "ServiceState",
                            2u32,
                            "Stopping",
                        ),
                        ServiceState::Stopped => _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "ServiceState",
                            3u32,
                            "Stopped",
                        ),
                        ServiceState::Failed => _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "ServiceState",
                            4u32,
                            "Failed",
                        ),
                    }
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for ServiceState {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __field4,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                4u64 => _serde::__private::Ok(__Field::__field4),
                                _ => _serde::__private::Err(_serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"variant index 0 <= i < 5",
                                )),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "Starting" => _serde::__private::Ok(__Field::__field0),
                                "Running" => _serde::__private::Ok(__Field::__field1),
                                "Stopping" => _serde::__private::Ok(__Field::__field2),
                                "Stopped" => _serde::__private::Ok(__Field::__field3),
                                "Failed" => _serde::__private::Ok(__Field::__field4),
                                _ => _serde::__private::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                )),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"Starting" => _serde::__private::Ok(__Field::__field0),
                                b"Running" => _serde::__private::Ok(__Field::__field1),
                                b"Stopping" => _serde::__private::Ok(__Field::__field2),
                                b"Stopped" => _serde::__private::Ok(__Field::__field3),
                                b"Failed" => _serde::__private::Ok(__Field::__field4),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(_serde::de::Error::unknown_variant(
                                        __value, VARIANTS,
                                    ))
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<ServiceState>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = ServiceState;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum ServiceState",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match _serde::de::EnumAccess::variant(__data)? {
                                (__Field::__field0, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(ServiceState::Starting)
                                }
                                (__Field::__field1, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(ServiceState::Running)
                                }
                                (__Field::__field2, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(ServiceState::Stopping)
                                }
                                (__Field::__field3, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(ServiceState::Stopped)
                                }
                                (__Field::__field4, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(ServiceState::Failed)
                                }
                            }
                        }
                    }
                    #[doc(hidden)]
                    const VARIANTS: &'static [&'static str] =
                        &["Starting", "Running", "Stopping", "Stopped", "Failed"];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "ServiceState",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<ServiceState>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        impl<'q, DB: ::sqlx::Database> ::sqlx::encode::Encode<'q, DB> for ServiceState
        where
            &'q ::std::primitive::str: ::sqlx::encode::Encode<'q, DB>,
        {
            fn encode_by_ref(
                &self,
                buf: &mut <DB as ::sqlx::database::Database>::ArgumentBuffer<'q>,
            ) -> ::std::result::Result<::sqlx::encode::IsNull, ::sqlx::error::BoxDynError>
            {
                let val = match self {
                    ServiceState::Starting => "Starting",
                    ServiceState::Running => "Running",
                    ServiceState::Stopping => "Stopping",
                    ServiceState::Stopped => "Stopped",
                    ServiceState::Failed => "Failed",
                };
                <&::std::primitive::str as ::sqlx::encode::Encode<'q, DB>>::encode(val, buf)
            }
            fn size_hint(&self) -> ::std::primitive::usize {
                let val = match self {
                    ServiceState::Starting => "Starting",
                    ServiceState::Running => "Running",
                    ServiceState::Stopping => "Stopping",
                    ServiceState::Stopped => "Stopped",
                    ServiceState::Failed => "Failed",
                };
                <&::std::primitive::str as ::sqlx::encode::Encode<'q, DB>>::size_hint(&val)
            }
        }
        #[automatically_derived]
        impl<'r> ::sqlx::decode::Decode<'r, ::sqlx::sqlite::Sqlite> for ServiceState {
            fn decode(
                value: ::sqlx::sqlite::SqliteValueRef<'r>,
            ) -> ::std::result::Result<
                Self,
                ::std::boxed::Box<
                    dyn ::std::error::Error + 'static + ::std::marker::Send + ::std::marker::Sync,
                >,
            > {
                let value = <&'r ::std::primitive::str as ::sqlx::decode::Decode<
                    'r,
                    ::sqlx::sqlite::Sqlite,
                >>::decode(value)?;
                match value {
                    "Starting" => ::std::result::Result::Ok(ServiceState::Starting),
                    "Running" => ::std::result::Result::Ok(ServiceState::Running),
                    "Stopping" => ::std::result::Result::Ok(ServiceState::Stopping),
                    "Stopped" => ::std::result::Result::Ok(ServiceState::Stopped),
                    "Failed" => ::std::result::Result::Ok(ServiceState::Failed),
                    _ => Err(::alloc::__export::must_use({
                        let res = ::alloc::fmt::format(format_args!(
                            "invalid value {0:?} for enum {1}",
                            value, "ServiceState",
                        ));
                        res
                    })
                    .into()),
                }
            }
        }
        #[automatically_derived]
        impl sqlx::Type<::sqlx::Sqlite> for ServiceState {
            fn type_info() -> ::sqlx::sqlite::SqliteTypeInfo {
                <::std::primitive::str as ::sqlx::Type<sqlx::Sqlite>>::type_info()
            }
            fn compatible(ty: &::sqlx::sqlite::SqliteTypeInfo) -> ::std::primitive::bool {
                <&::std::primitive::str as ::sqlx::types::Type<sqlx::sqlite::Sqlite>>::compatible(
                    ty,
                )
            }
        }
        impl ::bincode::Encode for ServiceState {
            fn encode<__E: ::bincode::enc::Encoder>(
                &self,
                encoder: &mut __E,
            ) -> core::result::Result<(), ::bincode::error::EncodeError> {
                match self {
                    Self::Starting => {
                        <u32 as ::bincode::Encode>::encode(&(0u32), encoder)?;
                        Ok(())
                    }
                    Self::Running => {
                        <u32 as ::bincode::Encode>::encode(&(1u32), encoder)?;
                        Ok(())
                    }
                    Self::Stopping => {
                        <u32 as ::bincode::Encode>::encode(&(2u32), encoder)?;
                        Ok(())
                    }
                    Self::Stopped => {
                        <u32 as ::bincode::Encode>::encode(&(3u32), encoder)?;
                        Ok(())
                    }
                    Self::Failed => {
                        <u32 as ::bincode::Encode>::encode(&(4u32), encoder)?;
                        Ok(())
                    }
                }
            }
        }
        impl ::bincode::Decode for ServiceState {
            fn decode<__D: ::bincode::de::Decoder>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, ::bincode::error::DecodeError> {
                let variant_index = <u32 as ::bincode::Decode>::decode(decoder)?;
                match variant_index {
                    0u32 => Ok(Self::Starting {}),
                    1u32 => Ok(Self::Running {}),
                    2u32 => Ok(Self::Stopping {}),
                    3u32 => Ok(Self::Stopped {}),
                    4u32 => Ok(Self::Failed {}),
                    variant => Err(::bincode::error::DecodeError::UnexpectedVariant {
                        found: variant,
                        type_name: "ServiceState",
                        allowed: &::bincode::error::AllowedEnumVariants::Range { min: 0, max: 4 },
                    }),
                }
            }
        }
        impl<'__de> ::bincode::BorrowDecode<'__de> for ServiceState {
            fn borrow_decode<__D: ::bincode::de::BorrowDecoder<'__de>>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, ::bincode::error::DecodeError> {
                let variant_index = <u32 as ::bincode::Decode>::decode(decoder)?;
                match variant_index {
                    0u32 => Ok(Self::Starting {}),
                    1u32 => Ok(Self::Running {}),
                    2u32 => Ok(Self::Stopping {}),
                    3u32 => Ok(Self::Stopped {}),
                    4u32 => Ok(Self::Failed {}),
                    variant => Err(::bincode::error::DecodeError::UnexpectedVariant {
                        found: variant,
                        type_name: "ServiceState",
                        allowed: &::bincode::error::AllowedEnumVariants::Range { min: 0, max: 4 },
                    }),
                }
            }
        }
        #[automatically_derived]
        impl derive_more::Display for ServiceState {
            fn fmt(
                &self,
                __derive_more_f: &mut derive_more::core::fmt::Formatter<'_>,
            ) -> derive_more::core::fmt::Result {
                match self {
                    Self::Starting => __derive_more_f.write_str("Starting"),
                    Self::Running => __derive_more_f.write_str("Running"),
                    Self::Stopping => __derive_more_f.write_str("Stopping"),
                    Self::Stopped => __derive_more_f.write_str("Stopped"),
                    Self::Failed => __derive_more_f.write_str("Failed"),
                }
            }
        }
        impl From<String> for ServiceState {
            fn from(value: String) -> Self {
                match value.as_str() {
                    "Starting" => Self::Starting,
                    "Running" => Self::Running,
                    "Stopping" => Self::Stopping,
                    "Stopped" => Self::Stopped,
                    "Failed" => Self::Failed,
                    _ => Self::Stopped,
                }
            }
        }
    }
    use crate::commands::add_service::AddServiceCommand;
    use crate::commands::config::{GetConfig, ServiceConfigPayload, UpdateConfigCommand};
    use crate::commands::dependency::{
        AddDependencyCommand, ListDependenciesCommand, ListDependenciesResponse,
        RemoveDependencyCommand,
    };
    use crate::commands::error::ErrorPayload;
    use crate::commands::git::{CheckoutCommand, GetRepoStatusCommand};
    use crate::commands::list_services::{ListServicesCommand, ListServicesResponse};
    use crate::commands::manage_service::{
        RemoveServiceCommand, RestartServiceCommand, StartServiceCommand, StopServiceCommand,
    };
    use crate::commands::service_status::{GetServiceStatus, ServiceStatus};
    use crate::service_command;
    use bincode::{Decode, Encode};
    use binrw::{BinRead, BinWrite};
    use derive_more::{From, Into, IsVariant, TryUnwrap, Unwrap};
    use savefile::prelude::Savefile;
    use serde::{Deserialize, Serialize};
    #[brw(repr(u16), big)]
    #[non_exhaustive]
    pub enum Command {
        StartService = 1,
        StopService = 2,
        RestartService = 3,
        GetServiceStatus = 4,
        AddService = 5,
        RemoveService = 6,
        ListServices = 7,
        UpdateConfig = 10,
        GetConfig = 11,
        AddDependency = 20,
        RemoveDependency = 21,
        ListDependencies = 22,
        CheckoutBranch = 30,
        GetRepoStatus = 31,
        Shutdown = 40,
        GetSystemStatus = 41,
        Ping = 42,
        Success = 0xFFF0,
        Error = 0xFFFF,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Command {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    Command::StartService => "StartService",
                    Command::StopService => "StopService",
                    Command::RestartService => "RestartService",
                    Command::GetServiceStatus => "GetServiceStatus",
                    Command::AddService => "AddService",
                    Command::RemoveService => "RemoveService",
                    Command::ListServices => "ListServices",
                    Command::UpdateConfig => "UpdateConfig",
                    Command::GetConfig => "GetConfig",
                    Command::AddDependency => "AddDependency",
                    Command::RemoveDependency => "RemoveDependency",
                    Command::ListDependencies => "ListDependencies",
                    Command::CheckoutBranch => "CheckoutBranch",
                    Command::GetRepoStatus => "GetRepoStatus",
                    Command::Shutdown => "Shutdown",
                    Command::GetSystemStatus => "GetSystemStatus",
                    Command::Ping => "Ping",
                    Command::Success => "Success",
                    Command::Error => "Error",
                },
            )
        }
    }
    #[automatically_derived]
    #[allow(non_snake_case, unknown_lints)]
    #[allow(clippy::redundant_closure_call)]
    impl binrw::BinRead for Command {
        type Args<'__binrw_generated_args_lifetime> = ();
        fn read_options<R: binrw::io::Read + binrw::io::Seek>(
            __binrw_generated_var_reader: &mut R,
            __binrw_generated_var_endian: binrw::Endian,
            __binrw_generated_var_arguments: Self::Args<'_>,
        ) -> binrw::BinResult<Self> {
            let __binrw_generated_var_reader = __binrw_generated_var_reader;
            let __binrw_generated_position_temp =
                binrw::io::Seek::stream_position(__binrw_generated_var_reader)?;
            (|| {
                let __binrw_generated_var_endian = binrw::Endian::Big;
                let __binrw_temp: u16 = binrw::BinRead::read_options(
                    __binrw_generated_var_reader,
                    __binrw_generated_var_endian,
                    (),
                )?;
                if __binrw_temp == Self::StartService as u16 {
                    Ok(Self::StartService)
                } else if __binrw_temp == Self::StopService as u16 {
                    Ok(Self::StopService)
                } else if __binrw_temp == Self::RestartService as u16 {
                    Ok(Self::RestartService)
                } else if __binrw_temp == Self::GetServiceStatus as u16 {
                    Ok(Self::GetServiceStatus)
                } else if __binrw_temp == Self::AddService as u16 {
                    Ok(Self::AddService)
                } else if __binrw_temp == Self::RemoveService as u16 {
                    Ok(Self::RemoveService)
                } else if __binrw_temp == Self::ListServices as u16 {
                    Ok(Self::ListServices)
                } else if __binrw_temp == Self::UpdateConfig as u16 {
                    Ok(Self::UpdateConfig)
                } else if __binrw_temp == Self::GetConfig as u16 {
                    Ok(Self::GetConfig)
                } else if __binrw_temp == Self::AddDependency as u16 {
                    Ok(Self::AddDependency)
                } else if __binrw_temp == Self::RemoveDependency as u16 {
                    Ok(Self::RemoveDependency)
                } else if __binrw_temp == Self::ListDependencies as u16 {
                    Ok(Self::ListDependencies)
                } else if __binrw_temp == Self::CheckoutBranch as u16 {
                    Ok(Self::CheckoutBranch)
                } else if __binrw_temp == Self::GetRepoStatus as u16 {
                    Ok(Self::GetRepoStatus)
                } else if __binrw_temp == Self::Shutdown as u16 {
                    Ok(Self::Shutdown)
                } else if __binrw_temp == Self::GetSystemStatus as u16 {
                    Ok(Self::GetSystemStatus)
                } else if __binrw_temp == Self::Ping as u16 {
                    Ok(Self::Ping)
                } else if __binrw_temp == Self::Success as u16 {
                    Ok(Self::Success)
                } else if __binrw_temp == Self::Error as u16 {
                    Ok(Self::Error)
                } else {
                    Err(binrw::error::ContextExt::with_context(
                        binrw::Error::NoVariantMatch {
                            pos: __binrw_generated_position_temp,
                        },
                        binrw::error::BacktraceFrame::Message({
                            extern crate alloc;
                            ::alloc::__export::must_use({
                                let res = ::alloc::fmt::format(format_args!(
                                    "Unexpected value for enum: {0:?}",
                                    __binrw_temp,
                                ));
                                res
                            })
                            .into()
                        }),
                    ))
                }
            })()
            .or_else(binrw::__private::restore_position::<binrw::Error, _, _>(
                __binrw_generated_var_reader,
                __binrw_generated_position_temp,
            ))
        }
    }
    impl binrw::meta::ReadEndian for Command {
        const ENDIAN: binrw::meta::EndianKind = binrw::meta::EndianKind::Endian(binrw::Endian::Big);
    }
    #[automatically_derived]
    #[allow(non_snake_case, unknown_lints)]
    #[allow(clippy::redundant_closure_call)]
    impl binrw::BinWrite for Command {
        type Args<'__binrw_generated_args_lifetime> = ();
        fn write_options<W: binrw::io::Write + binrw::io::Seek>(
            &self,
            __binrw_generated_var_writer: &mut W,
            __binrw_generated_var_endian: binrw::Endian,
            __binrw_generated_var_arguments: Self::Args<'_>,
        ) -> binrw::BinResult<()> {
            let __binrw_generated_var_writer = __binrw_generated_var_writer;
            let __binrw_generated_position_temp =
                binrw::io::Seek::stream_position(__binrw_generated_var_writer)?;
            let __binrw_generated_var_endian = binrw::Endian::Big;
            binrw::BinWrite::write_options(
                &(match self {
                    Self::StartService => Self::StartService,
                    Self::StopService => Self::StopService,
                    Self::RestartService => Self::RestartService,
                    Self::GetServiceStatus => Self::GetServiceStatus,
                    Self::AddService => Self::AddService,
                    Self::RemoveService => Self::RemoveService,
                    Self::ListServices => Self::ListServices,
                    Self::UpdateConfig => Self::UpdateConfig,
                    Self::GetConfig => Self::GetConfig,
                    Self::AddDependency => Self::AddDependency,
                    Self::RemoveDependency => Self::RemoveDependency,
                    Self::ListDependencies => Self::ListDependencies,
                    Self::CheckoutBranch => Self::CheckoutBranch,
                    Self::GetRepoStatus => Self::GetRepoStatus,
                    Self::Shutdown => Self::Shutdown,
                    Self::GetSystemStatus => Self::GetSystemStatus,
                    Self::Ping => Self::Ping,
                    Self::Success => Self::Success,
                    Self::Error => Self::Error,
                } as u16),
                __binrw_generated_var_writer,
                __binrw_generated_var_endian,
                (),
            )?;
            Ok(())
        }
    }
    impl binrw::meta::WriteEndian for Command {
        const ENDIAN: binrw::meta::EndianKind = binrw::meta::EndianKind::Endian(binrw::Endian::Big);
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Command {
        #[inline]
        fn clone(&self) -> Command {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Command {}
    impl ::bincode::Encode for Command {
        fn encode<__E: ::bincode::enc::Encoder>(
            &self,
            encoder: &mut __E,
        ) -> core::result::Result<(), ::bincode::error::EncodeError> {
            match self {
                Self::StartService => {
                    <u32 as ::bincode::Encode>::encode(&(0u32), encoder)?;
                    Ok(())
                }
                Self::StopService => {
                    <u32 as ::bincode::Encode>::encode(&(1u32), encoder)?;
                    Ok(())
                }
                Self::RestartService => {
                    <u32 as ::bincode::Encode>::encode(&(2u32), encoder)?;
                    Ok(())
                }
                Self::GetServiceStatus => {
                    <u32 as ::bincode::Encode>::encode(&(3u32), encoder)?;
                    Ok(())
                }
                Self::AddService => {
                    <u32 as ::bincode::Encode>::encode(&(4u32), encoder)?;
                    Ok(())
                }
                Self::RemoveService => {
                    <u32 as ::bincode::Encode>::encode(&(5u32), encoder)?;
                    Ok(())
                }
                Self::ListServices => {
                    <u32 as ::bincode::Encode>::encode(&(6u32), encoder)?;
                    Ok(())
                }
                Self::UpdateConfig => {
                    <u32 as ::bincode::Encode>::encode(&(7u32), encoder)?;
                    Ok(())
                }
                Self::GetConfig => {
                    <u32 as ::bincode::Encode>::encode(&(8u32), encoder)?;
                    Ok(())
                }
                Self::AddDependency => {
                    <u32 as ::bincode::Encode>::encode(&(9u32), encoder)?;
                    Ok(())
                }
                Self::RemoveDependency => {
                    <u32 as ::bincode::Encode>::encode(&(10u32), encoder)?;
                    Ok(())
                }
                Self::ListDependencies => {
                    <u32 as ::bincode::Encode>::encode(&(11u32), encoder)?;
                    Ok(())
                }
                Self::CheckoutBranch => {
                    <u32 as ::bincode::Encode>::encode(&(12u32), encoder)?;
                    Ok(())
                }
                Self::GetRepoStatus => {
                    <u32 as ::bincode::Encode>::encode(&(13u32), encoder)?;
                    Ok(())
                }
                Self::Shutdown => {
                    <u32 as ::bincode::Encode>::encode(&(14u32), encoder)?;
                    Ok(())
                }
                Self::GetSystemStatus => {
                    <u32 as ::bincode::Encode>::encode(&(15u32), encoder)?;
                    Ok(())
                }
                Self::Ping => {
                    <u32 as ::bincode::Encode>::encode(&(16u32), encoder)?;
                    Ok(())
                }
                Self::Success => {
                    <u32 as ::bincode::Encode>::encode(&(17u32), encoder)?;
                    Ok(())
                }
                Self::Error => {
                    <u32 as ::bincode::Encode>::encode(&(18u32), encoder)?;
                    Ok(())
                }
            }
        }
    }
    impl ::bincode::Decode for Command {
        fn decode<__D: ::bincode::de::Decoder>(
            decoder: &mut __D,
        ) -> core::result::Result<Self, ::bincode::error::DecodeError> {
            let variant_index = <u32 as ::bincode::Decode>::decode(decoder)?;
            match variant_index {
                0u32 => Ok(Self::StartService {}),
                1u32 => Ok(Self::StopService {}),
                2u32 => Ok(Self::RestartService {}),
                3u32 => Ok(Self::GetServiceStatus {}),
                4u32 => Ok(Self::AddService {}),
                5u32 => Ok(Self::RemoveService {}),
                6u32 => Ok(Self::ListServices {}),
                7u32 => Ok(Self::UpdateConfig {}),
                8u32 => Ok(Self::GetConfig {}),
                9u32 => Ok(Self::AddDependency {}),
                10u32 => Ok(Self::RemoveDependency {}),
                11u32 => Ok(Self::ListDependencies {}),
                12u32 => Ok(Self::CheckoutBranch {}),
                13u32 => Ok(Self::GetRepoStatus {}),
                14u32 => Ok(Self::Shutdown {}),
                15u32 => Ok(Self::GetSystemStatus {}),
                16u32 => Ok(Self::Ping {}),
                17u32 => Ok(Self::Success {}),
                18u32 => Ok(Self::Error {}),
                variant => Err(::bincode::error::DecodeError::UnexpectedVariant {
                    found: variant,
                    type_name: "Command",
                    allowed: &::bincode::error::AllowedEnumVariants::Allowed(&[
                        0u32, 1u32, 2u32, 3u32, 4u32, 5u32, 6u32, 7u32, 8u32, 9u32, 10u32, 11u32,
                        12u32, 13u32, 14u32, 15u32, 16u32, 17u32, 18u32,
                    ]),
                }),
            }
        }
    }
    impl<'__de> ::bincode::BorrowDecode<'__de> for Command {
        fn borrow_decode<__D: ::bincode::de::BorrowDecoder<'__de>>(
            decoder: &mut __D,
        ) -> core::result::Result<Self, ::bincode::error::DecodeError> {
            let variant_index = <u32 as ::bincode::Decode>::decode(decoder)?;
            match variant_index {
                0u32 => Ok(Self::StartService {}),
                1u32 => Ok(Self::StopService {}),
                2u32 => Ok(Self::RestartService {}),
                3u32 => Ok(Self::GetServiceStatus {}),
                4u32 => Ok(Self::AddService {}),
                5u32 => Ok(Self::RemoveService {}),
                6u32 => Ok(Self::ListServices {}),
                7u32 => Ok(Self::UpdateConfig {}),
                8u32 => Ok(Self::GetConfig {}),
                9u32 => Ok(Self::AddDependency {}),
                10u32 => Ok(Self::RemoveDependency {}),
                11u32 => Ok(Self::ListDependencies {}),
                12u32 => Ok(Self::CheckoutBranch {}),
                13u32 => Ok(Self::GetRepoStatus {}),
                14u32 => Ok(Self::Shutdown {}),
                15u32 => Ok(Self::GetSystemStatus {}),
                16u32 => Ok(Self::Ping {}),
                17u32 => Ok(Self::Success {}),
                18u32 => Ok(Self::Error {}),
                variant => Err(::bincode::error::DecodeError::UnexpectedVariant {
                    found: variant,
                    type_name: "Command",
                    allowed: &::bincode::error::AllowedEnumVariants::Allowed(&[
                        0u32, 1u32, 2u32, 3u32, 4u32, 5u32, 6u32, 7u32, 8u32, 9u32, 10u32, 11u32,
                        12u32, 13u32, 14u32, 15u32, 16u32, 17u32, 18u32,
                    ]),
                }),
            }
        }
    }
    pub struct PingCommand;
    impl ::std::default::Default for PingCommand {
        fn default() -> Self {
            Self
        }
    }
    impl PingCommand {
        pub fn new() -> Self {
            ::std::default::Default::default()
        }
    }
    impl crate::traits::ServiceCommand for PingCommand {
        type Input = ();
        type Output = ();
        const COMMAND: crate::commands::Command = crate::commands::Command::Ping;
        fn into_payload(self) -> Self::Input {}
    }
    #[unwrap(ref, ref_mut)]
    #[try_unwrap(ref, ref_mut)]
    #[non_exhaustive]
    pub enum CommandPayload {
        Status(ServiceStatus),
        ListServices(ListServicesResponse),
        ServiceConfig(ServiceConfigPayload),
        Dependencies(ListDependenciesResponse),
        Error(ErrorPayload),
        Empty,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for CommandPayload {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                CommandPayload::Status(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Status", &__self_0)
                }
                CommandPayload::ListServices(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(f, "ListServices", &__self_0)
                }
                CommandPayload::ServiceConfig(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(f, "ServiceConfig", &__self_0)
                }
                CommandPayload::Dependencies(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Dependencies", &__self_0)
                }
                CommandPayload::Error(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Error", &__self_0)
                }
                CommandPayload::Empty => ::core::fmt::Formatter::write_str(f, "Empty"),
            }
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for CommandPayload {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    CommandPayload::Status(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "CommandPayload",
                            0u32,
                            "Status",
                            __field0,
                        )
                    }
                    CommandPayload::ListServices(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "CommandPayload",
                            1u32,
                            "ListServices",
                            __field0,
                        )
                    }
                    CommandPayload::ServiceConfig(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "CommandPayload",
                            2u32,
                            "ServiceConfig",
                            __field0,
                        )
                    }
                    CommandPayload::Dependencies(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "CommandPayload",
                            3u32,
                            "Dependencies",
                            __field0,
                        )
                    }
                    CommandPayload::Error(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "CommandPayload",
                            4u32,
                            "Error",
                            __field0,
                        )
                    }
                    CommandPayload::Empty => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "CommandPayload",
                        5u32,
                        "Empty",
                    ),
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for CommandPayload {
            fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "variant identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            5u64 => _serde::__private::Ok(__Field::__field5),
                            _ => _serde::__private::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"variant index 0 <= i < 6",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "Status" => _serde::__private::Ok(__Field::__field0),
                            "ListServices" => _serde::__private::Ok(__Field::__field1),
                            "ServiceConfig" => _serde::__private::Ok(__Field::__field2),
                            "Dependencies" => _serde::__private::Ok(__Field::__field3),
                            "Error" => _serde::__private::Ok(__Field::__field4),
                            "Empty" => _serde::__private::Ok(__Field::__field5),
                            _ => _serde::__private::Err(_serde::de::Error::unknown_variant(
                                __value, VARIANTS,
                            )),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"Status" => _serde::__private::Ok(__Field::__field0),
                            b"ListServices" => _serde::__private::Ok(__Field::__field1),
                            b"ServiceConfig" => _serde::__private::Ok(__Field::__field2),
                            b"Dependencies" => _serde::__private::Ok(__Field::__field3),
                            b"Error" => _serde::__private::Ok(__Field::__field4),
                            b"Empty" => _serde::__private::Ok(__Field::__field5),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                ))
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<CommandPayload>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = CommandPayload;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "enum CommandPayload")
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => _serde::__private::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<ServiceStatus>(
                                    __variant,
                                ),
                                CommandPayload::Status,
                            ),
                            (__Field::__field1, __variant) => _serde::__private::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<ListServicesResponse>(
                                    __variant,
                                ),
                                CommandPayload::ListServices,
                            ),
                            (__Field::__field2, __variant) => _serde::__private::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<ServiceConfigPayload>(
                                    __variant,
                                ),
                                CommandPayload::ServiceConfig,
                            ),
                            (__Field::__field3, __variant) => _serde::__private::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<
                                    ListDependenciesResponse,
                                >(__variant),
                                CommandPayload::Dependencies,
                            ),
                            (__Field::__field4, __variant) => _serde::__private::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<ErrorPayload>(
                                    __variant,
                                ),
                                CommandPayload::Error,
                            ),
                            (__Field::__field5, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(CommandPayload::Empty)
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &[
                    "Status",
                    "ListServices",
                    "ServiceConfig",
                    "Dependencies",
                    "Error",
                    "Empty",
                ];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "CommandPayload",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<CommandPayload>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    impl ::bincode::Encode for CommandPayload {
        fn encode<__E: ::bincode::enc::Encoder>(
            &self,
            encoder: &mut __E,
        ) -> core::result::Result<(), ::bincode::error::EncodeError> {
            match self {
                Self::Status(field_0) => {
                    <u32 as ::bincode::Encode>::encode(&(0u32), encoder)?;
                    ::bincode::Encode::encode(field_0, encoder)?;
                    Ok(())
                }
                Self::ListServices(field_0) => {
                    <u32 as ::bincode::Encode>::encode(&(1u32), encoder)?;
                    ::bincode::Encode::encode(field_0, encoder)?;
                    Ok(())
                }
                Self::ServiceConfig(field_0) => {
                    <u32 as ::bincode::Encode>::encode(&(2u32), encoder)?;
                    ::bincode::Encode::encode(field_0, encoder)?;
                    Ok(())
                }
                Self::Dependencies(field_0) => {
                    <u32 as ::bincode::Encode>::encode(&(3u32), encoder)?;
                    ::bincode::Encode::encode(field_0, encoder)?;
                    Ok(())
                }
                Self::Error(field_0) => {
                    <u32 as ::bincode::Encode>::encode(&(4u32), encoder)?;
                    ::bincode::Encode::encode(field_0, encoder)?;
                    Ok(())
                }
                Self::Empty => {
                    <u32 as ::bincode::Encode>::encode(&(5u32), encoder)?;
                    Ok(())
                }
            }
        }
    }
    impl ::bincode::Decode for CommandPayload {
        fn decode<__D: ::bincode::de::Decoder>(
            decoder: &mut __D,
        ) -> core::result::Result<Self, ::bincode::error::DecodeError> {
            let variant_index = <u32 as ::bincode::Decode>::decode(decoder)?;
            match variant_index {
                0u32 => Ok(Self::Status {
                    0: ::bincode::Decode::decode(decoder)?,
                }),
                1u32 => Ok(Self::ListServices {
                    0: ::bincode::Decode::decode(decoder)?,
                }),
                2u32 => Ok(Self::ServiceConfig {
                    0: ::bincode::Decode::decode(decoder)?,
                }),
                3u32 => Ok(Self::Dependencies {
                    0: ::bincode::Decode::decode(decoder)?,
                }),
                4u32 => Ok(Self::Error {
                    0: ::bincode::Decode::decode(decoder)?,
                }),
                5u32 => Ok(Self::Empty {}),
                variant => Err(::bincode::error::DecodeError::UnexpectedVariant {
                    found: variant,
                    type_name: "CommandPayload",
                    allowed: &::bincode::error::AllowedEnumVariants::Range { min: 0, max: 5 },
                }),
            }
        }
    }
    impl<'__de> ::bincode::BorrowDecode<'__de> for CommandPayload {
        fn borrow_decode<__D: ::bincode::de::BorrowDecoder<'__de>>(
            decoder: &mut __D,
        ) -> core::result::Result<Self, ::bincode::error::DecodeError> {
            let variant_index = <u32 as ::bincode::Decode>::decode(decoder)?;
            match variant_index {
                0u32 => Ok(Self::Status {
                    0: ::bincode::BorrowDecode::borrow_decode(decoder)?,
                }),
                1u32 => Ok(Self::ListServices {
                    0: ::bincode::BorrowDecode::borrow_decode(decoder)?,
                }),
                2u32 => Ok(Self::ServiceConfig {
                    0: ::bincode::BorrowDecode::borrow_decode(decoder)?,
                }),
                3u32 => Ok(Self::Dependencies {
                    0: ::bincode::BorrowDecode::borrow_decode(decoder)?,
                }),
                4u32 => Ok(Self::Error {
                    0: ::bincode::BorrowDecode::borrow_decode(decoder)?,
                }),
                5u32 => Ok(Self::Empty {}),
                variant => Err(::bincode::error::DecodeError::UnexpectedVariant {
                    found: variant,
                    type_name: "CommandPayload",
                    allowed: &::bincode::error::AllowedEnumVariants::Range { min: 0, max: 5 },
                }),
            }
        }
    }
    #[automatically_derived]
    impl CommandPayload {
        ///Returns `true` if this value is of type `
        ///Status
        ///`. Returns `false` otherwise
        #[inline]
        #[must_use]
        pub const fn is_status(&self) -> bool {
            match self {
                CommandPayload::Status(..) => true,
                _ => false,
            }
        }
        ///Returns `true` if this value is of type `
        ///ListServices
        ///`. Returns `false` otherwise
        #[inline]
        #[must_use]
        pub const fn is_list_services(&self) -> bool {
            match self {
                CommandPayload::ListServices(..) => true,
                _ => false,
            }
        }
        ///Returns `true` if this value is of type `
        ///ServiceConfig
        ///`. Returns `false` otherwise
        #[inline]
        #[must_use]
        pub const fn is_service_config(&self) -> bool {
            match self {
                CommandPayload::ServiceConfig(..) => true,
                _ => false,
            }
        }
        ///Returns `true` if this value is of type `
        ///Dependencies
        ///`. Returns `false` otherwise
        #[inline]
        #[must_use]
        pub const fn is_dependencies(&self) -> bool {
            match self {
                CommandPayload::Dependencies(..) => true,
                _ => false,
            }
        }
        ///Returns `true` if this value is of type `
        ///Error
        ///`. Returns `false` otherwise
        #[inline]
        #[must_use]
        pub const fn is_error(&self) -> bool {
            match self {
                CommandPayload::Error(..) => true,
                _ => false,
            }
        }
        ///Returns `true` if this value is of type `
        ///Empty
        ///`. Returns `false` otherwise
        #[inline]
        #[must_use]
        pub const fn is_empty(&self) -> bool {
            match self {
                CommandPayload::Empty => true,
                _ => false,
            }
        }
    }
    #[automatically_derived]
    impl CommandPayload {
        #[inline]
        #[track_caller]
        /**Unwraps this value to the `CommandPayload::Status` variant.
        */
        ///Panics if this value is of any other type.
        pub fn unwrap_status(self) -> (ServiceStatus) {
            match self {
                CommandPayload::Status(field_0) => (field_0),
                val @ _ => match val {
                    CommandPayload::Status(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_status()` on a `CommandPayload::Status` value",
                                ),
                            );
                    }
                    CommandPayload::ListServices(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_status()` on a `CommandPayload::ListServices` value",
                                ),
                            );
                    }
                    CommandPayload::ServiceConfig(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_status()` on a `CommandPayload::ServiceConfig` value",
                                ),
                            );
                    }
                    CommandPayload::Dependencies(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_status()` on a `CommandPayload::Dependencies` value",
                                ),
                            );
                    }
                    CommandPayload::Error(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_status()` on a `CommandPayload::Error` value",
                                ),
                            );
                    }
                    CommandPayload::Empty => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_status()` on a `CommandPayload::Empty` value",
                                ),
                            );
                    }
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Unwraps this reference to the `CommandPayload::Status` variant.
        */
        ///Panics if this value is of any other type.
        pub fn unwrap_status_ref(&self) -> (&ServiceStatus) {
            match self {
                CommandPayload::Status(field_0) => (field_0),
                val @ _ => match val {
                    CommandPayload::Status(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_status_ref()` on a `CommandPayload::Status` value",
                                ),
                            );
                    }
                    CommandPayload::ListServices(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_status_ref()` on a `CommandPayload::ListServices` value",
                                ),
                            );
                    }
                    CommandPayload::ServiceConfig(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_status_ref()` on a `CommandPayload::ServiceConfig` value",
                                ),
                            );
                    }
                    CommandPayload::Dependencies(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_status_ref()` on a `CommandPayload::Dependencies` value",
                                ),
                            );
                    }
                    CommandPayload::Error(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_status_ref()` on a `CommandPayload::Error` value",
                                ),
                            );
                    }
                    CommandPayload::Empty => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_status_ref()` on a `CommandPayload::Empty` value",
                                ),
                            );
                    }
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Unwraps this mutable reference to the `CommandPayload::Status` variant.
        */
        ///Panics if this value is of any other type.
        pub fn unwrap_status_mut(&mut self) -> (&mut ServiceStatus) {
            match self {
                CommandPayload::Status(field_0) => (field_0),
                val @ _ => match val {
                    CommandPayload::Status(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_status_mut()` on a `CommandPayload::Status` value",
                                ),
                            );
                    }
                    CommandPayload::ListServices(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_status_mut()` on a `CommandPayload::ListServices` value",
                                ),
                            );
                    }
                    CommandPayload::ServiceConfig(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_status_mut()` on a `CommandPayload::ServiceConfig` value",
                                ),
                            );
                    }
                    CommandPayload::Dependencies(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_status_mut()` on a `CommandPayload::Dependencies` value",
                                ),
                            );
                    }
                    CommandPayload::Error(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_status_mut()` on a `CommandPayload::Error` value",
                                ),
                            );
                    }
                    CommandPayload::Empty => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_status_mut()` on a `CommandPayload::Empty` value",
                                ),
                            );
                    }
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Unwraps this value to the `CommandPayload::ListServices` variant.
        */
        ///Panics if this value is of any other type.
        pub fn unwrap_list_services(self) -> (ListServicesResponse) {
            match self {
                CommandPayload::ListServices(field_0) => (field_0),
                val @ _ => match val {
                    CommandPayload::Status(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_list_services()` on a `CommandPayload::Status` value",
                                ),
                            );
                    }
                    CommandPayload::ListServices(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_list_services()` on a `CommandPayload::ListServices` value",
                                ),
                            );
                    }
                    CommandPayload::ServiceConfig(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_list_services()` on a `CommandPayload::ServiceConfig` value",
                                ),
                            );
                    }
                    CommandPayload::Dependencies(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_list_services()` on a `CommandPayload::Dependencies` value",
                                ),
                            );
                    }
                    CommandPayload::Error(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_list_services()` on a `CommandPayload::Error` value",
                                ),
                            );
                    }
                    CommandPayload::Empty => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_list_services()` on a `CommandPayload::Empty` value",
                                ),
                            );
                    }
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Unwraps this reference to the `CommandPayload::ListServices` variant.
        */
        ///Panics if this value is of any other type.
        pub fn unwrap_list_services_ref(&self) -> (&ListServicesResponse) {
            match self {
                CommandPayload::ListServices(field_0) => (field_0),
                val @ _ => match val {
                    CommandPayload::Status(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_list_services_ref()` on a `CommandPayload::Status` value",
                                ),
                            );
                    }
                    CommandPayload::ListServices(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_list_services_ref()` on a `CommandPayload::ListServices` value",
                                ),
                            );
                    }
                    CommandPayload::ServiceConfig(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_list_services_ref()` on a `CommandPayload::ServiceConfig` value",
                                ),
                            );
                    }
                    CommandPayload::Dependencies(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_list_services_ref()` on a `CommandPayload::Dependencies` value",
                                ),
                            );
                    }
                    CommandPayload::Error(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_list_services_ref()` on a `CommandPayload::Error` value",
                                ),
                            );
                    }
                    CommandPayload::Empty => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_list_services_ref()` on a `CommandPayload::Empty` value",
                                ),
                            );
                    }
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Unwraps this mutable reference to the `CommandPayload::ListServices` variant.
        */
        ///Panics if this value is of any other type.
        pub fn unwrap_list_services_mut(&mut self) -> (&mut ListServicesResponse) {
            match self {
                CommandPayload::ListServices(field_0) => (field_0),
                val @ _ => match val {
                    CommandPayload::Status(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_list_services_mut()` on a `CommandPayload::Status` value",
                                ),
                            );
                    }
                    CommandPayload::ListServices(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_list_services_mut()` on a `CommandPayload::ListServices` value",
                                ),
                            );
                    }
                    CommandPayload::ServiceConfig(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_list_services_mut()` on a `CommandPayload::ServiceConfig` value",
                                ),
                            );
                    }
                    CommandPayload::Dependencies(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_list_services_mut()` on a `CommandPayload::Dependencies` value",
                                ),
                            );
                    }
                    CommandPayload::Error(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_list_services_mut()` on a `CommandPayload::Error` value",
                                ),
                            );
                    }
                    CommandPayload::Empty => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_list_services_mut()` on a `CommandPayload::Empty` value",
                                ),
                            );
                    }
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Unwraps this value to the `CommandPayload::ServiceConfig` variant.
        */
        ///Panics if this value is of any other type.
        pub fn unwrap_service_config(self) -> (ServiceConfigPayload) {
            match self {
                CommandPayload::ServiceConfig(field_0) => (field_0),
                val @ _ => match val {
                    CommandPayload::Status(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_service_config()` on a `CommandPayload::Status` value",
                                ),
                            );
                    }
                    CommandPayload::ListServices(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_service_config()` on a `CommandPayload::ListServices` value",
                                ),
                            );
                    }
                    CommandPayload::ServiceConfig(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_service_config()` on a `CommandPayload::ServiceConfig` value",
                                ),
                            );
                    }
                    CommandPayload::Dependencies(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_service_config()` on a `CommandPayload::Dependencies` value",
                                ),
                            );
                    }
                    CommandPayload::Error(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_service_config()` on a `CommandPayload::Error` value",
                                ),
                            );
                    }
                    CommandPayload::Empty => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_service_config()` on a `CommandPayload::Empty` value",
                                ),
                            );
                    }
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Unwraps this reference to the `CommandPayload::ServiceConfig` variant.
        */
        ///Panics if this value is of any other type.
        pub fn unwrap_service_config_ref(&self) -> (&ServiceConfigPayload) {
            match self {
                CommandPayload::ServiceConfig(field_0) => (field_0),
                val @ _ => match val {
                    CommandPayload::Status(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_service_config_ref()` on a `CommandPayload::Status` value",
                                ),
                            );
                    }
                    CommandPayload::ListServices(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_service_config_ref()` on a `CommandPayload::ListServices` value",
                                ),
                            );
                    }
                    CommandPayload::ServiceConfig(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_service_config_ref()` on a `CommandPayload::ServiceConfig` value",
                                ),
                            );
                    }
                    CommandPayload::Dependencies(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_service_config_ref()` on a `CommandPayload::Dependencies` value",
                                ),
                            );
                    }
                    CommandPayload::Error(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_service_config_ref()` on a `CommandPayload::Error` value",
                                ),
                            );
                    }
                    CommandPayload::Empty => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_service_config_ref()` on a `CommandPayload::Empty` value",
                                ),
                            );
                    }
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Unwraps this mutable reference to the `CommandPayload::ServiceConfig` variant.
        */
        ///Panics if this value is of any other type.
        pub fn unwrap_service_config_mut(&mut self) -> (&mut ServiceConfigPayload) {
            match self {
                CommandPayload::ServiceConfig(field_0) => (field_0),
                val @ _ => match val {
                    CommandPayload::Status(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_service_config_mut()` on a `CommandPayload::Status` value",
                                ),
                            );
                    }
                    CommandPayload::ListServices(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_service_config_mut()` on a `CommandPayload::ListServices` value",
                                ),
                            );
                    }
                    CommandPayload::ServiceConfig(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_service_config_mut()` on a `CommandPayload::ServiceConfig` value",
                                ),
                            );
                    }
                    CommandPayload::Dependencies(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_service_config_mut()` on a `CommandPayload::Dependencies` value",
                                ),
                            );
                    }
                    CommandPayload::Error(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_service_config_mut()` on a `CommandPayload::Error` value",
                                ),
                            );
                    }
                    CommandPayload::Empty => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_service_config_mut()` on a `CommandPayload::Empty` value",
                                ),
                            );
                    }
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Unwraps this value to the `CommandPayload::Dependencies` variant.
        */
        ///Panics if this value is of any other type.
        pub fn unwrap_dependencies(self) -> (ListDependenciesResponse) {
            match self {
                CommandPayload::Dependencies(field_0) => (field_0),
                val @ _ => match val {
                    CommandPayload::Status(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_dependencies()` on a `CommandPayload::Status` value",
                                ),
                            );
                    }
                    CommandPayload::ListServices(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_dependencies()` on a `CommandPayload::ListServices` value",
                                ),
                            );
                    }
                    CommandPayload::ServiceConfig(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_dependencies()` on a `CommandPayload::ServiceConfig` value",
                                ),
                            );
                    }
                    CommandPayload::Dependencies(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_dependencies()` on a `CommandPayload::Dependencies` value",
                                ),
                            );
                    }
                    CommandPayload::Error(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_dependencies()` on a `CommandPayload::Error` value",
                                ),
                            );
                    }
                    CommandPayload::Empty => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_dependencies()` on a `CommandPayload::Empty` value",
                                ),
                            );
                    }
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Unwraps this reference to the `CommandPayload::Dependencies` variant.
        */
        ///Panics if this value is of any other type.
        pub fn unwrap_dependencies_ref(&self) -> (&ListDependenciesResponse) {
            match self {
                CommandPayload::Dependencies(field_0) => (field_0),
                val @ _ => match val {
                    CommandPayload::Status(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_dependencies_ref()` on a `CommandPayload::Status` value",
                                ),
                            );
                    }
                    CommandPayload::ListServices(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_dependencies_ref()` on a `CommandPayload::ListServices` value",
                                ),
                            );
                    }
                    CommandPayload::ServiceConfig(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_dependencies_ref()` on a `CommandPayload::ServiceConfig` value",
                                ),
                            );
                    }
                    CommandPayload::Dependencies(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_dependencies_ref()` on a `CommandPayload::Dependencies` value",
                                ),
                            );
                    }
                    CommandPayload::Error(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_dependencies_ref()` on a `CommandPayload::Error` value",
                                ),
                            );
                    }
                    CommandPayload::Empty => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_dependencies_ref()` on a `CommandPayload::Empty` value",
                                ),
                            );
                    }
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Unwraps this mutable reference to the `CommandPayload::Dependencies` variant.
        */
        ///Panics if this value is of any other type.
        pub fn unwrap_dependencies_mut(&mut self) -> (&mut ListDependenciesResponse) {
            match self {
                CommandPayload::Dependencies(field_0) => (field_0),
                val @ _ => match val {
                    CommandPayload::Status(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_dependencies_mut()` on a `CommandPayload::Status` value",
                                ),
                            );
                    }
                    CommandPayload::ListServices(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_dependencies_mut()` on a `CommandPayload::ListServices` value",
                                ),
                            );
                    }
                    CommandPayload::ServiceConfig(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_dependencies_mut()` on a `CommandPayload::ServiceConfig` value",
                                ),
                            );
                    }
                    CommandPayload::Dependencies(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_dependencies_mut()` on a `CommandPayload::Dependencies` value",
                                ),
                            );
                    }
                    CommandPayload::Error(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_dependencies_mut()` on a `CommandPayload::Error` value",
                                ),
                            );
                    }
                    CommandPayload::Empty => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_dependencies_mut()` on a `CommandPayload::Empty` value",
                                ),
                            );
                    }
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Unwraps this value to the `CommandPayload::Error` variant.
        */
        ///Panics if this value is of any other type.
        pub fn unwrap_error(self) -> (ErrorPayload) {
            match self {
                CommandPayload::Error(field_0) => (field_0),
                val @ _ => match val {
                    CommandPayload::Status(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_error()` on a `CommandPayload::Status` value",
                                ),
                            );
                    }
                    CommandPayload::ListServices(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_error()` on a `CommandPayload::ListServices` value",
                                ),
                            );
                    }
                    CommandPayload::ServiceConfig(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_error()` on a `CommandPayload::ServiceConfig` value",
                                ),
                            );
                    }
                    CommandPayload::Dependencies(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_error()` on a `CommandPayload::Dependencies` value",
                                ),
                            );
                    }
                    CommandPayload::Error(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_error()` on a `CommandPayload::Error` value",
                                ),
                            );
                    }
                    CommandPayload::Empty => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_error()` on a `CommandPayload::Empty` value",
                                ),
                            );
                    }
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Unwraps this reference to the `CommandPayload::Error` variant.
        */
        ///Panics if this value is of any other type.
        pub fn unwrap_error_ref(&self) -> (&ErrorPayload) {
            match self {
                CommandPayload::Error(field_0) => (field_0),
                val @ _ => match val {
                    CommandPayload::Status(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_error_ref()` on a `CommandPayload::Status` value",
                                ),
                            );
                    }
                    CommandPayload::ListServices(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_error_ref()` on a `CommandPayload::ListServices` value",
                                ),
                            );
                    }
                    CommandPayload::ServiceConfig(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_error_ref()` on a `CommandPayload::ServiceConfig` value",
                                ),
                            );
                    }
                    CommandPayload::Dependencies(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_error_ref()` on a `CommandPayload::Dependencies` value",
                                ),
                            );
                    }
                    CommandPayload::Error(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_error_ref()` on a `CommandPayload::Error` value",
                                ),
                            );
                    }
                    CommandPayload::Empty => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_error_ref()` on a `CommandPayload::Empty` value",
                                ),
                            );
                    }
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Unwraps this mutable reference to the `CommandPayload::Error` variant.
        */
        ///Panics if this value is of any other type.
        pub fn unwrap_error_mut(&mut self) -> (&mut ErrorPayload) {
            match self {
                CommandPayload::Error(field_0) => (field_0),
                val @ _ => match val {
                    CommandPayload::Status(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_error_mut()` on a `CommandPayload::Status` value",
                                ),
                            );
                    }
                    CommandPayload::ListServices(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_error_mut()` on a `CommandPayload::ListServices` value",
                                ),
                            );
                    }
                    CommandPayload::ServiceConfig(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_error_mut()` on a `CommandPayload::ServiceConfig` value",
                                ),
                            );
                    }
                    CommandPayload::Dependencies(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_error_mut()` on a `CommandPayload::Dependencies` value",
                                ),
                            );
                    }
                    CommandPayload::Error(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_error_mut()` on a `CommandPayload::Error` value",
                                ),
                            );
                    }
                    CommandPayload::Empty => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_error_mut()` on a `CommandPayload::Empty` value",
                                ),
                            );
                    }
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Unwraps this value to the `CommandPayload::Empty` variant.
        */
        ///Panics if this value is of any other type.
        pub fn unwrap_empty(self) -> () {
            match self {
                CommandPayload::Empty => {}
                val @ _ => match val {
                    CommandPayload::Status(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_empty()` on a `CommandPayload::Status` value",
                                ),
                            );
                    }
                    CommandPayload::ListServices(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_empty()` on a `CommandPayload::ListServices` value",
                                ),
                            );
                    }
                    CommandPayload::ServiceConfig(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_empty()` on a `CommandPayload::ServiceConfig` value",
                                ),
                            );
                    }
                    CommandPayload::Dependencies(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_empty()` on a `CommandPayload::Dependencies` value",
                                ),
                            );
                    }
                    CommandPayload::Error(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_empty()` on a `CommandPayload::Error` value",
                                ),
                            );
                    }
                    CommandPayload::Empty => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_empty()` on a `CommandPayload::Empty` value",
                                ),
                            );
                    }
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Unwraps this reference to the `CommandPayload::Empty` variant.
        */
        ///Panics if this value is of any other type.
        pub fn unwrap_empty_ref(&self) -> () {
            match self {
                CommandPayload::Empty => {}
                val @ _ => match val {
                    CommandPayload::Status(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_empty_ref()` on a `CommandPayload::Status` value",
                                ),
                            );
                    }
                    CommandPayload::ListServices(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_empty_ref()` on a `CommandPayload::ListServices` value",
                                ),
                            );
                    }
                    CommandPayload::ServiceConfig(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_empty_ref()` on a `CommandPayload::ServiceConfig` value",
                                ),
                            );
                    }
                    CommandPayload::Dependencies(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_empty_ref()` on a `CommandPayload::Dependencies` value",
                                ),
                            );
                    }
                    CommandPayload::Error(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_empty_ref()` on a `CommandPayload::Error` value",
                                ),
                            );
                    }
                    CommandPayload::Empty => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_empty_ref()` on a `CommandPayload::Empty` value",
                                ),
                            );
                    }
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Unwraps this mutable reference to the `CommandPayload::Empty` variant.
        */
        ///Panics if this value is of any other type.
        pub fn unwrap_empty_mut(&mut self) -> () {
            match self {
                CommandPayload::Empty => {}
                val @ _ => match val {
                    CommandPayload::Status(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_empty_mut()` on a `CommandPayload::Status` value",
                                ),
                            );
                    }
                    CommandPayload::ListServices(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_empty_mut()` on a `CommandPayload::ListServices` value",
                                ),
                            );
                    }
                    CommandPayload::ServiceConfig(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_empty_mut()` on a `CommandPayload::ServiceConfig` value",
                                ),
                            );
                    }
                    CommandPayload::Dependencies(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_empty_mut()` on a `CommandPayload::Dependencies` value",
                                ),
                            );
                    }
                    CommandPayload::Error(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_empty_mut()` on a `CommandPayload::Error` value",
                                ),
                            );
                    }
                    CommandPayload::Empty => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `CommandPayload::unwrap_empty_mut()` on a `CommandPayload::Empty` value",
                                ),
                            );
                    }
                },
            }
        }
    }
    #[automatically_derived]
    impl CommandPayload {
        #[inline]
        #[track_caller]
        /**Attempts to unwrap this value to the `CommandPayload::Status` variant.
        */
        ///Returns a [TryUnwrapError] with the original value if this value is of any other type.
        pub fn try_unwrap_status(
            self,
        ) -> derive_more::core::result::Result<(ServiceStatus), derive_more::TryUnwrapError<Self>>
        {
            match self {
                CommandPayload::Status(field_0) => derive_more::core::result::Result::Ok((field_0)),
                val @ _ => match val {
                    val @ CommandPayload::Status(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "CommandPayload",
                            "Status",
                            "try_unwrap_status",
                        ),
                    ),
                    val @ CommandPayload::ListServices(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "CommandPayload",
                                "ListServices",
                                "try_unwrap_status",
                            ),
                        )
                    }
                    val @ CommandPayload::ServiceConfig(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "CommandPayload",
                                "ServiceConfig",
                                "try_unwrap_status",
                            ),
                        )
                    }
                    val @ CommandPayload::Dependencies(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "CommandPayload",
                                "Dependencies",
                                "try_unwrap_status",
                            ),
                        )
                    }
                    val @ CommandPayload::Error(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "CommandPayload",
                            "Error",
                            "try_unwrap_status",
                        ),
                    ),
                    val @ CommandPayload::Empty => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "CommandPayload",
                            "Empty",
                            "try_unwrap_status",
                        ),
                    ),
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Attempts to unwrap this reference to the `CommandPayload::Status` variant.
        */
        ///Returns a [TryUnwrapError] with the original value if this value is of any other type.
        pub fn try_unwrap_status_ref(
            &self,
        ) -> derive_more::core::result::Result<(&ServiceStatus), derive_more::TryUnwrapError<&Self>>
        {
            match self {
                CommandPayload::Status(field_0) => derive_more::core::result::Result::Ok((field_0)),
                val @ _ => match val {
                    val @ CommandPayload::Status(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "CommandPayload",
                            "Status",
                            "try_unwrap_status_ref",
                        ),
                    ),
                    val @ CommandPayload::ListServices(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "CommandPayload",
                                "ListServices",
                                "try_unwrap_status_ref",
                            ),
                        )
                    }
                    val @ CommandPayload::ServiceConfig(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "CommandPayload",
                                "ServiceConfig",
                                "try_unwrap_status_ref",
                            ),
                        )
                    }
                    val @ CommandPayload::Dependencies(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "CommandPayload",
                                "Dependencies",
                                "try_unwrap_status_ref",
                            ),
                        )
                    }
                    val @ CommandPayload::Error(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "CommandPayload",
                            "Error",
                            "try_unwrap_status_ref",
                        ),
                    ),
                    val @ CommandPayload::Empty => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "CommandPayload",
                            "Empty",
                            "try_unwrap_status_ref",
                        ),
                    ),
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Attempts to unwrap this mutable reference to the `CommandPayload::Status` variant.
        */
        ///Returns a [TryUnwrapError] with the original value if this value is of any other type.
        pub fn try_unwrap_status_mut(
            &mut self,
        ) -> derive_more::core::result::Result<
            (&mut ServiceStatus),
            derive_more::TryUnwrapError<&mut Self>,
        > {
            match self {
                CommandPayload::Status(field_0) => derive_more::core::result::Result::Ok((field_0)),
                val @ _ => match val {
                    val @ CommandPayload::Status(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "CommandPayload",
                            "Status",
                            "try_unwrap_status_mut",
                        ),
                    ),
                    val @ CommandPayload::ListServices(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "CommandPayload",
                                "ListServices",
                                "try_unwrap_status_mut",
                            ),
                        )
                    }
                    val @ CommandPayload::ServiceConfig(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "CommandPayload",
                                "ServiceConfig",
                                "try_unwrap_status_mut",
                            ),
                        )
                    }
                    val @ CommandPayload::Dependencies(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "CommandPayload",
                                "Dependencies",
                                "try_unwrap_status_mut",
                            ),
                        )
                    }
                    val @ CommandPayload::Error(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "CommandPayload",
                            "Error",
                            "try_unwrap_status_mut",
                        ),
                    ),
                    val @ CommandPayload::Empty => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "CommandPayload",
                            "Empty",
                            "try_unwrap_status_mut",
                        ),
                    ),
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Attempts to unwrap this value to the `CommandPayload::ListServices` variant.
        */
        ///Returns a [TryUnwrapError] with the original value if this value is of any other type.
        pub fn try_unwrap_list_services(
            self,
        ) -> derive_more::core::result::Result<
            (ListServicesResponse),
            derive_more::TryUnwrapError<Self>,
        > {
            match self {
                CommandPayload::ListServices(field_0) => {
                    derive_more::core::result::Result::Ok((field_0))
                }
                val @ _ => match val {
                    val @ CommandPayload::Status(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "CommandPayload",
                            "Status",
                            "try_unwrap_list_services",
                        ),
                    ),
                    val @ CommandPayload::ListServices(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "CommandPayload",
                                "ListServices",
                                "try_unwrap_list_services",
                            ),
                        )
                    }
                    val @ CommandPayload::ServiceConfig(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "CommandPayload",
                                "ServiceConfig",
                                "try_unwrap_list_services",
                            ),
                        )
                    }
                    val @ CommandPayload::Dependencies(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "CommandPayload",
                                "Dependencies",
                                "try_unwrap_list_services",
                            ),
                        )
                    }
                    val @ CommandPayload::Error(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "CommandPayload",
                            "Error",
                            "try_unwrap_list_services",
                        ),
                    ),
                    val @ CommandPayload::Empty => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "CommandPayload",
                            "Empty",
                            "try_unwrap_list_services",
                        ),
                    ),
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Attempts to unwrap this reference to the `CommandPayload::ListServices` variant.
        */
        ///Returns a [TryUnwrapError] with the original value if this value is of any other type.
        pub fn try_unwrap_list_services_ref(
            &self,
        ) -> derive_more::core::result::Result<
            (&ListServicesResponse),
            derive_more::TryUnwrapError<&Self>,
        > {
            match self {
                CommandPayload::ListServices(field_0) => {
                    derive_more::core::result::Result::Ok((field_0))
                }
                val @ _ => match val {
                    val @ CommandPayload::Status(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "CommandPayload",
                            "Status",
                            "try_unwrap_list_services_ref",
                        ),
                    ),
                    val @ CommandPayload::ListServices(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "CommandPayload",
                                "ListServices",
                                "try_unwrap_list_services_ref",
                            ),
                        )
                    }
                    val @ CommandPayload::ServiceConfig(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "CommandPayload",
                                "ServiceConfig",
                                "try_unwrap_list_services_ref",
                            ),
                        )
                    }
                    val @ CommandPayload::Dependencies(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "CommandPayload",
                                "Dependencies",
                                "try_unwrap_list_services_ref",
                            ),
                        )
                    }
                    val @ CommandPayload::Error(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "CommandPayload",
                            "Error",
                            "try_unwrap_list_services_ref",
                        ),
                    ),
                    val @ CommandPayload::Empty => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "CommandPayload",
                            "Empty",
                            "try_unwrap_list_services_ref",
                        ),
                    ),
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Attempts to unwrap this mutable reference to the `CommandPayload::ListServices` variant.
        */
        ///Returns a [TryUnwrapError] with the original value if this value is of any other type.
        pub fn try_unwrap_list_services_mut(
            &mut self,
        ) -> derive_more::core::result::Result<
            (&mut ListServicesResponse),
            derive_more::TryUnwrapError<&mut Self>,
        > {
            match self {
                CommandPayload::ListServices(field_0) => {
                    derive_more::core::result::Result::Ok((field_0))
                }
                val @ _ => match val {
                    val @ CommandPayload::Status(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "CommandPayload",
                            "Status",
                            "try_unwrap_list_services_mut",
                        ),
                    ),
                    val @ CommandPayload::ListServices(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "CommandPayload",
                                "ListServices",
                                "try_unwrap_list_services_mut",
                            ),
                        )
                    }
                    val @ CommandPayload::ServiceConfig(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "CommandPayload",
                                "ServiceConfig",
                                "try_unwrap_list_services_mut",
                            ),
                        )
                    }
                    val @ CommandPayload::Dependencies(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "CommandPayload",
                                "Dependencies",
                                "try_unwrap_list_services_mut",
                            ),
                        )
                    }
                    val @ CommandPayload::Error(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "CommandPayload",
                            "Error",
                            "try_unwrap_list_services_mut",
                        ),
                    ),
                    val @ CommandPayload::Empty => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "CommandPayload",
                            "Empty",
                            "try_unwrap_list_services_mut",
                        ),
                    ),
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Attempts to unwrap this value to the `CommandPayload::ServiceConfig` variant.
        */
        ///Returns a [TryUnwrapError] with the original value if this value is of any other type.
        pub fn try_unwrap_service_config(
            self,
        ) -> derive_more::core::result::Result<
            (ServiceConfigPayload),
            derive_more::TryUnwrapError<Self>,
        > {
            match self {
                CommandPayload::ServiceConfig(field_0) => {
                    derive_more::core::result::Result::Ok((field_0))
                }
                val @ _ => match val {
                    val @ CommandPayload::Status(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "CommandPayload",
                            "Status",
                            "try_unwrap_service_config",
                        ),
                    ),
                    val @ CommandPayload::ListServices(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "CommandPayload",
                                "ListServices",
                                "try_unwrap_service_config",
                            ),
                        )
                    }
                    val @ CommandPayload::ServiceConfig(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "CommandPayload",
                                "ServiceConfig",
                                "try_unwrap_service_config",
                            ),
                        )
                    }
                    val @ CommandPayload::Dependencies(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "CommandPayload",
                                "Dependencies",
                                "try_unwrap_service_config",
                            ),
                        )
                    }
                    val @ CommandPayload::Error(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "CommandPayload",
                            "Error",
                            "try_unwrap_service_config",
                        ),
                    ),
                    val @ CommandPayload::Empty => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "CommandPayload",
                            "Empty",
                            "try_unwrap_service_config",
                        ),
                    ),
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Attempts to unwrap this reference to the `CommandPayload::ServiceConfig` variant.
        */
        ///Returns a [TryUnwrapError] with the original value if this value is of any other type.
        pub fn try_unwrap_service_config_ref(
            &self,
        ) -> derive_more::core::result::Result<
            (&ServiceConfigPayload),
            derive_more::TryUnwrapError<&Self>,
        > {
            match self {
                CommandPayload::ServiceConfig(field_0) => {
                    derive_more::core::result::Result::Ok((field_0))
                }
                val @ _ => match val {
                    val @ CommandPayload::Status(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "CommandPayload",
                            "Status",
                            "try_unwrap_service_config_ref",
                        ),
                    ),
                    val @ CommandPayload::ListServices(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "CommandPayload",
                                "ListServices",
                                "try_unwrap_service_config_ref",
                            ),
                        )
                    }
                    val @ CommandPayload::ServiceConfig(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "CommandPayload",
                                "ServiceConfig",
                                "try_unwrap_service_config_ref",
                            ),
                        )
                    }
                    val @ CommandPayload::Dependencies(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "CommandPayload",
                                "Dependencies",
                                "try_unwrap_service_config_ref",
                            ),
                        )
                    }
                    val @ CommandPayload::Error(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "CommandPayload",
                            "Error",
                            "try_unwrap_service_config_ref",
                        ),
                    ),
                    val @ CommandPayload::Empty => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "CommandPayload",
                            "Empty",
                            "try_unwrap_service_config_ref",
                        ),
                    ),
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Attempts to unwrap this mutable reference to the `CommandPayload::ServiceConfig` variant.
        */
        ///Returns a [TryUnwrapError] with the original value if this value is of any other type.
        pub fn try_unwrap_service_config_mut(
            &mut self,
        ) -> derive_more::core::result::Result<
            (&mut ServiceConfigPayload),
            derive_more::TryUnwrapError<&mut Self>,
        > {
            match self {
                CommandPayload::ServiceConfig(field_0) => {
                    derive_more::core::result::Result::Ok((field_0))
                }
                val @ _ => match val {
                    val @ CommandPayload::Status(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "CommandPayload",
                            "Status",
                            "try_unwrap_service_config_mut",
                        ),
                    ),
                    val @ CommandPayload::ListServices(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "CommandPayload",
                                "ListServices",
                                "try_unwrap_service_config_mut",
                            ),
                        )
                    }
                    val @ CommandPayload::ServiceConfig(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "CommandPayload",
                                "ServiceConfig",
                                "try_unwrap_service_config_mut",
                            ),
                        )
                    }
                    val @ CommandPayload::Dependencies(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "CommandPayload",
                                "Dependencies",
                                "try_unwrap_service_config_mut",
                            ),
                        )
                    }
                    val @ CommandPayload::Error(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "CommandPayload",
                            "Error",
                            "try_unwrap_service_config_mut",
                        ),
                    ),
                    val @ CommandPayload::Empty => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "CommandPayload",
                            "Empty",
                            "try_unwrap_service_config_mut",
                        ),
                    ),
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Attempts to unwrap this value to the `CommandPayload::Dependencies` variant.
        */
        ///Returns a [TryUnwrapError] with the original value if this value is of any other type.
        pub fn try_unwrap_dependencies(
            self,
        ) -> derive_more::core::result::Result<
            (ListDependenciesResponse),
            derive_more::TryUnwrapError<Self>,
        > {
            match self {
                CommandPayload::Dependencies(field_0) => {
                    derive_more::core::result::Result::Ok((field_0))
                }
                val @ _ => match val {
                    val @ CommandPayload::Status(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "CommandPayload",
                            "Status",
                            "try_unwrap_dependencies",
                        ),
                    ),
                    val @ CommandPayload::ListServices(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "CommandPayload",
                                "ListServices",
                                "try_unwrap_dependencies",
                            ),
                        )
                    }
                    val @ CommandPayload::ServiceConfig(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "CommandPayload",
                                "ServiceConfig",
                                "try_unwrap_dependencies",
                            ),
                        )
                    }
                    val @ CommandPayload::Dependencies(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "CommandPayload",
                                "Dependencies",
                                "try_unwrap_dependencies",
                            ),
                        )
                    }
                    val @ CommandPayload::Error(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "CommandPayload",
                            "Error",
                            "try_unwrap_dependencies",
                        ),
                    ),
                    val @ CommandPayload::Empty => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "CommandPayload",
                            "Empty",
                            "try_unwrap_dependencies",
                        ),
                    ),
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Attempts to unwrap this reference to the `CommandPayload::Dependencies` variant.
        */
        ///Returns a [TryUnwrapError] with the original value if this value is of any other type.
        pub fn try_unwrap_dependencies_ref(
            &self,
        ) -> derive_more::core::result::Result<
            (&ListDependenciesResponse),
            derive_more::TryUnwrapError<&Self>,
        > {
            match self {
                CommandPayload::Dependencies(field_0) => {
                    derive_more::core::result::Result::Ok((field_0))
                }
                val @ _ => match val {
                    val @ CommandPayload::Status(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "CommandPayload",
                            "Status",
                            "try_unwrap_dependencies_ref",
                        ),
                    ),
                    val @ CommandPayload::ListServices(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "CommandPayload",
                                "ListServices",
                                "try_unwrap_dependencies_ref",
                            ),
                        )
                    }
                    val @ CommandPayload::ServiceConfig(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "CommandPayload",
                                "ServiceConfig",
                                "try_unwrap_dependencies_ref",
                            ),
                        )
                    }
                    val @ CommandPayload::Dependencies(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "CommandPayload",
                                "Dependencies",
                                "try_unwrap_dependencies_ref",
                            ),
                        )
                    }
                    val @ CommandPayload::Error(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "CommandPayload",
                            "Error",
                            "try_unwrap_dependencies_ref",
                        ),
                    ),
                    val @ CommandPayload::Empty => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "CommandPayload",
                            "Empty",
                            "try_unwrap_dependencies_ref",
                        ),
                    ),
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Attempts to unwrap this mutable reference to the `CommandPayload::Dependencies` variant.
        */
        ///Returns a [TryUnwrapError] with the original value if this value is of any other type.
        pub fn try_unwrap_dependencies_mut(
            &mut self,
        ) -> derive_more::core::result::Result<
            (&mut ListDependenciesResponse),
            derive_more::TryUnwrapError<&mut Self>,
        > {
            match self {
                CommandPayload::Dependencies(field_0) => {
                    derive_more::core::result::Result::Ok((field_0))
                }
                val @ _ => match val {
                    val @ CommandPayload::Status(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "CommandPayload",
                            "Status",
                            "try_unwrap_dependencies_mut",
                        ),
                    ),
                    val @ CommandPayload::ListServices(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "CommandPayload",
                                "ListServices",
                                "try_unwrap_dependencies_mut",
                            ),
                        )
                    }
                    val @ CommandPayload::ServiceConfig(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "CommandPayload",
                                "ServiceConfig",
                                "try_unwrap_dependencies_mut",
                            ),
                        )
                    }
                    val @ CommandPayload::Dependencies(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "CommandPayload",
                                "Dependencies",
                                "try_unwrap_dependencies_mut",
                            ),
                        )
                    }
                    val @ CommandPayload::Error(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "CommandPayload",
                            "Error",
                            "try_unwrap_dependencies_mut",
                        ),
                    ),
                    val @ CommandPayload::Empty => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "CommandPayload",
                            "Empty",
                            "try_unwrap_dependencies_mut",
                        ),
                    ),
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Attempts to unwrap this value to the `CommandPayload::Error` variant.
        */
        ///Returns a [TryUnwrapError] with the original value if this value is of any other type.
        pub fn try_unwrap_error(
            self,
        ) -> derive_more::core::result::Result<(ErrorPayload), derive_more::TryUnwrapError<Self>>
        {
            match self {
                CommandPayload::Error(field_0) => derive_more::core::result::Result::Ok((field_0)),
                val @ _ => match val {
                    val @ CommandPayload::Status(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "CommandPayload",
                            "Status",
                            "try_unwrap_error",
                        ),
                    ),
                    val @ CommandPayload::ListServices(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "CommandPayload",
                                "ListServices",
                                "try_unwrap_error",
                            ),
                        )
                    }
                    val @ CommandPayload::ServiceConfig(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "CommandPayload",
                                "ServiceConfig",
                                "try_unwrap_error",
                            ),
                        )
                    }
                    val @ CommandPayload::Dependencies(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "CommandPayload",
                                "Dependencies",
                                "try_unwrap_error",
                            ),
                        )
                    }
                    val @ CommandPayload::Error(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "CommandPayload",
                            "Error",
                            "try_unwrap_error",
                        ),
                    ),
                    val @ CommandPayload::Empty => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "CommandPayload",
                            "Empty",
                            "try_unwrap_error",
                        ),
                    ),
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Attempts to unwrap this reference to the `CommandPayload::Error` variant.
        */
        ///Returns a [TryUnwrapError] with the original value if this value is of any other type.
        pub fn try_unwrap_error_ref(
            &self,
        ) -> derive_more::core::result::Result<(&ErrorPayload), derive_more::TryUnwrapError<&Self>>
        {
            match self {
                CommandPayload::Error(field_0) => derive_more::core::result::Result::Ok((field_0)),
                val @ _ => match val {
                    val @ CommandPayload::Status(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "CommandPayload",
                            "Status",
                            "try_unwrap_error_ref",
                        ),
                    ),
                    val @ CommandPayload::ListServices(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "CommandPayload",
                                "ListServices",
                                "try_unwrap_error_ref",
                            ),
                        )
                    }
                    val @ CommandPayload::ServiceConfig(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "CommandPayload",
                                "ServiceConfig",
                                "try_unwrap_error_ref",
                            ),
                        )
                    }
                    val @ CommandPayload::Dependencies(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "CommandPayload",
                                "Dependencies",
                                "try_unwrap_error_ref",
                            ),
                        )
                    }
                    val @ CommandPayload::Error(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "CommandPayload",
                            "Error",
                            "try_unwrap_error_ref",
                        ),
                    ),
                    val @ CommandPayload::Empty => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "CommandPayload",
                            "Empty",
                            "try_unwrap_error_ref",
                        ),
                    ),
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Attempts to unwrap this mutable reference to the `CommandPayload::Error` variant.
        */
        ///Returns a [TryUnwrapError] with the original value if this value is of any other type.
        pub fn try_unwrap_error_mut(
            &mut self,
        ) -> derive_more::core::result::Result<
            (&mut ErrorPayload),
            derive_more::TryUnwrapError<&mut Self>,
        > {
            match self {
                CommandPayload::Error(field_0) => derive_more::core::result::Result::Ok((field_0)),
                val @ _ => match val {
                    val @ CommandPayload::Status(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "CommandPayload",
                            "Status",
                            "try_unwrap_error_mut",
                        ),
                    ),
                    val @ CommandPayload::ListServices(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "CommandPayload",
                                "ListServices",
                                "try_unwrap_error_mut",
                            ),
                        )
                    }
                    val @ CommandPayload::ServiceConfig(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "CommandPayload",
                                "ServiceConfig",
                                "try_unwrap_error_mut",
                            ),
                        )
                    }
                    val @ CommandPayload::Dependencies(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "CommandPayload",
                                "Dependencies",
                                "try_unwrap_error_mut",
                            ),
                        )
                    }
                    val @ CommandPayload::Error(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "CommandPayload",
                            "Error",
                            "try_unwrap_error_mut",
                        ),
                    ),
                    val @ CommandPayload::Empty => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "CommandPayload",
                            "Empty",
                            "try_unwrap_error_mut",
                        ),
                    ),
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Attempts to unwrap this value to the `CommandPayload::Empty` variant.
        */
        ///Returns a [TryUnwrapError] with the original value if this value is of any other type.
        pub fn try_unwrap_empty(
            self,
        ) -> derive_more::core::result::Result<(), derive_more::TryUnwrapError<Self>> {
            match self {
                CommandPayload::Empty => derive_more::core::result::Result::Ok(()),
                val @ _ => match val {
                    val @ CommandPayload::Status(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "CommandPayload",
                            "Status",
                            "try_unwrap_empty",
                        ),
                    ),
                    val @ CommandPayload::ListServices(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "CommandPayload",
                                "ListServices",
                                "try_unwrap_empty",
                            ),
                        )
                    }
                    val @ CommandPayload::ServiceConfig(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "CommandPayload",
                                "ServiceConfig",
                                "try_unwrap_empty",
                            ),
                        )
                    }
                    val @ CommandPayload::Dependencies(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "CommandPayload",
                                "Dependencies",
                                "try_unwrap_empty",
                            ),
                        )
                    }
                    val @ CommandPayload::Error(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "CommandPayload",
                            "Error",
                            "try_unwrap_empty",
                        ),
                    ),
                    val @ CommandPayload::Empty => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "CommandPayload",
                            "Empty",
                            "try_unwrap_empty",
                        ),
                    ),
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Attempts to unwrap this reference to the `CommandPayload::Empty` variant.
        */
        ///Returns a [TryUnwrapError] with the original value if this value is of any other type.
        pub fn try_unwrap_empty_ref(
            &self,
        ) -> derive_more::core::result::Result<(), derive_more::TryUnwrapError<&Self>> {
            match self {
                CommandPayload::Empty => derive_more::core::result::Result::Ok(()),
                val @ _ => match val {
                    val @ CommandPayload::Status(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "CommandPayload",
                            "Status",
                            "try_unwrap_empty_ref",
                        ),
                    ),
                    val @ CommandPayload::ListServices(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "CommandPayload",
                                "ListServices",
                                "try_unwrap_empty_ref",
                            ),
                        )
                    }
                    val @ CommandPayload::ServiceConfig(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "CommandPayload",
                                "ServiceConfig",
                                "try_unwrap_empty_ref",
                            ),
                        )
                    }
                    val @ CommandPayload::Dependencies(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "CommandPayload",
                                "Dependencies",
                                "try_unwrap_empty_ref",
                            ),
                        )
                    }
                    val @ CommandPayload::Error(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "CommandPayload",
                            "Error",
                            "try_unwrap_empty_ref",
                        ),
                    ),
                    val @ CommandPayload::Empty => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "CommandPayload",
                            "Empty",
                            "try_unwrap_empty_ref",
                        ),
                    ),
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Attempts to unwrap this mutable reference to the `CommandPayload::Empty` variant.
        */
        ///Returns a [TryUnwrapError] with the original value if this value is of any other type.
        pub fn try_unwrap_empty_mut(
            &mut self,
        ) -> derive_more::core::result::Result<(), derive_more::TryUnwrapError<&mut Self>> {
            match self {
                CommandPayload::Empty => derive_more::core::result::Result::Ok(()),
                val @ _ => match val {
                    val @ CommandPayload::Status(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "CommandPayload",
                            "Status",
                            "try_unwrap_empty_mut",
                        ),
                    ),
                    val @ CommandPayload::ListServices(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "CommandPayload",
                                "ListServices",
                                "try_unwrap_empty_mut",
                            ),
                        )
                    }
                    val @ CommandPayload::ServiceConfig(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "CommandPayload",
                                "ServiceConfig",
                                "try_unwrap_empty_mut",
                            ),
                        )
                    }
                    val @ CommandPayload::Dependencies(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "CommandPayload",
                                "Dependencies",
                                "try_unwrap_empty_mut",
                            ),
                        )
                    }
                    val @ CommandPayload::Error(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "CommandPayload",
                            "Error",
                            "try_unwrap_empty_mut",
                        ),
                    ),
                    val @ CommandPayload::Empty => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "CommandPayload",
                            "Empty",
                            "try_unwrap_empty_mut",
                        ),
                    ),
                },
            }
        }
    }
    #[automatically_derived]
    impl derive_more::From<(ServiceStatus)> for CommandPayload {
        #[inline]
        fn from(value: (ServiceStatus)) -> Self {
            CommandPayload::Status(value)
        }
    }
    #[automatically_derived]
    impl derive_more::From<(ListServicesResponse)> for CommandPayload {
        #[inline]
        fn from(value: (ListServicesResponse)) -> Self {
            CommandPayload::ListServices(value)
        }
    }
    #[automatically_derived]
    impl derive_more::From<(ServiceConfigPayload)> for CommandPayload {
        #[inline]
        fn from(value: (ServiceConfigPayload)) -> Self {
            CommandPayload::ServiceConfig(value)
        }
    }
    #[automatically_derived]
    impl derive_more::From<(ListDependenciesResponse)> for CommandPayload {
        #[inline]
        fn from(value: (ListDependenciesResponse)) -> Self {
            CommandPayload::Dependencies(value)
        }
    }
    #[automatically_derived]
    impl derive_more::From<(ErrorPayload)> for CommandPayload {
        #[inline]
        fn from(value: (ErrorPayload)) -> Self {
            CommandPayload::Error(value)
        }
    }
    impl TryFrom<CommandPayload> for () {
        type Error = ::anyhow::Error;
        fn try_from(value: CommandPayload) -> Result<Self, Self::Error> {
            #[allow(unused_imports)]
            use crate::commands::CommandPayload::Empty;
            if !value.is_empty() {
                return ::anyhow::__private::Err(::anyhow::Error::msg(
                    ::alloc::__export::must_use({
                        let res = ::alloc::fmt::format(format_args!(
                            "Command is not of type `{0}`",
                            "Empty"
                        ));
                        res
                    }),
                ));
            }
            Ok(value.unwrap_empty())
        }
    }
    #[unwrap(ref, ref_mut)]
    #[try_unwrap(ref, ref_mut)]
    #[non_exhaustive]
    pub enum ServiceCommand {
        Start(StartServiceCommand),
        Stop(StopServiceCommand),
        Restart(RestartServiceCommand),
        List(ListServicesCommand),
        Status(GetServiceStatus),
        Add(AddServiceCommand),
        Remove(RemoveServiceCommand),
        ConfigGet(GetConfig),
        ConfigUpdate(UpdateConfigCommand),
        DependencyAdd(AddDependencyCommand),
        DependencyRemove(RemoveDependencyCommand),
        DependencyList(ListDependenciesCommand),
        GitCheckout(CheckoutCommand),
        GitStatus(GetRepoStatusCommand),
    }
    #[automatically_derived]
    impl derive_more::From<(StartServiceCommand)> for ServiceCommand {
        #[inline]
        fn from(value: (StartServiceCommand)) -> Self {
            ServiceCommand::Start(value)
        }
    }
    #[automatically_derived]
    impl derive_more::From<(StopServiceCommand)> for ServiceCommand {
        #[inline]
        fn from(value: (StopServiceCommand)) -> Self {
            ServiceCommand::Stop(value)
        }
    }
    #[automatically_derived]
    impl derive_more::From<(RestartServiceCommand)> for ServiceCommand {
        #[inline]
        fn from(value: (RestartServiceCommand)) -> Self {
            ServiceCommand::Restart(value)
        }
    }
    #[automatically_derived]
    impl derive_more::From<(ListServicesCommand)> for ServiceCommand {
        #[inline]
        fn from(value: (ListServicesCommand)) -> Self {
            ServiceCommand::List(value)
        }
    }
    #[automatically_derived]
    impl derive_more::From<(GetServiceStatus)> for ServiceCommand {
        #[inline]
        fn from(value: (GetServiceStatus)) -> Self {
            ServiceCommand::Status(value)
        }
    }
    #[automatically_derived]
    impl derive_more::From<(AddServiceCommand)> for ServiceCommand {
        #[inline]
        fn from(value: (AddServiceCommand)) -> Self {
            ServiceCommand::Add(value)
        }
    }
    #[automatically_derived]
    impl derive_more::From<(RemoveServiceCommand)> for ServiceCommand {
        #[inline]
        fn from(value: (RemoveServiceCommand)) -> Self {
            ServiceCommand::Remove(value)
        }
    }
    #[automatically_derived]
    impl derive_more::From<(GetConfig)> for ServiceCommand {
        #[inline]
        fn from(value: (GetConfig)) -> Self {
            ServiceCommand::ConfigGet(value)
        }
    }
    #[automatically_derived]
    impl derive_more::From<(UpdateConfigCommand)> for ServiceCommand {
        #[inline]
        fn from(value: (UpdateConfigCommand)) -> Self {
            ServiceCommand::ConfigUpdate(value)
        }
    }
    #[automatically_derived]
    impl derive_more::From<(AddDependencyCommand)> for ServiceCommand {
        #[inline]
        fn from(value: (AddDependencyCommand)) -> Self {
            ServiceCommand::DependencyAdd(value)
        }
    }
    #[automatically_derived]
    impl derive_more::From<(RemoveDependencyCommand)> for ServiceCommand {
        #[inline]
        fn from(value: (RemoveDependencyCommand)) -> Self {
            ServiceCommand::DependencyRemove(value)
        }
    }
    #[automatically_derived]
    impl derive_more::From<(ListDependenciesCommand)> for ServiceCommand {
        #[inline]
        fn from(value: (ListDependenciesCommand)) -> Self {
            ServiceCommand::DependencyList(value)
        }
    }
    #[automatically_derived]
    impl derive_more::From<(CheckoutCommand)> for ServiceCommand {
        #[inline]
        fn from(value: (CheckoutCommand)) -> Self {
            ServiceCommand::GitCheckout(value)
        }
    }
    #[automatically_derived]
    impl derive_more::From<(GetRepoStatusCommand)> for ServiceCommand {
        #[inline]
        fn from(value: (GetRepoStatusCommand)) -> Self {
            ServiceCommand::GitStatus(value)
        }
    }
    #[automatically_derived]
    impl ServiceCommand {
        ///Returns `true` if this value is of type `
        ///Start
        ///`. Returns `false` otherwise
        #[inline]
        #[must_use]
        pub const fn is_start(&self) -> bool {
            match self {
                ServiceCommand::Start(..) => true,
                _ => false,
            }
        }
        ///Returns `true` if this value is of type `
        ///Stop
        ///`. Returns `false` otherwise
        #[inline]
        #[must_use]
        pub const fn is_stop(&self) -> bool {
            match self {
                ServiceCommand::Stop(..) => true,
                _ => false,
            }
        }
        ///Returns `true` if this value is of type `
        ///Restart
        ///`. Returns `false` otherwise
        #[inline]
        #[must_use]
        pub const fn is_restart(&self) -> bool {
            match self {
                ServiceCommand::Restart(..) => true,
                _ => false,
            }
        }
        ///Returns `true` if this value is of type `
        ///List
        ///`. Returns `false` otherwise
        #[inline]
        #[must_use]
        pub const fn is_list(&self) -> bool {
            match self {
                ServiceCommand::List(..) => true,
                _ => false,
            }
        }
        ///Returns `true` if this value is of type `
        ///Status
        ///`. Returns `false` otherwise
        #[inline]
        #[must_use]
        pub const fn is_status(&self) -> bool {
            match self {
                ServiceCommand::Status(..) => true,
                _ => false,
            }
        }
        ///Returns `true` if this value is of type `
        ///Add
        ///`. Returns `false` otherwise
        #[inline]
        #[must_use]
        pub const fn is_add(&self) -> bool {
            match self {
                ServiceCommand::Add(..) => true,
                _ => false,
            }
        }
        ///Returns `true` if this value is of type `
        ///Remove
        ///`. Returns `false` otherwise
        #[inline]
        #[must_use]
        pub const fn is_remove(&self) -> bool {
            match self {
                ServiceCommand::Remove(..) => true,
                _ => false,
            }
        }
        ///Returns `true` if this value is of type `
        ///ConfigGet
        ///`. Returns `false` otherwise
        #[inline]
        #[must_use]
        pub const fn is_config_get(&self) -> bool {
            match self {
                ServiceCommand::ConfigGet(..) => true,
                _ => false,
            }
        }
        ///Returns `true` if this value is of type `
        ///ConfigUpdate
        ///`. Returns `false` otherwise
        #[inline]
        #[must_use]
        pub const fn is_config_update(&self) -> bool {
            match self {
                ServiceCommand::ConfigUpdate(..) => true,
                _ => false,
            }
        }
        ///Returns `true` if this value is of type `
        ///DependencyAdd
        ///`. Returns `false` otherwise
        #[inline]
        #[must_use]
        pub const fn is_dependency_add(&self) -> bool {
            match self {
                ServiceCommand::DependencyAdd(..) => true,
                _ => false,
            }
        }
        ///Returns `true` if this value is of type `
        ///DependencyRemove
        ///`. Returns `false` otherwise
        #[inline]
        #[must_use]
        pub const fn is_dependency_remove(&self) -> bool {
            match self {
                ServiceCommand::DependencyRemove(..) => true,
                _ => false,
            }
        }
        ///Returns `true` if this value is of type `
        ///DependencyList
        ///`. Returns `false` otherwise
        #[inline]
        #[must_use]
        pub const fn is_dependency_list(&self) -> bool {
            match self {
                ServiceCommand::DependencyList(..) => true,
                _ => false,
            }
        }
        ///Returns `true` if this value is of type `
        ///GitCheckout
        ///`. Returns `false` otherwise
        #[inline]
        #[must_use]
        pub const fn is_git_checkout(&self) -> bool {
            match self {
                ServiceCommand::GitCheckout(..) => true,
                _ => false,
            }
        }
        ///Returns `true` if this value is of type `
        ///GitStatus
        ///`. Returns `false` otherwise
        #[inline]
        #[must_use]
        pub const fn is_git_status(&self) -> bool {
            match self {
                ServiceCommand::GitStatus(..) => true,
                _ => false,
            }
        }
    }
    #[automatically_derived]
    impl ServiceCommand {
        #[inline]
        #[track_caller]
        /**Unwraps this value to the `ServiceCommand::Start` variant.
        */
        ///Panics if this value is of any other type.
        pub fn unwrap_start(self) -> (StartServiceCommand) {
            match self {
                ServiceCommand::Start(field_0) => (field_0),
                val @ _ => match val {
                    ServiceCommand::Start(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_start()` on a `ServiceCommand::Start` value",
                                ),
                            );
                    }
                    ServiceCommand::Stop(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_start()` on a `ServiceCommand::Stop` value",
                                ),
                            );
                    }
                    ServiceCommand::Restart(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_start()` on a `ServiceCommand::Restart` value",
                                ),
                            );
                    }
                    ServiceCommand::List(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_start()` on a `ServiceCommand::List` value",
                                ),
                            );
                    }
                    ServiceCommand::Status(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_start()` on a `ServiceCommand::Status` value",
                                ),
                            );
                    }
                    ServiceCommand::Add(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_start()` on a `ServiceCommand::Add` value",
                                ),
                            );
                    }
                    ServiceCommand::Remove(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_start()` on a `ServiceCommand::Remove` value",
                                ),
                            );
                    }
                    ServiceCommand::ConfigGet(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_start()` on a `ServiceCommand::ConfigGet` value",
                                ),
                            );
                    }
                    ServiceCommand::ConfigUpdate(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_start()` on a `ServiceCommand::ConfigUpdate` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyAdd(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_start()` on a `ServiceCommand::DependencyAdd` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyRemove(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_start()` on a `ServiceCommand::DependencyRemove` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyList(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_start()` on a `ServiceCommand::DependencyList` value",
                                ),
                            );
                    }
                    ServiceCommand::GitCheckout(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_start()` on a `ServiceCommand::GitCheckout` value",
                                ),
                            );
                    }
                    ServiceCommand::GitStatus(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_start()` on a `ServiceCommand::GitStatus` value",
                                ),
                            );
                    }
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Unwraps this reference to the `ServiceCommand::Start` variant.
        */
        ///Panics if this value is of any other type.
        pub fn unwrap_start_ref(&self) -> (&StartServiceCommand) {
            match self {
                ServiceCommand::Start(field_0) => (field_0),
                val @ _ => match val {
                    ServiceCommand::Start(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_start_ref()` on a `ServiceCommand::Start` value",
                                ),
                            );
                    }
                    ServiceCommand::Stop(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_start_ref()` on a `ServiceCommand::Stop` value",
                                ),
                            );
                    }
                    ServiceCommand::Restart(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_start_ref()` on a `ServiceCommand::Restart` value",
                                ),
                            );
                    }
                    ServiceCommand::List(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_start_ref()` on a `ServiceCommand::List` value",
                                ),
                            );
                    }
                    ServiceCommand::Status(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_start_ref()` on a `ServiceCommand::Status` value",
                                ),
                            );
                    }
                    ServiceCommand::Add(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_start_ref()` on a `ServiceCommand::Add` value",
                                ),
                            );
                    }
                    ServiceCommand::Remove(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_start_ref()` on a `ServiceCommand::Remove` value",
                                ),
                            );
                    }
                    ServiceCommand::ConfigGet(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_start_ref()` on a `ServiceCommand::ConfigGet` value",
                                ),
                            );
                    }
                    ServiceCommand::ConfigUpdate(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_start_ref()` on a `ServiceCommand::ConfigUpdate` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyAdd(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_start_ref()` on a `ServiceCommand::DependencyAdd` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyRemove(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_start_ref()` on a `ServiceCommand::DependencyRemove` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyList(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_start_ref()` on a `ServiceCommand::DependencyList` value",
                                ),
                            );
                    }
                    ServiceCommand::GitCheckout(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_start_ref()` on a `ServiceCommand::GitCheckout` value",
                                ),
                            );
                    }
                    ServiceCommand::GitStatus(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_start_ref()` on a `ServiceCommand::GitStatus` value",
                                ),
                            );
                    }
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Unwraps this mutable reference to the `ServiceCommand::Start` variant.
        */
        ///Panics if this value is of any other type.
        pub fn unwrap_start_mut(&mut self) -> (&mut StartServiceCommand) {
            match self {
                ServiceCommand::Start(field_0) => (field_0),
                val @ _ => match val {
                    ServiceCommand::Start(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_start_mut()` on a `ServiceCommand::Start` value",
                                ),
                            );
                    }
                    ServiceCommand::Stop(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_start_mut()` on a `ServiceCommand::Stop` value",
                                ),
                            );
                    }
                    ServiceCommand::Restart(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_start_mut()` on a `ServiceCommand::Restart` value",
                                ),
                            );
                    }
                    ServiceCommand::List(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_start_mut()` on a `ServiceCommand::List` value",
                                ),
                            );
                    }
                    ServiceCommand::Status(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_start_mut()` on a `ServiceCommand::Status` value",
                                ),
                            );
                    }
                    ServiceCommand::Add(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_start_mut()` on a `ServiceCommand::Add` value",
                                ),
                            );
                    }
                    ServiceCommand::Remove(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_start_mut()` on a `ServiceCommand::Remove` value",
                                ),
                            );
                    }
                    ServiceCommand::ConfigGet(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_start_mut()` on a `ServiceCommand::ConfigGet` value",
                                ),
                            );
                    }
                    ServiceCommand::ConfigUpdate(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_start_mut()` on a `ServiceCommand::ConfigUpdate` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyAdd(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_start_mut()` on a `ServiceCommand::DependencyAdd` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyRemove(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_start_mut()` on a `ServiceCommand::DependencyRemove` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyList(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_start_mut()` on a `ServiceCommand::DependencyList` value",
                                ),
                            );
                    }
                    ServiceCommand::GitCheckout(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_start_mut()` on a `ServiceCommand::GitCheckout` value",
                                ),
                            );
                    }
                    ServiceCommand::GitStatus(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_start_mut()` on a `ServiceCommand::GitStatus` value",
                                ),
                            );
                    }
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Unwraps this value to the `ServiceCommand::Stop` variant.
        */
        ///Panics if this value is of any other type.
        pub fn unwrap_stop(self) -> (StopServiceCommand) {
            match self {
                ServiceCommand::Stop(field_0) => (field_0),
                val @ _ => match val {
                    ServiceCommand::Start(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_stop()` on a `ServiceCommand::Start` value",
                                ),
                            );
                    }
                    ServiceCommand::Stop(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_stop()` on a `ServiceCommand::Stop` value",
                                ),
                            );
                    }
                    ServiceCommand::Restart(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_stop()` on a `ServiceCommand::Restart` value",
                                ),
                            );
                    }
                    ServiceCommand::List(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_stop()` on a `ServiceCommand::List` value",
                                ),
                            );
                    }
                    ServiceCommand::Status(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_stop()` on a `ServiceCommand::Status` value",
                                ),
                            );
                    }
                    ServiceCommand::Add(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_stop()` on a `ServiceCommand::Add` value",
                                ),
                            );
                    }
                    ServiceCommand::Remove(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_stop()` on a `ServiceCommand::Remove` value",
                                ),
                            );
                    }
                    ServiceCommand::ConfigGet(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_stop()` on a `ServiceCommand::ConfigGet` value",
                                ),
                            );
                    }
                    ServiceCommand::ConfigUpdate(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_stop()` on a `ServiceCommand::ConfigUpdate` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyAdd(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_stop()` on a `ServiceCommand::DependencyAdd` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyRemove(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_stop()` on a `ServiceCommand::DependencyRemove` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyList(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_stop()` on a `ServiceCommand::DependencyList` value",
                                ),
                            );
                    }
                    ServiceCommand::GitCheckout(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_stop()` on a `ServiceCommand::GitCheckout` value",
                                ),
                            );
                    }
                    ServiceCommand::GitStatus(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_stop()` on a `ServiceCommand::GitStatus` value",
                                ),
                            );
                    }
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Unwraps this reference to the `ServiceCommand::Stop` variant.
        */
        ///Panics if this value is of any other type.
        pub fn unwrap_stop_ref(&self) -> (&StopServiceCommand) {
            match self {
                ServiceCommand::Stop(field_0) => (field_0),
                val @ _ => match val {
                    ServiceCommand::Start(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_stop_ref()` on a `ServiceCommand::Start` value",
                                ),
                            );
                    }
                    ServiceCommand::Stop(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_stop_ref()` on a `ServiceCommand::Stop` value",
                                ),
                            );
                    }
                    ServiceCommand::Restart(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_stop_ref()` on a `ServiceCommand::Restart` value",
                                ),
                            );
                    }
                    ServiceCommand::List(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_stop_ref()` on a `ServiceCommand::List` value",
                                ),
                            );
                    }
                    ServiceCommand::Status(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_stop_ref()` on a `ServiceCommand::Status` value",
                                ),
                            );
                    }
                    ServiceCommand::Add(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_stop_ref()` on a `ServiceCommand::Add` value",
                                ),
                            );
                    }
                    ServiceCommand::Remove(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_stop_ref()` on a `ServiceCommand::Remove` value",
                                ),
                            );
                    }
                    ServiceCommand::ConfigGet(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_stop_ref()` on a `ServiceCommand::ConfigGet` value",
                                ),
                            );
                    }
                    ServiceCommand::ConfigUpdate(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_stop_ref()` on a `ServiceCommand::ConfigUpdate` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyAdd(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_stop_ref()` on a `ServiceCommand::DependencyAdd` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyRemove(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_stop_ref()` on a `ServiceCommand::DependencyRemove` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyList(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_stop_ref()` on a `ServiceCommand::DependencyList` value",
                                ),
                            );
                    }
                    ServiceCommand::GitCheckout(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_stop_ref()` on a `ServiceCommand::GitCheckout` value",
                                ),
                            );
                    }
                    ServiceCommand::GitStatus(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_stop_ref()` on a `ServiceCommand::GitStatus` value",
                                ),
                            );
                    }
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Unwraps this mutable reference to the `ServiceCommand::Stop` variant.
        */
        ///Panics if this value is of any other type.
        pub fn unwrap_stop_mut(&mut self) -> (&mut StopServiceCommand) {
            match self {
                ServiceCommand::Stop(field_0) => (field_0),
                val @ _ => match val {
                    ServiceCommand::Start(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_stop_mut()` on a `ServiceCommand::Start` value",
                                ),
                            );
                    }
                    ServiceCommand::Stop(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_stop_mut()` on a `ServiceCommand::Stop` value",
                                ),
                            );
                    }
                    ServiceCommand::Restart(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_stop_mut()` on a `ServiceCommand::Restart` value",
                                ),
                            );
                    }
                    ServiceCommand::List(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_stop_mut()` on a `ServiceCommand::List` value",
                                ),
                            );
                    }
                    ServiceCommand::Status(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_stop_mut()` on a `ServiceCommand::Status` value",
                                ),
                            );
                    }
                    ServiceCommand::Add(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_stop_mut()` on a `ServiceCommand::Add` value",
                                ),
                            );
                    }
                    ServiceCommand::Remove(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_stop_mut()` on a `ServiceCommand::Remove` value",
                                ),
                            );
                    }
                    ServiceCommand::ConfigGet(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_stop_mut()` on a `ServiceCommand::ConfigGet` value",
                                ),
                            );
                    }
                    ServiceCommand::ConfigUpdate(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_stop_mut()` on a `ServiceCommand::ConfigUpdate` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyAdd(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_stop_mut()` on a `ServiceCommand::DependencyAdd` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyRemove(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_stop_mut()` on a `ServiceCommand::DependencyRemove` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyList(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_stop_mut()` on a `ServiceCommand::DependencyList` value",
                                ),
                            );
                    }
                    ServiceCommand::GitCheckout(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_stop_mut()` on a `ServiceCommand::GitCheckout` value",
                                ),
                            );
                    }
                    ServiceCommand::GitStatus(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_stop_mut()` on a `ServiceCommand::GitStatus` value",
                                ),
                            );
                    }
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Unwraps this value to the `ServiceCommand::Restart` variant.
        */
        ///Panics if this value is of any other type.
        pub fn unwrap_restart(self) -> (RestartServiceCommand) {
            match self {
                ServiceCommand::Restart(field_0) => (field_0),
                val @ _ => match val {
                    ServiceCommand::Start(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_restart()` on a `ServiceCommand::Start` value",
                                ),
                            );
                    }
                    ServiceCommand::Stop(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_restart()` on a `ServiceCommand::Stop` value",
                                ),
                            );
                    }
                    ServiceCommand::Restart(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_restart()` on a `ServiceCommand::Restart` value",
                                ),
                            );
                    }
                    ServiceCommand::List(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_restart()` on a `ServiceCommand::List` value",
                                ),
                            );
                    }
                    ServiceCommand::Status(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_restart()` on a `ServiceCommand::Status` value",
                                ),
                            );
                    }
                    ServiceCommand::Add(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_restart()` on a `ServiceCommand::Add` value",
                                ),
                            );
                    }
                    ServiceCommand::Remove(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_restart()` on a `ServiceCommand::Remove` value",
                                ),
                            );
                    }
                    ServiceCommand::ConfigGet(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_restart()` on a `ServiceCommand::ConfigGet` value",
                                ),
                            );
                    }
                    ServiceCommand::ConfigUpdate(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_restart()` on a `ServiceCommand::ConfigUpdate` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyAdd(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_restart()` on a `ServiceCommand::DependencyAdd` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyRemove(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_restart()` on a `ServiceCommand::DependencyRemove` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyList(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_restart()` on a `ServiceCommand::DependencyList` value",
                                ),
                            );
                    }
                    ServiceCommand::GitCheckout(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_restart()` on a `ServiceCommand::GitCheckout` value",
                                ),
                            );
                    }
                    ServiceCommand::GitStatus(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_restart()` on a `ServiceCommand::GitStatus` value",
                                ),
                            );
                    }
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Unwraps this reference to the `ServiceCommand::Restart` variant.
        */
        ///Panics if this value is of any other type.
        pub fn unwrap_restart_ref(&self) -> (&RestartServiceCommand) {
            match self {
                ServiceCommand::Restart(field_0) => (field_0),
                val @ _ => match val {
                    ServiceCommand::Start(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_restart_ref()` on a `ServiceCommand::Start` value",
                                ),
                            );
                    }
                    ServiceCommand::Stop(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_restart_ref()` on a `ServiceCommand::Stop` value",
                                ),
                            );
                    }
                    ServiceCommand::Restart(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_restart_ref()` on a `ServiceCommand::Restart` value",
                                ),
                            );
                    }
                    ServiceCommand::List(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_restart_ref()` on a `ServiceCommand::List` value",
                                ),
                            );
                    }
                    ServiceCommand::Status(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_restart_ref()` on a `ServiceCommand::Status` value",
                                ),
                            );
                    }
                    ServiceCommand::Add(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_restart_ref()` on a `ServiceCommand::Add` value",
                                ),
                            );
                    }
                    ServiceCommand::Remove(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_restart_ref()` on a `ServiceCommand::Remove` value",
                                ),
                            );
                    }
                    ServiceCommand::ConfigGet(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_restart_ref()` on a `ServiceCommand::ConfigGet` value",
                                ),
                            );
                    }
                    ServiceCommand::ConfigUpdate(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_restart_ref()` on a `ServiceCommand::ConfigUpdate` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyAdd(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_restart_ref()` on a `ServiceCommand::DependencyAdd` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyRemove(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_restart_ref()` on a `ServiceCommand::DependencyRemove` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyList(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_restart_ref()` on a `ServiceCommand::DependencyList` value",
                                ),
                            );
                    }
                    ServiceCommand::GitCheckout(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_restart_ref()` on a `ServiceCommand::GitCheckout` value",
                                ),
                            );
                    }
                    ServiceCommand::GitStatus(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_restart_ref()` on a `ServiceCommand::GitStatus` value",
                                ),
                            );
                    }
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Unwraps this mutable reference to the `ServiceCommand::Restart` variant.
        */
        ///Panics if this value is of any other type.
        pub fn unwrap_restart_mut(&mut self) -> (&mut RestartServiceCommand) {
            match self {
                ServiceCommand::Restart(field_0) => (field_0),
                val @ _ => match val {
                    ServiceCommand::Start(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_restart_mut()` on a `ServiceCommand::Start` value",
                                ),
                            );
                    }
                    ServiceCommand::Stop(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_restart_mut()` on a `ServiceCommand::Stop` value",
                                ),
                            );
                    }
                    ServiceCommand::Restart(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_restart_mut()` on a `ServiceCommand::Restart` value",
                                ),
                            );
                    }
                    ServiceCommand::List(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_restart_mut()` on a `ServiceCommand::List` value",
                                ),
                            );
                    }
                    ServiceCommand::Status(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_restart_mut()` on a `ServiceCommand::Status` value",
                                ),
                            );
                    }
                    ServiceCommand::Add(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_restart_mut()` on a `ServiceCommand::Add` value",
                                ),
                            );
                    }
                    ServiceCommand::Remove(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_restart_mut()` on a `ServiceCommand::Remove` value",
                                ),
                            );
                    }
                    ServiceCommand::ConfigGet(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_restart_mut()` on a `ServiceCommand::ConfigGet` value",
                                ),
                            );
                    }
                    ServiceCommand::ConfigUpdate(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_restart_mut()` on a `ServiceCommand::ConfigUpdate` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyAdd(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_restart_mut()` on a `ServiceCommand::DependencyAdd` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyRemove(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_restart_mut()` on a `ServiceCommand::DependencyRemove` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyList(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_restart_mut()` on a `ServiceCommand::DependencyList` value",
                                ),
                            );
                    }
                    ServiceCommand::GitCheckout(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_restart_mut()` on a `ServiceCommand::GitCheckout` value",
                                ),
                            );
                    }
                    ServiceCommand::GitStatus(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_restart_mut()` on a `ServiceCommand::GitStatus` value",
                                ),
                            );
                    }
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Unwraps this value to the `ServiceCommand::List` variant.
        */
        ///Panics if this value is of any other type.
        pub fn unwrap_list(self) -> (ListServicesCommand) {
            match self {
                ServiceCommand::List(field_0) => (field_0),
                val @ _ => match val {
                    ServiceCommand::Start(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_list()` on a `ServiceCommand::Start` value",
                                ),
                            );
                    }
                    ServiceCommand::Stop(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_list()` on a `ServiceCommand::Stop` value",
                                ),
                            );
                    }
                    ServiceCommand::Restart(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_list()` on a `ServiceCommand::Restart` value",
                                ),
                            );
                    }
                    ServiceCommand::List(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_list()` on a `ServiceCommand::List` value",
                                ),
                            );
                    }
                    ServiceCommand::Status(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_list()` on a `ServiceCommand::Status` value",
                                ),
                            );
                    }
                    ServiceCommand::Add(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_list()` on a `ServiceCommand::Add` value",
                                ),
                            );
                    }
                    ServiceCommand::Remove(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_list()` on a `ServiceCommand::Remove` value",
                                ),
                            );
                    }
                    ServiceCommand::ConfigGet(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_list()` on a `ServiceCommand::ConfigGet` value",
                                ),
                            );
                    }
                    ServiceCommand::ConfigUpdate(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_list()` on a `ServiceCommand::ConfigUpdate` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyAdd(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_list()` on a `ServiceCommand::DependencyAdd` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyRemove(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_list()` on a `ServiceCommand::DependencyRemove` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyList(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_list()` on a `ServiceCommand::DependencyList` value",
                                ),
                            );
                    }
                    ServiceCommand::GitCheckout(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_list()` on a `ServiceCommand::GitCheckout` value",
                                ),
                            );
                    }
                    ServiceCommand::GitStatus(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_list()` on a `ServiceCommand::GitStatus` value",
                                ),
                            );
                    }
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Unwraps this reference to the `ServiceCommand::List` variant.
        */
        ///Panics if this value is of any other type.
        pub fn unwrap_list_ref(&self) -> (&ListServicesCommand) {
            match self {
                ServiceCommand::List(field_0) => (field_0),
                val @ _ => match val {
                    ServiceCommand::Start(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_list_ref()` on a `ServiceCommand::Start` value",
                                ),
                            );
                    }
                    ServiceCommand::Stop(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_list_ref()` on a `ServiceCommand::Stop` value",
                                ),
                            );
                    }
                    ServiceCommand::Restart(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_list_ref()` on a `ServiceCommand::Restart` value",
                                ),
                            );
                    }
                    ServiceCommand::List(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_list_ref()` on a `ServiceCommand::List` value",
                                ),
                            );
                    }
                    ServiceCommand::Status(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_list_ref()` on a `ServiceCommand::Status` value",
                                ),
                            );
                    }
                    ServiceCommand::Add(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_list_ref()` on a `ServiceCommand::Add` value",
                                ),
                            );
                    }
                    ServiceCommand::Remove(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_list_ref()` on a `ServiceCommand::Remove` value",
                                ),
                            );
                    }
                    ServiceCommand::ConfigGet(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_list_ref()` on a `ServiceCommand::ConfigGet` value",
                                ),
                            );
                    }
                    ServiceCommand::ConfigUpdate(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_list_ref()` on a `ServiceCommand::ConfigUpdate` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyAdd(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_list_ref()` on a `ServiceCommand::DependencyAdd` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyRemove(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_list_ref()` on a `ServiceCommand::DependencyRemove` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyList(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_list_ref()` on a `ServiceCommand::DependencyList` value",
                                ),
                            );
                    }
                    ServiceCommand::GitCheckout(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_list_ref()` on a `ServiceCommand::GitCheckout` value",
                                ),
                            );
                    }
                    ServiceCommand::GitStatus(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_list_ref()` on a `ServiceCommand::GitStatus` value",
                                ),
                            );
                    }
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Unwraps this mutable reference to the `ServiceCommand::List` variant.
        */
        ///Panics if this value is of any other type.
        pub fn unwrap_list_mut(&mut self) -> (&mut ListServicesCommand) {
            match self {
                ServiceCommand::List(field_0) => (field_0),
                val @ _ => match val {
                    ServiceCommand::Start(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_list_mut()` on a `ServiceCommand::Start` value",
                                ),
                            );
                    }
                    ServiceCommand::Stop(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_list_mut()` on a `ServiceCommand::Stop` value",
                                ),
                            );
                    }
                    ServiceCommand::Restart(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_list_mut()` on a `ServiceCommand::Restart` value",
                                ),
                            );
                    }
                    ServiceCommand::List(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_list_mut()` on a `ServiceCommand::List` value",
                                ),
                            );
                    }
                    ServiceCommand::Status(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_list_mut()` on a `ServiceCommand::Status` value",
                                ),
                            );
                    }
                    ServiceCommand::Add(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_list_mut()` on a `ServiceCommand::Add` value",
                                ),
                            );
                    }
                    ServiceCommand::Remove(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_list_mut()` on a `ServiceCommand::Remove` value",
                                ),
                            );
                    }
                    ServiceCommand::ConfigGet(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_list_mut()` on a `ServiceCommand::ConfigGet` value",
                                ),
                            );
                    }
                    ServiceCommand::ConfigUpdate(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_list_mut()` on a `ServiceCommand::ConfigUpdate` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyAdd(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_list_mut()` on a `ServiceCommand::DependencyAdd` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyRemove(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_list_mut()` on a `ServiceCommand::DependencyRemove` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyList(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_list_mut()` on a `ServiceCommand::DependencyList` value",
                                ),
                            );
                    }
                    ServiceCommand::GitCheckout(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_list_mut()` on a `ServiceCommand::GitCheckout` value",
                                ),
                            );
                    }
                    ServiceCommand::GitStatus(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_list_mut()` on a `ServiceCommand::GitStatus` value",
                                ),
                            );
                    }
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Unwraps this value to the `ServiceCommand::Status` variant.
        */
        ///Panics if this value is of any other type.
        pub fn unwrap_status(self) -> (GetServiceStatus) {
            match self {
                ServiceCommand::Status(field_0) => (field_0),
                val @ _ => match val {
                    ServiceCommand::Start(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_status()` on a `ServiceCommand::Start` value",
                                ),
                            );
                    }
                    ServiceCommand::Stop(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_status()` on a `ServiceCommand::Stop` value",
                                ),
                            );
                    }
                    ServiceCommand::Restart(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_status()` on a `ServiceCommand::Restart` value",
                                ),
                            );
                    }
                    ServiceCommand::List(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_status()` on a `ServiceCommand::List` value",
                                ),
                            );
                    }
                    ServiceCommand::Status(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_status()` on a `ServiceCommand::Status` value",
                                ),
                            );
                    }
                    ServiceCommand::Add(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_status()` on a `ServiceCommand::Add` value",
                                ),
                            );
                    }
                    ServiceCommand::Remove(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_status()` on a `ServiceCommand::Remove` value",
                                ),
                            );
                    }
                    ServiceCommand::ConfigGet(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_status()` on a `ServiceCommand::ConfigGet` value",
                                ),
                            );
                    }
                    ServiceCommand::ConfigUpdate(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_status()` on a `ServiceCommand::ConfigUpdate` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyAdd(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_status()` on a `ServiceCommand::DependencyAdd` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyRemove(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_status()` on a `ServiceCommand::DependencyRemove` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyList(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_status()` on a `ServiceCommand::DependencyList` value",
                                ),
                            );
                    }
                    ServiceCommand::GitCheckout(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_status()` on a `ServiceCommand::GitCheckout` value",
                                ),
                            );
                    }
                    ServiceCommand::GitStatus(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_status()` on a `ServiceCommand::GitStatus` value",
                                ),
                            );
                    }
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Unwraps this reference to the `ServiceCommand::Status` variant.
        */
        ///Panics if this value is of any other type.
        pub fn unwrap_status_ref(&self) -> (&GetServiceStatus) {
            match self {
                ServiceCommand::Status(field_0) => (field_0),
                val @ _ => match val {
                    ServiceCommand::Start(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_status_ref()` on a `ServiceCommand::Start` value",
                                ),
                            );
                    }
                    ServiceCommand::Stop(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_status_ref()` on a `ServiceCommand::Stop` value",
                                ),
                            );
                    }
                    ServiceCommand::Restart(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_status_ref()` on a `ServiceCommand::Restart` value",
                                ),
                            );
                    }
                    ServiceCommand::List(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_status_ref()` on a `ServiceCommand::List` value",
                                ),
                            );
                    }
                    ServiceCommand::Status(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_status_ref()` on a `ServiceCommand::Status` value",
                                ),
                            );
                    }
                    ServiceCommand::Add(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_status_ref()` on a `ServiceCommand::Add` value",
                                ),
                            );
                    }
                    ServiceCommand::Remove(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_status_ref()` on a `ServiceCommand::Remove` value",
                                ),
                            );
                    }
                    ServiceCommand::ConfigGet(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_status_ref()` on a `ServiceCommand::ConfigGet` value",
                                ),
                            );
                    }
                    ServiceCommand::ConfigUpdate(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_status_ref()` on a `ServiceCommand::ConfigUpdate` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyAdd(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_status_ref()` on a `ServiceCommand::DependencyAdd` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyRemove(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_status_ref()` on a `ServiceCommand::DependencyRemove` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyList(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_status_ref()` on a `ServiceCommand::DependencyList` value",
                                ),
                            );
                    }
                    ServiceCommand::GitCheckout(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_status_ref()` on a `ServiceCommand::GitCheckout` value",
                                ),
                            );
                    }
                    ServiceCommand::GitStatus(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_status_ref()` on a `ServiceCommand::GitStatus` value",
                                ),
                            );
                    }
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Unwraps this mutable reference to the `ServiceCommand::Status` variant.
        */
        ///Panics if this value is of any other type.
        pub fn unwrap_status_mut(&mut self) -> (&mut GetServiceStatus) {
            match self {
                ServiceCommand::Status(field_0) => (field_0),
                val @ _ => match val {
                    ServiceCommand::Start(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_status_mut()` on a `ServiceCommand::Start` value",
                                ),
                            );
                    }
                    ServiceCommand::Stop(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_status_mut()` on a `ServiceCommand::Stop` value",
                                ),
                            );
                    }
                    ServiceCommand::Restart(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_status_mut()` on a `ServiceCommand::Restart` value",
                                ),
                            );
                    }
                    ServiceCommand::List(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_status_mut()` on a `ServiceCommand::List` value",
                                ),
                            );
                    }
                    ServiceCommand::Status(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_status_mut()` on a `ServiceCommand::Status` value",
                                ),
                            );
                    }
                    ServiceCommand::Add(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_status_mut()` on a `ServiceCommand::Add` value",
                                ),
                            );
                    }
                    ServiceCommand::Remove(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_status_mut()` on a `ServiceCommand::Remove` value",
                                ),
                            );
                    }
                    ServiceCommand::ConfigGet(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_status_mut()` on a `ServiceCommand::ConfigGet` value",
                                ),
                            );
                    }
                    ServiceCommand::ConfigUpdate(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_status_mut()` on a `ServiceCommand::ConfigUpdate` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyAdd(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_status_mut()` on a `ServiceCommand::DependencyAdd` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyRemove(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_status_mut()` on a `ServiceCommand::DependencyRemove` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyList(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_status_mut()` on a `ServiceCommand::DependencyList` value",
                                ),
                            );
                    }
                    ServiceCommand::GitCheckout(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_status_mut()` on a `ServiceCommand::GitCheckout` value",
                                ),
                            );
                    }
                    ServiceCommand::GitStatus(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_status_mut()` on a `ServiceCommand::GitStatus` value",
                                ),
                            );
                    }
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Unwraps this value to the `ServiceCommand::Add` variant.
        */
        ///Panics if this value is of any other type.
        pub fn unwrap_add(self) -> (AddServiceCommand) {
            match self {
                ServiceCommand::Add(field_0) => (field_0),
                val @ _ => match val {
                    ServiceCommand::Start(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_add()` on a `ServiceCommand::Start` value",
                                ),
                            );
                    }
                    ServiceCommand::Stop(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_add()` on a `ServiceCommand::Stop` value",
                                ),
                            );
                    }
                    ServiceCommand::Restart(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_add()` on a `ServiceCommand::Restart` value",
                                ),
                            );
                    }
                    ServiceCommand::List(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_add()` on a `ServiceCommand::List` value",
                                ),
                            );
                    }
                    ServiceCommand::Status(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_add()` on a `ServiceCommand::Status` value",
                                ),
                            );
                    }
                    ServiceCommand::Add(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_add()` on a `ServiceCommand::Add` value",
                                ),
                            );
                    }
                    ServiceCommand::Remove(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_add()` on a `ServiceCommand::Remove` value",
                                ),
                            );
                    }
                    ServiceCommand::ConfigGet(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_add()` on a `ServiceCommand::ConfigGet` value",
                                ),
                            );
                    }
                    ServiceCommand::ConfigUpdate(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_add()` on a `ServiceCommand::ConfigUpdate` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyAdd(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_add()` on a `ServiceCommand::DependencyAdd` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyRemove(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_add()` on a `ServiceCommand::DependencyRemove` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyList(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_add()` on a `ServiceCommand::DependencyList` value",
                                ),
                            );
                    }
                    ServiceCommand::GitCheckout(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_add()` on a `ServiceCommand::GitCheckout` value",
                                ),
                            );
                    }
                    ServiceCommand::GitStatus(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_add()` on a `ServiceCommand::GitStatus` value",
                                ),
                            );
                    }
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Unwraps this reference to the `ServiceCommand::Add` variant.
        */
        ///Panics if this value is of any other type.
        pub fn unwrap_add_ref(&self) -> (&AddServiceCommand) {
            match self {
                ServiceCommand::Add(field_0) => (field_0),
                val @ _ => match val {
                    ServiceCommand::Start(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_add_ref()` on a `ServiceCommand::Start` value",
                                ),
                            );
                    }
                    ServiceCommand::Stop(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_add_ref()` on a `ServiceCommand::Stop` value",
                                ),
                            );
                    }
                    ServiceCommand::Restart(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_add_ref()` on a `ServiceCommand::Restart` value",
                                ),
                            );
                    }
                    ServiceCommand::List(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_add_ref()` on a `ServiceCommand::List` value",
                                ),
                            );
                    }
                    ServiceCommand::Status(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_add_ref()` on a `ServiceCommand::Status` value",
                                ),
                            );
                    }
                    ServiceCommand::Add(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_add_ref()` on a `ServiceCommand::Add` value",
                                ),
                            );
                    }
                    ServiceCommand::Remove(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_add_ref()` on a `ServiceCommand::Remove` value",
                                ),
                            );
                    }
                    ServiceCommand::ConfigGet(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_add_ref()` on a `ServiceCommand::ConfigGet` value",
                                ),
                            );
                    }
                    ServiceCommand::ConfigUpdate(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_add_ref()` on a `ServiceCommand::ConfigUpdate` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyAdd(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_add_ref()` on a `ServiceCommand::DependencyAdd` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyRemove(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_add_ref()` on a `ServiceCommand::DependencyRemove` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyList(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_add_ref()` on a `ServiceCommand::DependencyList` value",
                                ),
                            );
                    }
                    ServiceCommand::GitCheckout(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_add_ref()` on a `ServiceCommand::GitCheckout` value",
                                ),
                            );
                    }
                    ServiceCommand::GitStatus(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_add_ref()` on a `ServiceCommand::GitStatus` value",
                                ),
                            );
                    }
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Unwraps this mutable reference to the `ServiceCommand::Add` variant.
        */
        ///Panics if this value is of any other type.
        pub fn unwrap_add_mut(&mut self) -> (&mut AddServiceCommand) {
            match self {
                ServiceCommand::Add(field_0) => (field_0),
                val @ _ => match val {
                    ServiceCommand::Start(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_add_mut()` on a `ServiceCommand::Start` value",
                                ),
                            );
                    }
                    ServiceCommand::Stop(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_add_mut()` on a `ServiceCommand::Stop` value",
                                ),
                            );
                    }
                    ServiceCommand::Restart(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_add_mut()` on a `ServiceCommand::Restart` value",
                                ),
                            );
                    }
                    ServiceCommand::List(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_add_mut()` on a `ServiceCommand::List` value",
                                ),
                            );
                    }
                    ServiceCommand::Status(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_add_mut()` on a `ServiceCommand::Status` value",
                                ),
                            );
                    }
                    ServiceCommand::Add(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_add_mut()` on a `ServiceCommand::Add` value",
                                ),
                            );
                    }
                    ServiceCommand::Remove(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_add_mut()` on a `ServiceCommand::Remove` value",
                                ),
                            );
                    }
                    ServiceCommand::ConfigGet(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_add_mut()` on a `ServiceCommand::ConfigGet` value",
                                ),
                            );
                    }
                    ServiceCommand::ConfigUpdate(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_add_mut()` on a `ServiceCommand::ConfigUpdate` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyAdd(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_add_mut()` on a `ServiceCommand::DependencyAdd` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyRemove(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_add_mut()` on a `ServiceCommand::DependencyRemove` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyList(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_add_mut()` on a `ServiceCommand::DependencyList` value",
                                ),
                            );
                    }
                    ServiceCommand::GitCheckout(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_add_mut()` on a `ServiceCommand::GitCheckout` value",
                                ),
                            );
                    }
                    ServiceCommand::GitStatus(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_add_mut()` on a `ServiceCommand::GitStatus` value",
                                ),
                            );
                    }
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Unwraps this value to the `ServiceCommand::Remove` variant.
        */
        ///Panics if this value is of any other type.
        pub fn unwrap_remove(self) -> (RemoveServiceCommand) {
            match self {
                ServiceCommand::Remove(field_0) => (field_0),
                val @ _ => match val {
                    ServiceCommand::Start(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_remove()` on a `ServiceCommand::Start` value",
                                ),
                            );
                    }
                    ServiceCommand::Stop(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_remove()` on a `ServiceCommand::Stop` value",
                                ),
                            );
                    }
                    ServiceCommand::Restart(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_remove()` on a `ServiceCommand::Restart` value",
                                ),
                            );
                    }
                    ServiceCommand::List(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_remove()` on a `ServiceCommand::List` value",
                                ),
                            );
                    }
                    ServiceCommand::Status(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_remove()` on a `ServiceCommand::Status` value",
                                ),
                            );
                    }
                    ServiceCommand::Add(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_remove()` on a `ServiceCommand::Add` value",
                                ),
                            );
                    }
                    ServiceCommand::Remove(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_remove()` on a `ServiceCommand::Remove` value",
                                ),
                            );
                    }
                    ServiceCommand::ConfigGet(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_remove()` on a `ServiceCommand::ConfigGet` value",
                                ),
                            );
                    }
                    ServiceCommand::ConfigUpdate(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_remove()` on a `ServiceCommand::ConfigUpdate` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyAdd(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_remove()` on a `ServiceCommand::DependencyAdd` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyRemove(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_remove()` on a `ServiceCommand::DependencyRemove` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyList(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_remove()` on a `ServiceCommand::DependencyList` value",
                                ),
                            );
                    }
                    ServiceCommand::GitCheckout(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_remove()` on a `ServiceCommand::GitCheckout` value",
                                ),
                            );
                    }
                    ServiceCommand::GitStatus(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_remove()` on a `ServiceCommand::GitStatus` value",
                                ),
                            );
                    }
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Unwraps this reference to the `ServiceCommand::Remove` variant.
        */
        ///Panics if this value is of any other type.
        pub fn unwrap_remove_ref(&self) -> (&RemoveServiceCommand) {
            match self {
                ServiceCommand::Remove(field_0) => (field_0),
                val @ _ => match val {
                    ServiceCommand::Start(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_remove_ref()` on a `ServiceCommand::Start` value",
                                ),
                            );
                    }
                    ServiceCommand::Stop(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_remove_ref()` on a `ServiceCommand::Stop` value",
                                ),
                            );
                    }
                    ServiceCommand::Restart(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_remove_ref()` on a `ServiceCommand::Restart` value",
                                ),
                            );
                    }
                    ServiceCommand::List(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_remove_ref()` on a `ServiceCommand::List` value",
                                ),
                            );
                    }
                    ServiceCommand::Status(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_remove_ref()` on a `ServiceCommand::Status` value",
                                ),
                            );
                    }
                    ServiceCommand::Add(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_remove_ref()` on a `ServiceCommand::Add` value",
                                ),
                            );
                    }
                    ServiceCommand::Remove(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_remove_ref()` on a `ServiceCommand::Remove` value",
                                ),
                            );
                    }
                    ServiceCommand::ConfigGet(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_remove_ref()` on a `ServiceCommand::ConfigGet` value",
                                ),
                            );
                    }
                    ServiceCommand::ConfigUpdate(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_remove_ref()` on a `ServiceCommand::ConfigUpdate` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyAdd(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_remove_ref()` on a `ServiceCommand::DependencyAdd` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyRemove(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_remove_ref()` on a `ServiceCommand::DependencyRemove` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyList(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_remove_ref()` on a `ServiceCommand::DependencyList` value",
                                ),
                            );
                    }
                    ServiceCommand::GitCheckout(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_remove_ref()` on a `ServiceCommand::GitCheckout` value",
                                ),
                            );
                    }
                    ServiceCommand::GitStatus(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_remove_ref()` on a `ServiceCommand::GitStatus` value",
                                ),
                            );
                    }
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Unwraps this mutable reference to the `ServiceCommand::Remove` variant.
        */
        ///Panics if this value is of any other type.
        pub fn unwrap_remove_mut(&mut self) -> (&mut RemoveServiceCommand) {
            match self {
                ServiceCommand::Remove(field_0) => (field_0),
                val @ _ => match val {
                    ServiceCommand::Start(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_remove_mut()` on a `ServiceCommand::Start` value",
                                ),
                            );
                    }
                    ServiceCommand::Stop(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_remove_mut()` on a `ServiceCommand::Stop` value",
                                ),
                            );
                    }
                    ServiceCommand::Restart(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_remove_mut()` on a `ServiceCommand::Restart` value",
                                ),
                            );
                    }
                    ServiceCommand::List(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_remove_mut()` on a `ServiceCommand::List` value",
                                ),
                            );
                    }
                    ServiceCommand::Status(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_remove_mut()` on a `ServiceCommand::Status` value",
                                ),
                            );
                    }
                    ServiceCommand::Add(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_remove_mut()` on a `ServiceCommand::Add` value",
                                ),
                            );
                    }
                    ServiceCommand::Remove(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_remove_mut()` on a `ServiceCommand::Remove` value",
                                ),
                            );
                    }
                    ServiceCommand::ConfigGet(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_remove_mut()` on a `ServiceCommand::ConfigGet` value",
                                ),
                            );
                    }
                    ServiceCommand::ConfigUpdate(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_remove_mut()` on a `ServiceCommand::ConfigUpdate` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyAdd(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_remove_mut()` on a `ServiceCommand::DependencyAdd` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyRemove(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_remove_mut()` on a `ServiceCommand::DependencyRemove` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyList(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_remove_mut()` on a `ServiceCommand::DependencyList` value",
                                ),
                            );
                    }
                    ServiceCommand::GitCheckout(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_remove_mut()` on a `ServiceCommand::GitCheckout` value",
                                ),
                            );
                    }
                    ServiceCommand::GitStatus(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_remove_mut()` on a `ServiceCommand::GitStatus` value",
                                ),
                            );
                    }
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Unwraps this value to the `ServiceCommand::ConfigGet` variant.
        */
        ///Panics if this value is of any other type.
        pub fn unwrap_config_get(self) -> (GetConfig) {
            match self {
                ServiceCommand::ConfigGet(field_0) => (field_0),
                val @ _ => match val {
                    ServiceCommand::Start(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_config_get()` on a `ServiceCommand::Start` value",
                                ),
                            );
                    }
                    ServiceCommand::Stop(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_config_get()` on a `ServiceCommand::Stop` value",
                                ),
                            );
                    }
                    ServiceCommand::Restart(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_config_get()` on a `ServiceCommand::Restart` value",
                                ),
                            );
                    }
                    ServiceCommand::List(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_config_get()` on a `ServiceCommand::List` value",
                                ),
                            );
                    }
                    ServiceCommand::Status(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_config_get()` on a `ServiceCommand::Status` value",
                                ),
                            );
                    }
                    ServiceCommand::Add(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_config_get()` on a `ServiceCommand::Add` value",
                                ),
                            );
                    }
                    ServiceCommand::Remove(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_config_get()` on a `ServiceCommand::Remove` value",
                                ),
                            );
                    }
                    ServiceCommand::ConfigGet(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_config_get()` on a `ServiceCommand::ConfigGet` value",
                                ),
                            );
                    }
                    ServiceCommand::ConfigUpdate(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_config_get()` on a `ServiceCommand::ConfigUpdate` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyAdd(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_config_get()` on a `ServiceCommand::DependencyAdd` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyRemove(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_config_get()` on a `ServiceCommand::DependencyRemove` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyList(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_config_get()` on a `ServiceCommand::DependencyList` value",
                                ),
                            );
                    }
                    ServiceCommand::GitCheckout(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_config_get()` on a `ServiceCommand::GitCheckout` value",
                                ),
                            );
                    }
                    ServiceCommand::GitStatus(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_config_get()` on a `ServiceCommand::GitStatus` value",
                                ),
                            );
                    }
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Unwraps this reference to the `ServiceCommand::ConfigGet` variant.
        */
        ///Panics if this value is of any other type.
        pub fn unwrap_config_get_ref(&self) -> (&GetConfig) {
            match self {
                ServiceCommand::ConfigGet(field_0) => (field_0),
                val @ _ => match val {
                    ServiceCommand::Start(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_config_get_ref()` on a `ServiceCommand::Start` value",
                                ),
                            );
                    }
                    ServiceCommand::Stop(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_config_get_ref()` on a `ServiceCommand::Stop` value",
                                ),
                            );
                    }
                    ServiceCommand::Restart(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_config_get_ref()` on a `ServiceCommand::Restart` value",
                                ),
                            );
                    }
                    ServiceCommand::List(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_config_get_ref()` on a `ServiceCommand::List` value",
                                ),
                            );
                    }
                    ServiceCommand::Status(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_config_get_ref()` on a `ServiceCommand::Status` value",
                                ),
                            );
                    }
                    ServiceCommand::Add(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_config_get_ref()` on a `ServiceCommand::Add` value",
                                ),
                            );
                    }
                    ServiceCommand::Remove(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_config_get_ref()` on a `ServiceCommand::Remove` value",
                                ),
                            );
                    }
                    ServiceCommand::ConfigGet(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_config_get_ref()` on a `ServiceCommand::ConfigGet` value",
                                ),
                            );
                    }
                    ServiceCommand::ConfigUpdate(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_config_get_ref()` on a `ServiceCommand::ConfigUpdate` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyAdd(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_config_get_ref()` on a `ServiceCommand::DependencyAdd` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyRemove(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_config_get_ref()` on a `ServiceCommand::DependencyRemove` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyList(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_config_get_ref()` on a `ServiceCommand::DependencyList` value",
                                ),
                            );
                    }
                    ServiceCommand::GitCheckout(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_config_get_ref()` on a `ServiceCommand::GitCheckout` value",
                                ),
                            );
                    }
                    ServiceCommand::GitStatus(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_config_get_ref()` on a `ServiceCommand::GitStatus` value",
                                ),
                            );
                    }
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Unwraps this mutable reference to the `ServiceCommand::ConfigGet` variant.
        */
        ///Panics if this value is of any other type.
        pub fn unwrap_config_get_mut(&mut self) -> (&mut GetConfig) {
            match self {
                ServiceCommand::ConfigGet(field_0) => (field_0),
                val @ _ => match val {
                    ServiceCommand::Start(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_config_get_mut()` on a `ServiceCommand::Start` value",
                                ),
                            );
                    }
                    ServiceCommand::Stop(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_config_get_mut()` on a `ServiceCommand::Stop` value",
                                ),
                            );
                    }
                    ServiceCommand::Restart(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_config_get_mut()` on a `ServiceCommand::Restart` value",
                                ),
                            );
                    }
                    ServiceCommand::List(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_config_get_mut()` on a `ServiceCommand::List` value",
                                ),
                            );
                    }
                    ServiceCommand::Status(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_config_get_mut()` on a `ServiceCommand::Status` value",
                                ),
                            );
                    }
                    ServiceCommand::Add(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_config_get_mut()` on a `ServiceCommand::Add` value",
                                ),
                            );
                    }
                    ServiceCommand::Remove(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_config_get_mut()` on a `ServiceCommand::Remove` value",
                                ),
                            );
                    }
                    ServiceCommand::ConfigGet(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_config_get_mut()` on a `ServiceCommand::ConfigGet` value",
                                ),
                            );
                    }
                    ServiceCommand::ConfigUpdate(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_config_get_mut()` on a `ServiceCommand::ConfigUpdate` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyAdd(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_config_get_mut()` on a `ServiceCommand::DependencyAdd` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyRemove(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_config_get_mut()` on a `ServiceCommand::DependencyRemove` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyList(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_config_get_mut()` on a `ServiceCommand::DependencyList` value",
                                ),
                            );
                    }
                    ServiceCommand::GitCheckout(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_config_get_mut()` on a `ServiceCommand::GitCheckout` value",
                                ),
                            );
                    }
                    ServiceCommand::GitStatus(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_config_get_mut()` on a `ServiceCommand::GitStatus` value",
                                ),
                            );
                    }
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Unwraps this value to the `ServiceCommand::ConfigUpdate` variant.
        */
        ///Panics if this value is of any other type.
        pub fn unwrap_config_update(self) -> (UpdateConfigCommand) {
            match self {
                ServiceCommand::ConfigUpdate(field_0) => (field_0),
                val @ _ => match val {
                    ServiceCommand::Start(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_config_update()` on a `ServiceCommand::Start` value",
                                ),
                            );
                    }
                    ServiceCommand::Stop(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_config_update()` on a `ServiceCommand::Stop` value",
                                ),
                            );
                    }
                    ServiceCommand::Restart(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_config_update()` on a `ServiceCommand::Restart` value",
                                ),
                            );
                    }
                    ServiceCommand::List(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_config_update()` on a `ServiceCommand::List` value",
                                ),
                            );
                    }
                    ServiceCommand::Status(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_config_update()` on a `ServiceCommand::Status` value",
                                ),
                            );
                    }
                    ServiceCommand::Add(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_config_update()` on a `ServiceCommand::Add` value",
                                ),
                            );
                    }
                    ServiceCommand::Remove(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_config_update()` on a `ServiceCommand::Remove` value",
                                ),
                            );
                    }
                    ServiceCommand::ConfigGet(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_config_update()` on a `ServiceCommand::ConfigGet` value",
                                ),
                            );
                    }
                    ServiceCommand::ConfigUpdate(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_config_update()` on a `ServiceCommand::ConfigUpdate` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyAdd(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_config_update()` on a `ServiceCommand::DependencyAdd` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyRemove(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_config_update()` on a `ServiceCommand::DependencyRemove` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyList(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_config_update()` on a `ServiceCommand::DependencyList` value",
                                ),
                            );
                    }
                    ServiceCommand::GitCheckout(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_config_update()` on a `ServiceCommand::GitCheckout` value",
                                ),
                            );
                    }
                    ServiceCommand::GitStatus(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_config_update()` on a `ServiceCommand::GitStatus` value",
                                ),
                            );
                    }
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Unwraps this reference to the `ServiceCommand::ConfigUpdate` variant.
        */
        ///Panics if this value is of any other type.
        pub fn unwrap_config_update_ref(&self) -> (&UpdateConfigCommand) {
            match self {
                ServiceCommand::ConfigUpdate(field_0) => (field_0),
                val @ _ => match val {
                    ServiceCommand::Start(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_config_update_ref()` on a `ServiceCommand::Start` value",
                                ),
                            );
                    }
                    ServiceCommand::Stop(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_config_update_ref()` on a `ServiceCommand::Stop` value",
                                ),
                            );
                    }
                    ServiceCommand::Restart(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_config_update_ref()` on a `ServiceCommand::Restart` value",
                                ),
                            );
                    }
                    ServiceCommand::List(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_config_update_ref()` on a `ServiceCommand::List` value",
                                ),
                            );
                    }
                    ServiceCommand::Status(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_config_update_ref()` on a `ServiceCommand::Status` value",
                                ),
                            );
                    }
                    ServiceCommand::Add(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_config_update_ref()` on a `ServiceCommand::Add` value",
                                ),
                            );
                    }
                    ServiceCommand::Remove(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_config_update_ref()` on a `ServiceCommand::Remove` value",
                                ),
                            );
                    }
                    ServiceCommand::ConfigGet(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_config_update_ref()` on a `ServiceCommand::ConfigGet` value",
                                ),
                            );
                    }
                    ServiceCommand::ConfigUpdate(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_config_update_ref()` on a `ServiceCommand::ConfigUpdate` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyAdd(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_config_update_ref()` on a `ServiceCommand::DependencyAdd` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyRemove(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_config_update_ref()` on a `ServiceCommand::DependencyRemove` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyList(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_config_update_ref()` on a `ServiceCommand::DependencyList` value",
                                ),
                            );
                    }
                    ServiceCommand::GitCheckout(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_config_update_ref()` on a `ServiceCommand::GitCheckout` value",
                                ),
                            );
                    }
                    ServiceCommand::GitStatus(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_config_update_ref()` on a `ServiceCommand::GitStatus` value",
                                ),
                            );
                    }
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Unwraps this mutable reference to the `ServiceCommand::ConfigUpdate` variant.
        */
        ///Panics if this value is of any other type.
        pub fn unwrap_config_update_mut(&mut self) -> (&mut UpdateConfigCommand) {
            match self {
                ServiceCommand::ConfigUpdate(field_0) => (field_0),
                val @ _ => match val {
                    ServiceCommand::Start(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_config_update_mut()` on a `ServiceCommand::Start` value",
                                ),
                            );
                    }
                    ServiceCommand::Stop(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_config_update_mut()` on a `ServiceCommand::Stop` value",
                                ),
                            );
                    }
                    ServiceCommand::Restart(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_config_update_mut()` on a `ServiceCommand::Restart` value",
                                ),
                            );
                    }
                    ServiceCommand::List(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_config_update_mut()` on a `ServiceCommand::List` value",
                                ),
                            );
                    }
                    ServiceCommand::Status(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_config_update_mut()` on a `ServiceCommand::Status` value",
                                ),
                            );
                    }
                    ServiceCommand::Add(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_config_update_mut()` on a `ServiceCommand::Add` value",
                                ),
                            );
                    }
                    ServiceCommand::Remove(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_config_update_mut()` on a `ServiceCommand::Remove` value",
                                ),
                            );
                    }
                    ServiceCommand::ConfigGet(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_config_update_mut()` on a `ServiceCommand::ConfigGet` value",
                                ),
                            );
                    }
                    ServiceCommand::ConfigUpdate(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_config_update_mut()` on a `ServiceCommand::ConfigUpdate` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyAdd(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_config_update_mut()` on a `ServiceCommand::DependencyAdd` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyRemove(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_config_update_mut()` on a `ServiceCommand::DependencyRemove` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyList(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_config_update_mut()` on a `ServiceCommand::DependencyList` value",
                                ),
                            );
                    }
                    ServiceCommand::GitCheckout(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_config_update_mut()` on a `ServiceCommand::GitCheckout` value",
                                ),
                            );
                    }
                    ServiceCommand::GitStatus(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_config_update_mut()` on a `ServiceCommand::GitStatus` value",
                                ),
                            );
                    }
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Unwraps this value to the `ServiceCommand::DependencyAdd` variant.
        */
        ///Panics if this value is of any other type.
        pub fn unwrap_dependency_add(self) -> (AddDependencyCommand) {
            match self {
                ServiceCommand::DependencyAdd(field_0) => (field_0),
                val @ _ => match val {
                    ServiceCommand::Start(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_add()` on a `ServiceCommand::Start` value",
                                ),
                            );
                    }
                    ServiceCommand::Stop(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_add()` on a `ServiceCommand::Stop` value",
                                ),
                            );
                    }
                    ServiceCommand::Restart(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_add()` on a `ServiceCommand::Restart` value",
                                ),
                            );
                    }
                    ServiceCommand::List(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_add()` on a `ServiceCommand::List` value",
                                ),
                            );
                    }
                    ServiceCommand::Status(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_add()` on a `ServiceCommand::Status` value",
                                ),
                            );
                    }
                    ServiceCommand::Add(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_add()` on a `ServiceCommand::Add` value",
                                ),
                            );
                    }
                    ServiceCommand::Remove(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_add()` on a `ServiceCommand::Remove` value",
                                ),
                            );
                    }
                    ServiceCommand::ConfigGet(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_add()` on a `ServiceCommand::ConfigGet` value",
                                ),
                            );
                    }
                    ServiceCommand::ConfigUpdate(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_add()` on a `ServiceCommand::ConfigUpdate` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyAdd(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_add()` on a `ServiceCommand::DependencyAdd` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyRemove(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_add()` on a `ServiceCommand::DependencyRemove` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyList(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_add()` on a `ServiceCommand::DependencyList` value",
                                ),
                            );
                    }
                    ServiceCommand::GitCheckout(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_add()` on a `ServiceCommand::GitCheckout` value",
                                ),
                            );
                    }
                    ServiceCommand::GitStatus(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_add()` on a `ServiceCommand::GitStatus` value",
                                ),
                            );
                    }
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Unwraps this reference to the `ServiceCommand::DependencyAdd` variant.
        */
        ///Panics if this value is of any other type.
        pub fn unwrap_dependency_add_ref(&self) -> (&AddDependencyCommand) {
            match self {
                ServiceCommand::DependencyAdd(field_0) => (field_0),
                val @ _ => match val {
                    ServiceCommand::Start(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_add_ref()` on a `ServiceCommand::Start` value",
                                ),
                            );
                    }
                    ServiceCommand::Stop(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_add_ref()` on a `ServiceCommand::Stop` value",
                                ),
                            );
                    }
                    ServiceCommand::Restart(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_add_ref()` on a `ServiceCommand::Restart` value",
                                ),
                            );
                    }
                    ServiceCommand::List(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_add_ref()` on a `ServiceCommand::List` value",
                                ),
                            );
                    }
                    ServiceCommand::Status(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_add_ref()` on a `ServiceCommand::Status` value",
                                ),
                            );
                    }
                    ServiceCommand::Add(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_add_ref()` on a `ServiceCommand::Add` value",
                                ),
                            );
                    }
                    ServiceCommand::Remove(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_add_ref()` on a `ServiceCommand::Remove` value",
                                ),
                            );
                    }
                    ServiceCommand::ConfigGet(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_add_ref()` on a `ServiceCommand::ConfigGet` value",
                                ),
                            );
                    }
                    ServiceCommand::ConfigUpdate(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_add_ref()` on a `ServiceCommand::ConfigUpdate` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyAdd(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_add_ref()` on a `ServiceCommand::DependencyAdd` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyRemove(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_add_ref()` on a `ServiceCommand::DependencyRemove` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyList(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_add_ref()` on a `ServiceCommand::DependencyList` value",
                                ),
                            );
                    }
                    ServiceCommand::GitCheckout(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_add_ref()` on a `ServiceCommand::GitCheckout` value",
                                ),
                            );
                    }
                    ServiceCommand::GitStatus(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_add_ref()` on a `ServiceCommand::GitStatus` value",
                                ),
                            );
                    }
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Unwraps this mutable reference to the `ServiceCommand::DependencyAdd` variant.
        */
        ///Panics if this value is of any other type.
        pub fn unwrap_dependency_add_mut(&mut self) -> (&mut AddDependencyCommand) {
            match self {
                ServiceCommand::DependencyAdd(field_0) => (field_0),
                val @ _ => match val {
                    ServiceCommand::Start(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_add_mut()` on a `ServiceCommand::Start` value",
                                ),
                            );
                    }
                    ServiceCommand::Stop(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_add_mut()` on a `ServiceCommand::Stop` value",
                                ),
                            );
                    }
                    ServiceCommand::Restart(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_add_mut()` on a `ServiceCommand::Restart` value",
                                ),
                            );
                    }
                    ServiceCommand::List(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_add_mut()` on a `ServiceCommand::List` value",
                                ),
                            );
                    }
                    ServiceCommand::Status(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_add_mut()` on a `ServiceCommand::Status` value",
                                ),
                            );
                    }
                    ServiceCommand::Add(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_add_mut()` on a `ServiceCommand::Add` value",
                                ),
                            );
                    }
                    ServiceCommand::Remove(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_add_mut()` on a `ServiceCommand::Remove` value",
                                ),
                            );
                    }
                    ServiceCommand::ConfigGet(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_add_mut()` on a `ServiceCommand::ConfigGet` value",
                                ),
                            );
                    }
                    ServiceCommand::ConfigUpdate(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_add_mut()` on a `ServiceCommand::ConfigUpdate` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyAdd(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_add_mut()` on a `ServiceCommand::DependencyAdd` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyRemove(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_add_mut()` on a `ServiceCommand::DependencyRemove` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyList(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_add_mut()` on a `ServiceCommand::DependencyList` value",
                                ),
                            );
                    }
                    ServiceCommand::GitCheckout(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_add_mut()` on a `ServiceCommand::GitCheckout` value",
                                ),
                            );
                    }
                    ServiceCommand::GitStatus(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_add_mut()` on a `ServiceCommand::GitStatus` value",
                                ),
                            );
                    }
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Unwraps this value to the `ServiceCommand::DependencyRemove` variant.
        */
        ///Panics if this value is of any other type.
        pub fn unwrap_dependency_remove(self) -> (RemoveDependencyCommand) {
            match self {
                ServiceCommand::DependencyRemove(field_0) => (field_0),
                val @ _ => match val {
                    ServiceCommand::Start(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_remove()` on a `ServiceCommand::Start` value",
                                ),
                            );
                    }
                    ServiceCommand::Stop(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_remove()` on a `ServiceCommand::Stop` value",
                                ),
                            );
                    }
                    ServiceCommand::Restart(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_remove()` on a `ServiceCommand::Restart` value",
                                ),
                            );
                    }
                    ServiceCommand::List(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_remove()` on a `ServiceCommand::List` value",
                                ),
                            );
                    }
                    ServiceCommand::Status(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_remove()` on a `ServiceCommand::Status` value",
                                ),
                            );
                    }
                    ServiceCommand::Add(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_remove()` on a `ServiceCommand::Add` value",
                                ),
                            );
                    }
                    ServiceCommand::Remove(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_remove()` on a `ServiceCommand::Remove` value",
                                ),
                            );
                    }
                    ServiceCommand::ConfigGet(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_remove()` on a `ServiceCommand::ConfigGet` value",
                                ),
                            );
                    }
                    ServiceCommand::ConfigUpdate(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_remove()` on a `ServiceCommand::ConfigUpdate` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyAdd(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_remove()` on a `ServiceCommand::DependencyAdd` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyRemove(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_remove()` on a `ServiceCommand::DependencyRemove` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyList(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_remove()` on a `ServiceCommand::DependencyList` value",
                                ),
                            );
                    }
                    ServiceCommand::GitCheckout(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_remove()` on a `ServiceCommand::GitCheckout` value",
                                ),
                            );
                    }
                    ServiceCommand::GitStatus(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_remove()` on a `ServiceCommand::GitStatus` value",
                                ),
                            );
                    }
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Unwraps this reference to the `ServiceCommand::DependencyRemove` variant.
        */
        ///Panics if this value is of any other type.
        pub fn unwrap_dependency_remove_ref(&self) -> (&RemoveDependencyCommand) {
            match self {
                ServiceCommand::DependencyRemove(field_0) => (field_0),
                val @ _ => match val {
                    ServiceCommand::Start(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_remove_ref()` on a `ServiceCommand::Start` value",
                                ),
                            );
                    }
                    ServiceCommand::Stop(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_remove_ref()` on a `ServiceCommand::Stop` value",
                                ),
                            );
                    }
                    ServiceCommand::Restart(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_remove_ref()` on a `ServiceCommand::Restart` value",
                                ),
                            );
                    }
                    ServiceCommand::List(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_remove_ref()` on a `ServiceCommand::List` value",
                                ),
                            );
                    }
                    ServiceCommand::Status(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_remove_ref()` on a `ServiceCommand::Status` value",
                                ),
                            );
                    }
                    ServiceCommand::Add(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_remove_ref()` on a `ServiceCommand::Add` value",
                                ),
                            );
                    }
                    ServiceCommand::Remove(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_remove_ref()` on a `ServiceCommand::Remove` value",
                                ),
                            );
                    }
                    ServiceCommand::ConfigGet(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_remove_ref()` on a `ServiceCommand::ConfigGet` value",
                                ),
                            );
                    }
                    ServiceCommand::ConfigUpdate(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_remove_ref()` on a `ServiceCommand::ConfigUpdate` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyAdd(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_remove_ref()` on a `ServiceCommand::DependencyAdd` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyRemove(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_remove_ref()` on a `ServiceCommand::DependencyRemove` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyList(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_remove_ref()` on a `ServiceCommand::DependencyList` value",
                                ),
                            );
                    }
                    ServiceCommand::GitCheckout(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_remove_ref()` on a `ServiceCommand::GitCheckout` value",
                                ),
                            );
                    }
                    ServiceCommand::GitStatus(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_remove_ref()` on a `ServiceCommand::GitStatus` value",
                                ),
                            );
                    }
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Unwraps this mutable reference to the `ServiceCommand::DependencyRemove` variant.
        */
        ///Panics if this value is of any other type.
        pub fn unwrap_dependency_remove_mut(&mut self) -> (&mut RemoveDependencyCommand) {
            match self {
                ServiceCommand::DependencyRemove(field_0) => (field_0),
                val @ _ => match val {
                    ServiceCommand::Start(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_remove_mut()` on a `ServiceCommand::Start` value",
                                ),
                            );
                    }
                    ServiceCommand::Stop(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_remove_mut()` on a `ServiceCommand::Stop` value",
                                ),
                            );
                    }
                    ServiceCommand::Restart(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_remove_mut()` on a `ServiceCommand::Restart` value",
                                ),
                            );
                    }
                    ServiceCommand::List(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_remove_mut()` on a `ServiceCommand::List` value",
                                ),
                            );
                    }
                    ServiceCommand::Status(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_remove_mut()` on a `ServiceCommand::Status` value",
                                ),
                            );
                    }
                    ServiceCommand::Add(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_remove_mut()` on a `ServiceCommand::Add` value",
                                ),
                            );
                    }
                    ServiceCommand::Remove(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_remove_mut()` on a `ServiceCommand::Remove` value",
                                ),
                            );
                    }
                    ServiceCommand::ConfigGet(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_remove_mut()` on a `ServiceCommand::ConfigGet` value",
                                ),
                            );
                    }
                    ServiceCommand::ConfigUpdate(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_remove_mut()` on a `ServiceCommand::ConfigUpdate` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyAdd(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_remove_mut()` on a `ServiceCommand::DependencyAdd` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyRemove(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_remove_mut()` on a `ServiceCommand::DependencyRemove` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyList(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_remove_mut()` on a `ServiceCommand::DependencyList` value",
                                ),
                            );
                    }
                    ServiceCommand::GitCheckout(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_remove_mut()` on a `ServiceCommand::GitCheckout` value",
                                ),
                            );
                    }
                    ServiceCommand::GitStatus(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_remove_mut()` on a `ServiceCommand::GitStatus` value",
                                ),
                            );
                    }
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Unwraps this value to the `ServiceCommand::DependencyList` variant.
        */
        ///Panics if this value is of any other type.
        pub fn unwrap_dependency_list(self) -> (ListDependenciesCommand) {
            match self {
                ServiceCommand::DependencyList(field_0) => (field_0),
                val @ _ => match val {
                    ServiceCommand::Start(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_list()` on a `ServiceCommand::Start` value",
                                ),
                            );
                    }
                    ServiceCommand::Stop(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_list()` on a `ServiceCommand::Stop` value",
                                ),
                            );
                    }
                    ServiceCommand::Restart(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_list()` on a `ServiceCommand::Restart` value",
                                ),
                            );
                    }
                    ServiceCommand::List(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_list()` on a `ServiceCommand::List` value",
                                ),
                            );
                    }
                    ServiceCommand::Status(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_list()` on a `ServiceCommand::Status` value",
                                ),
                            );
                    }
                    ServiceCommand::Add(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_list()` on a `ServiceCommand::Add` value",
                                ),
                            );
                    }
                    ServiceCommand::Remove(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_list()` on a `ServiceCommand::Remove` value",
                                ),
                            );
                    }
                    ServiceCommand::ConfigGet(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_list()` on a `ServiceCommand::ConfigGet` value",
                                ),
                            );
                    }
                    ServiceCommand::ConfigUpdate(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_list()` on a `ServiceCommand::ConfigUpdate` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyAdd(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_list()` on a `ServiceCommand::DependencyAdd` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyRemove(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_list()` on a `ServiceCommand::DependencyRemove` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyList(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_list()` on a `ServiceCommand::DependencyList` value",
                                ),
                            );
                    }
                    ServiceCommand::GitCheckout(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_list()` on a `ServiceCommand::GitCheckout` value",
                                ),
                            );
                    }
                    ServiceCommand::GitStatus(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_list()` on a `ServiceCommand::GitStatus` value",
                                ),
                            );
                    }
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Unwraps this reference to the `ServiceCommand::DependencyList` variant.
        */
        ///Panics if this value is of any other type.
        pub fn unwrap_dependency_list_ref(&self) -> (&ListDependenciesCommand) {
            match self {
                ServiceCommand::DependencyList(field_0) => (field_0),
                val @ _ => match val {
                    ServiceCommand::Start(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_list_ref()` on a `ServiceCommand::Start` value",
                                ),
                            );
                    }
                    ServiceCommand::Stop(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_list_ref()` on a `ServiceCommand::Stop` value",
                                ),
                            );
                    }
                    ServiceCommand::Restart(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_list_ref()` on a `ServiceCommand::Restart` value",
                                ),
                            );
                    }
                    ServiceCommand::List(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_list_ref()` on a `ServiceCommand::List` value",
                                ),
                            );
                    }
                    ServiceCommand::Status(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_list_ref()` on a `ServiceCommand::Status` value",
                                ),
                            );
                    }
                    ServiceCommand::Add(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_list_ref()` on a `ServiceCommand::Add` value",
                                ),
                            );
                    }
                    ServiceCommand::Remove(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_list_ref()` on a `ServiceCommand::Remove` value",
                                ),
                            );
                    }
                    ServiceCommand::ConfigGet(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_list_ref()` on a `ServiceCommand::ConfigGet` value",
                                ),
                            );
                    }
                    ServiceCommand::ConfigUpdate(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_list_ref()` on a `ServiceCommand::ConfigUpdate` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyAdd(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_list_ref()` on a `ServiceCommand::DependencyAdd` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyRemove(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_list_ref()` on a `ServiceCommand::DependencyRemove` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyList(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_list_ref()` on a `ServiceCommand::DependencyList` value",
                                ),
                            );
                    }
                    ServiceCommand::GitCheckout(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_list_ref()` on a `ServiceCommand::GitCheckout` value",
                                ),
                            );
                    }
                    ServiceCommand::GitStatus(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_list_ref()` on a `ServiceCommand::GitStatus` value",
                                ),
                            );
                    }
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Unwraps this mutable reference to the `ServiceCommand::DependencyList` variant.
        */
        ///Panics if this value is of any other type.
        pub fn unwrap_dependency_list_mut(&mut self) -> (&mut ListDependenciesCommand) {
            match self {
                ServiceCommand::DependencyList(field_0) => (field_0),
                val @ _ => match val {
                    ServiceCommand::Start(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_list_mut()` on a `ServiceCommand::Start` value",
                                ),
                            );
                    }
                    ServiceCommand::Stop(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_list_mut()` on a `ServiceCommand::Stop` value",
                                ),
                            );
                    }
                    ServiceCommand::Restart(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_list_mut()` on a `ServiceCommand::Restart` value",
                                ),
                            );
                    }
                    ServiceCommand::List(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_list_mut()` on a `ServiceCommand::List` value",
                                ),
                            );
                    }
                    ServiceCommand::Status(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_list_mut()` on a `ServiceCommand::Status` value",
                                ),
                            );
                    }
                    ServiceCommand::Add(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_list_mut()` on a `ServiceCommand::Add` value",
                                ),
                            );
                    }
                    ServiceCommand::Remove(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_list_mut()` on a `ServiceCommand::Remove` value",
                                ),
                            );
                    }
                    ServiceCommand::ConfigGet(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_list_mut()` on a `ServiceCommand::ConfigGet` value",
                                ),
                            );
                    }
                    ServiceCommand::ConfigUpdate(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_list_mut()` on a `ServiceCommand::ConfigUpdate` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyAdd(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_list_mut()` on a `ServiceCommand::DependencyAdd` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyRemove(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_list_mut()` on a `ServiceCommand::DependencyRemove` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyList(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_list_mut()` on a `ServiceCommand::DependencyList` value",
                                ),
                            );
                    }
                    ServiceCommand::GitCheckout(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_list_mut()` on a `ServiceCommand::GitCheckout` value",
                                ),
                            );
                    }
                    ServiceCommand::GitStatus(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_dependency_list_mut()` on a `ServiceCommand::GitStatus` value",
                                ),
                            );
                    }
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Unwraps this value to the `ServiceCommand::GitCheckout` variant.
        */
        ///Panics if this value is of any other type.
        pub fn unwrap_git_checkout(self) -> (CheckoutCommand) {
            match self {
                ServiceCommand::GitCheckout(field_0) => (field_0),
                val @ _ => match val {
                    ServiceCommand::Start(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_git_checkout()` on a `ServiceCommand::Start` value",
                                ),
                            );
                    }
                    ServiceCommand::Stop(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_git_checkout()` on a `ServiceCommand::Stop` value",
                                ),
                            );
                    }
                    ServiceCommand::Restart(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_git_checkout()` on a `ServiceCommand::Restart` value",
                                ),
                            );
                    }
                    ServiceCommand::List(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_git_checkout()` on a `ServiceCommand::List` value",
                                ),
                            );
                    }
                    ServiceCommand::Status(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_git_checkout()` on a `ServiceCommand::Status` value",
                                ),
                            );
                    }
                    ServiceCommand::Add(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_git_checkout()` on a `ServiceCommand::Add` value",
                                ),
                            );
                    }
                    ServiceCommand::Remove(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_git_checkout()` on a `ServiceCommand::Remove` value",
                                ),
                            );
                    }
                    ServiceCommand::ConfigGet(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_git_checkout()` on a `ServiceCommand::ConfigGet` value",
                                ),
                            );
                    }
                    ServiceCommand::ConfigUpdate(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_git_checkout()` on a `ServiceCommand::ConfigUpdate` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyAdd(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_git_checkout()` on a `ServiceCommand::DependencyAdd` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyRemove(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_git_checkout()` on a `ServiceCommand::DependencyRemove` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyList(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_git_checkout()` on a `ServiceCommand::DependencyList` value",
                                ),
                            );
                    }
                    ServiceCommand::GitCheckout(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_git_checkout()` on a `ServiceCommand::GitCheckout` value",
                                ),
                            );
                    }
                    ServiceCommand::GitStatus(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_git_checkout()` on a `ServiceCommand::GitStatus` value",
                                ),
                            );
                    }
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Unwraps this reference to the `ServiceCommand::GitCheckout` variant.
        */
        ///Panics if this value is of any other type.
        pub fn unwrap_git_checkout_ref(&self) -> (&CheckoutCommand) {
            match self {
                ServiceCommand::GitCheckout(field_0) => (field_0),
                val @ _ => match val {
                    ServiceCommand::Start(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_git_checkout_ref()` on a `ServiceCommand::Start` value",
                                ),
                            );
                    }
                    ServiceCommand::Stop(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_git_checkout_ref()` on a `ServiceCommand::Stop` value",
                                ),
                            );
                    }
                    ServiceCommand::Restart(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_git_checkout_ref()` on a `ServiceCommand::Restart` value",
                                ),
                            );
                    }
                    ServiceCommand::List(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_git_checkout_ref()` on a `ServiceCommand::List` value",
                                ),
                            );
                    }
                    ServiceCommand::Status(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_git_checkout_ref()` on a `ServiceCommand::Status` value",
                                ),
                            );
                    }
                    ServiceCommand::Add(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_git_checkout_ref()` on a `ServiceCommand::Add` value",
                                ),
                            );
                    }
                    ServiceCommand::Remove(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_git_checkout_ref()` on a `ServiceCommand::Remove` value",
                                ),
                            );
                    }
                    ServiceCommand::ConfigGet(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_git_checkout_ref()` on a `ServiceCommand::ConfigGet` value",
                                ),
                            );
                    }
                    ServiceCommand::ConfigUpdate(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_git_checkout_ref()` on a `ServiceCommand::ConfigUpdate` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyAdd(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_git_checkout_ref()` on a `ServiceCommand::DependencyAdd` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyRemove(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_git_checkout_ref()` on a `ServiceCommand::DependencyRemove` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyList(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_git_checkout_ref()` on a `ServiceCommand::DependencyList` value",
                                ),
                            );
                    }
                    ServiceCommand::GitCheckout(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_git_checkout_ref()` on a `ServiceCommand::GitCheckout` value",
                                ),
                            );
                    }
                    ServiceCommand::GitStatus(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_git_checkout_ref()` on a `ServiceCommand::GitStatus` value",
                                ),
                            );
                    }
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Unwraps this mutable reference to the `ServiceCommand::GitCheckout` variant.
        */
        ///Panics if this value is of any other type.
        pub fn unwrap_git_checkout_mut(&mut self) -> (&mut CheckoutCommand) {
            match self {
                ServiceCommand::GitCheckout(field_0) => (field_0),
                val @ _ => match val {
                    ServiceCommand::Start(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_git_checkout_mut()` on a `ServiceCommand::Start` value",
                                ),
                            );
                    }
                    ServiceCommand::Stop(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_git_checkout_mut()` on a `ServiceCommand::Stop` value",
                                ),
                            );
                    }
                    ServiceCommand::Restart(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_git_checkout_mut()` on a `ServiceCommand::Restart` value",
                                ),
                            );
                    }
                    ServiceCommand::List(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_git_checkout_mut()` on a `ServiceCommand::List` value",
                                ),
                            );
                    }
                    ServiceCommand::Status(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_git_checkout_mut()` on a `ServiceCommand::Status` value",
                                ),
                            );
                    }
                    ServiceCommand::Add(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_git_checkout_mut()` on a `ServiceCommand::Add` value",
                                ),
                            );
                    }
                    ServiceCommand::Remove(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_git_checkout_mut()` on a `ServiceCommand::Remove` value",
                                ),
                            );
                    }
                    ServiceCommand::ConfigGet(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_git_checkout_mut()` on a `ServiceCommand::ConfigGet` value",
                                ),
                            );
                    }
                    ServiceCommand::ConfigUpdate(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_git_checkout_mut()` on a `ServiceCommand::ConfigUpdate` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyAdd(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_git_checkout_mut()` on a `ServiceCommand::DependencyAdd` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyRemove(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_git_checkout_mut()` on a `ServiceCommand::DependencyRemove` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyList(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_git_checkout_mut()` on a `ServiceCommand::DependencyList` value",
                                ),
                            );
                    }
                    ServiceCommand::GitCheckout(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_git_checkout_mut()` on a `ServiceCommand::GitCheckout` value",
                                ),
                            );
                    }
                    ServiceCommand::GitStatus(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_git_checkout_mut()` on a `ServiceCommand::GitStatus` value",
                                ),
                            );
                    }
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Unwraps this value to the `ServiceCommand::GitStatus` variant.
        */
        ///Panics if this value is of any other type.
        pub fn unwrap_git_status(self) -> (GetRepoStatusCommand) {
            match self {
                ServiceCommand::GitStatus(field_0) => (field_0),
                val @ _ => match val {
                    ServiceCommand::Start(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_git_status()` on a `ServiceCommand::Start` value",
                                ),
                            );
                    }
                    ServiceCommand::Stop(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_git_status()` on a `ServiceCommand::Stop` value",
                                ),
                            );
                    }
                    ServiceCommand::Restart(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_git_status()` on a `ServiceCommand::Restart` value",
                                ),
                            );
                    }
                    ServiceCommand::List(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_git_status()` on a `ServiceCommand::List` value",
                                ),
                            );
                    }
                    ServiceCommand::Status(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_git_status()` on a `ServiceCommand::Status` value",
                                ),
                            );
                    }
                    ServiceCommand::Add(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_git_status()` on a `ServiceCommand::Add` value",
                                ),
                            );
                    }
                    ServiceCommand::Remove(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_git_status()` on a `ServiceCommand::Remove` value",
                                ),
                            );
                    }
                    ServiceCommand::ConfigGet(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_git_status()` on a `ServiceCommand::ConfigGet` value",
                                ),
                            );
                    }
                    ServiceCommand::ConfigUpdate(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_git_status()` on a `ServiceCommand::ConfigUpdate` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyAdd(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_git_status()` on a `ServiceCommand::DependencyAdd` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyRemove(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_git_status()` on a `ServiceCommand::DependencyRemove` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyList(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_git_status()` on a `ServiceCommand::DependencyList` value",
                                ),
                            );
                    }
                    ServiceCommand::GitCheckout(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_git_status()` on a `ServiceCommand::GitCheckout` value",
                                ),
                            );
                    }
                    ServiceCommand::GitStatus(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_git_status()` on a `ServiceCommand::GitStatus` value",
                                ),
                            );
                    }
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Unwraps this reference to the `ServiceCommand::GitStatus` variant.
        */
        ///Panics if this value is of any other type.
        pub fn unwrap_git_status_ref(&self) -> (&GetRepoStatusCommand) {
            match self {
                ServiceCommand::GitStatus(field_0) => (field_0),
                val @ _ => match val {
                    ServiceCommand::Start(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_git_status_ref()` on a `ServiceCommand::Start` value",
                                ),
                            );
                    }
                    ServiceCommand::Stop(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_git_status_ref()` on a `ServiceCommand::Stop` value",
                                ),
                            );
                    }
                    ServiceCommand::Restart(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_git_status_ref()` on a `ServiceCommand::Restart` value",
                                ),
                            );
                    }
                    ServiceCommand::List(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_git_status_ref()` on a `ServiceCommand::List` value",
                                ),
                            );
                    }
                    ServiceCommand::Status(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_git_status_ref()` on a `ServiceCommand::Status` value",
                                ),
                            );
                    }
                    ServiceCommand::Add(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_git_status_ref()` on a `ServiceCommand::Add` value",
                                ),
                            );
                    }
                    ServiceCommand::Remove(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_git_status_ref()` on a `ServiceCommand::Remove` value",
                                ),
                            );
                    }
                    ServiceCommand::ConfigGet(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_git_status_ref()` on a `ServiceCommand::ConfigGet` value",
                                ),
                            );
                    }
                    ServiceCommand::ConfigUpdate(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_git_status_ref()` on a `ServiceCommand::ConfigUpdate` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyAdd(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_git_status_ref()` on a `ServiceCommand::DependencyAdd` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyRemove(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_git_status_ref()` on a `ServiceCommand::DependencyRemove` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyList(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_git_status_ref()` on a `ServiceCommand::DependencyList` value",
                                ),
                            );
                    }
                    ServiceCommand::GitCheckout(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_git_status_ref()` on a `ServiceCommand::GitCheckout` value",
                                ),
                            );
                    }
                    ServiceCommand::GitStatus(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_git_status_ref()` on a `ServiceCommand::GitStatus` value",
                                ),
                            );
                    }
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Unwraps this mutable reference to the `ServiceCommand::GitStatus` variant.
        */
        ///Panics if this value is of any other type.
        pub fn unwrap_git_status_mut(&mut self) -> (&mut GetRepoStatusCommand) {
            match self {
                ServiceCommand::GitStatus(field_0) => (field_0),
                val @ _ => match val {
                    ServiceCommand::Start(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_git_status_mut()` on a `ServiceCommand::Start` value",
                                ),
                            );
                    }
                    ServiceCommand::Stop(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_git_status_mut()` on a `ServiceCommand::Stop` value",
                                ),
                            );
                    }
                    ServiceCommand::Restart(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_git_status_mut()` on a `ServiceCommand::Restart` value",
                                ),
                            );
                    }
                    ServiceCommand::List(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_git_status_mut()` on a `ServiceCommand::List` value",
                                ),
                            );
                    }
                    ServiceCommand::Status(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_git_status_mut()` on a `ServiceCommand::Status` value",
                                ),
                            );
                    }
                    ServiceCommand::Add(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_git_status_mut()` on a `ServiceCommand::Add` value",
                                ),
                            );
                    }
                    ServiceCommand::Remove(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_git_status_mut()` on a `ServiceCommand::Remove` value",
                                ),
                            );
                    }
                    ServiceCommand::ConfigGet(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_git_status_mut()` on a `ServiceCommand::ConfigGet` value",
                                ),
                            );
                    }
                    ServiceCommand::ConfigUpdate(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_git_status_mut()` on a `ServiceCommand::ConfigUpdate` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyAdd(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_git_status_mut()` on a `ServiceCommand::DependencyAdd` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyRemove(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_git_status_mut()` on a `ServiceCommand::DependencyRemove` value",
                                ),
                            );
                    }
                    ServiceCommand::DependencyList(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_git_status_mut()` on a `ServiceCommand::DependencyList` value",
                                ),
                            );
                    }
                    ServiceCommand::GitCheckout(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_git_status_mut()` on a `ServiceCommand::GitCheckout` value",
                                ),
                            );
                    }
                    ServiceCommand::GitStatus(..) => {
                        ::core::panicking::panic_fmt(
                                format_args!(
                                    "called `ServiceCommand::unwrap_git_status_mut()` on a `ServiceCommand::GitStatus` value",
                                ),
                            );
                    }
                },
            }
        }
    }
    #[automatically_derived]
    impl ServiceCommand {
        #[inline]
        #[track_caller]
        /**Attempts to unwrap this value to the `ServiceCommand::Start` variant.
        */
        ///Returns a [TryUnwrapError] with the original value if this value is of any other type.
        pub fn try_unwrap_start(
            self,
        ) -> derive_more::core::result::Result<
            (StartServiceCommand),
            derive_more::TryUnwrapError<Self>,
        > {
            match self {
                ServiceCommand::Start(field_0) => derive_more::core::result::Result::Ok((field_0)),
                val @ _ => match val {
                    val @ ServiceCommand::Start(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Start",
                            "try_unwrap_start",
                        ),
                    ),
                    val @ ServiceCommand::Stop(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Stop",
                            "try_unwrap_start",
                        ),
                    ),
                    val @ ServiceCommand::Restart(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Restart",
                            "try_unwrap_start",
                        ),
                    ),
                    val @ ServiceCommand::List(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "List",
                            "try_unwrap_start",
                        ),
                    ),
                    val @ ServiceCommand::Status(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Status",
                            "try_unwrap_start",
                        ),
                    ),
                    val @ ServiceCommand::Add(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Add",
                            "try_unwrap_start",
                        ),
                    ),
                    val @ ServiceCommand::Remove(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Remove",
                            "try_unwrap_start",
                        ),
                    ),
                    val @ ServiceCommand::ConfigGet(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "ConfigGet",
                            "try_unwrap_start",
                        ),
                    ),
                    val @ ServiceCommand::ConfigUpdate(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "ConfigUpdate",
                                "try_unwrap_start",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyAdd(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyAdd",
                                "try_unwrap_start",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyRemove(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyRemove",
                                "try_unwrap_start",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyList(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyList",
                                "try_unwrap_start",
                            ),
                        )
                    }
                    val @ ServiceCommand::GitCheckout(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "GitCheckout",
                                "try_unwrap_start",
                            ),
                        )
                    }
                    val @ ServiceCommand::GitStatus(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "GitStatus",
                            "try_unwrap_start",
                        ),
                    ),
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Attempts to unwrap this reference to the `ServiceCommand::Start` variant.
        */
        ///Returns a [TryUnwrapError] with the original value if this value is of any other type.
        pub fn try_unwrap_start_ref(
            &self,
        ) -> derive_more::core::result::Result<
            (&StartServiceCommand),
            derive_more::TryUnwrapError<&Self>,
        > {
            match self {
                ServiceCommand::Start(field_0) => derive_more::core::result::Result::Ok((field_0)),
                val @ _ => match val {
                    val @ ServiceCommand::Start(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Start",
                            "try_unwrap_start_ref",
                        ),
                    ),
                    val @ ServiceCommand::Stop(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Stop",
                            "try_unwrap_start_ref",
                        ),
                    ),
                    val @ ServiceCommand::Restart(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Restart",
                            "try_unwrap_start_ref",
                        ),
                    ),
                    val @ ServiceCommand::List(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "List",
                            "try_unwrap_start_ref",
                        ),
                    ),
                    val @ ServiceCommand::Status(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Status",
                            "try_unwrap_start_ref",
                        ),
                    ),
                    val @ ServiceCommand::Add(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Add",
                            "try_unwrap_start_ref",
                        ),
                    ),
                    val @ ServiceCommand::Remove(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Remove",
                            "try_unwrap_start_ref",
                        ),
                    ),
                    val @ ServiceCommand::ConfigGet(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "ConfigGet",
                            "try_unwrap_start_ref",
                        ),
                    ),
                    val @ ServiceCommand::ConfigUpdate(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "ConfigUpdate",
                                "try_unwrap_start_ref",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyAdd(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyAdd",
                                "try_unwrap_start_ref",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyRemove(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyRemove",
                                "try_unwrap_start_ref",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyList(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyList",
                                "try_unwrap_start_ref",
                            ),
                        )
                    }
                    val @ ServiceCommand::GitCheckout(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "GitCheckout",
                                "try_unwrap_start_ref",
                            ),
                        )
                    }
                    val @ ServiceCommand::GitStatus(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "GitStatus",
                            "try_unwrap_start_ref",
                        ),
                    ),
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Attempts to unwrap this mutable reference to the `ServiceCommand::Start` variant.
        */
        ///Returns a [TryUnwrapError] with the original value if this value is of any other type.
        pub fn try_unwrap_start_mut(
            &mut self,
        ) -> derive_more::core::result::Result<
            (&mut StartServiceCommand),
            derive_more::TryUnwrapError<&mut Self>,
        > {
            match self {
                ServiceCommand::Start(field_0) => derive_more::core::result::Result::Ok((field_0)),
                val @ _ => match val {
                    val @ ServiceCommand::Start(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Start",
                            "try_unwrap_start_mut",
                        ),
                    ),
                    val @ ServiceCommand::Stop(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Stop",
                            "try_unwrap_start_mut",
                        ),
                    ),
                    val @ ServiceCommand::Restart(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Restart",
                            "try_unwrap_start_mut",
                        ),
                    ),
                    val @ ServiceCommand::List(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "List",
                            "try_unwrap_start_mut",
                        ),
                    ),
                    val @ ServiceCommand::Status(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Status",
                            "try_unwrap_start_mut",
                        ),
                    ),
                    val @ ServiceCommand::Add(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Add",
                            "try_unwrap_start_mut",
                        ),
                    ),
                    val @ ServiceCommand::Remove(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Remove",
                            "try_unwrap_start_mut",
                        ),
                    ),
                    val @ ServiceCommand::ConfigGet(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "ConfigGet",
                            "try_unwrap_start_mut",
                        ),
                    ),
                    val @ ServiceCommand::ConfigUpdate(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "ConfigUpdate",
                                "try_unwrap_start_mut",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyAdd(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyAdd",
                                "try_unwrap_start_mut",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyRemove(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyRemove",
                                "try_unwrap_start_mut",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyList(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyList",
                                "try_unwrap_start_mut",
                            ),
                        )
                    }
                    val @ ServiceCommand::GitCheckout(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "GitCheckout",
                                "try_unwrap_start_mut",
                            ),
                        )
                    }
                    val @ ServiceCommand::GitStatus(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "GitStatus",
                            "try_unwrap_start_mut",
                        ),
                    ),
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Attempts to unwrap this value to the `ServiceCommand::Stop` variant.
        */
        ///Returns a [TryUnwrapError] with the original value if this value is of any other type.
        pub fn try_unwrap_stop(
            self,
        ) -> derive_more::core::result::Result<
            (StopServiceCommand),
            derive_more::TryUnwrapError<Self>,
        > {
            match self {
                ServiceCommand::Stop(field_0) => derive_more::core::result::Result::Ok((field_0)),
                val @ _ => match val {
                    val @ ServiceCommand::Start(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Start",
                            "try_unwrap_stop",
                        ),
                    ),
                    val @ ServiceCommand::Stop(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Stop",
                            "try_unwrap_stop",
                        ),
                    ),
                    val @ ServiceCommand::Restart(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Restart",
                            "try_unwrap_stop",
                        ),
                    ),
                    val @ ServiceCommand::List(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "List",
                            "try_unwrap_stop",
                        ),
                    ),
                    val @ ServiceCommand::Status(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Status",
                            "try_unwrap_stop",
                        ),
                    ),
                    val @ ServiceCommand::Add(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Add",
                            "try_unwrap_stop",
                        ),
                    ),
                    val @ ServiceCommand::Remove(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Remove",
                            "try_unwrap_stop",
                        ),
                    ),
                    val @ ServiceCommand::ConfigGet(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "ConfigGet",
                            "try_unwrap_stop",
                        ),
                    ),
                    val @ ServiceCommand::ConfigUpdate(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "ConfigUpdate",
                                "try_unwrap_stop",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyAdd(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyAdd",
                                "try_unwrap_stop",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyRemove(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyRemove",
                                "try_unwrap_stop",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyList(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyList",
                                "try_unwrap_stop",
                            ),
                        )
                    }
                    val @ ServiceCommand::GitCheckout(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "GitCheckout",
                                "try_unwrap_stop",
                            ),
                        )
                    }
                    val @ ServiceCommand::GitStatus(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "GitStatus",
                            "try_unwrap_stop",
                        ),
                    ),
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Attempts to unwrap this reference to the `ServiceCommand::Stop` variant.
        */
        ///Returns a [TryUnwrapError] with the original value if this value is of any other type.
        pub fn try_unwrap_stop_ref(
            &self,
        ) -> derive_more::core::result::Result<
            (&StopServiceCommand),
            derive_more::TryUnwrapError<&Self>,
        > {
            match self {
                ServiceCommand::Stop(field_0) => derive_more::core::result::Result::Ok((field_0)),
                val @ _ => match val {
                    val @ ServiceCommand::Start(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Start",
                            "try_unwrap_stop_ref",
                        ),
                    ),
                    val @ ServiceCommand::Stop(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Stop",
                            "try_unwrap_stop_ref",
                        ),
                    ),
                    val @ ServiceCommand::Restart(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Restart",
                            "try_unwrap_stop_ref",
                        ),
                    ),
                    val @ ServiceCommand::List(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "List",
                            "try_unwrap_stop_ref",
                        ),
                    ),
                    val @ ServiceCommand::Status(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Status",
                            "try_unwrap_stop_ref",
                        ),
                    ),
                    val @ ServiceCommand::Add(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Add",
                            "try_unwrap_stop_ref",
                        ),
                    ),
                    val @ ServiceCommand::Remove(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Remove",
                            "try_unwrap_stop_ref",
                        ),
                    ),
                    val @ ServiceCommand::ConfigGet(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "ConfigGet",
                            "try_unwrap_stop_ref",
                        ),
                    ),
                    val @ ServiceCommand::ConfigUpdate(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "ConfigUpdate",
                                "try_unwrap_stop_ref",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyAdd(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyAdd",
                                "try_unwrap_stop_ref",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyRemove(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyRemove",
                                "try_unwrap_stop_ref",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyList(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyList",
                                "try_unwrap_stop_ref",
                            ),
                        )
                    }
                    val @ ServiceCommand::GitCheckout(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "GitCheckout",
                                "try_unwrap_stop_ref",
                            ),
                        )
                    }
                    val @ ServiceCommand::GitStatus(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "GitStatus",
                            "try_unwrap_stop_ref",
                        ),
                    ),
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Attempts to unwrap this mutable reference to the `ServiceCommand::Stop` variant.
        */
        ///Returns a [TryUnwrapError] with the original value if this value is of any other type.
        pub fn try_unwrap_stop_mut(
            &mut self,
        ) -> derive_more::core::result::Result<
            (&mut StopServiceCommand),
            derive_more::TryUnwrapError<&mut Self>,
        > {
            match self {
                ServiceCommand::Stop(field_0) => derive_more::core::result::Result::Ok((field_0)),
                val @ _ => match val {
                    val @ ServiceCommand::Start(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Start",
                            "try_unwrap_stop_mut",
                        ),
                    ),
                    val @ ServiceCommand::Stop(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Stop",
                            "try_unwrap_stop_mut",
                        ),
                    ),
                    val @ ServiceCommand::Restart(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Restart",
                            "try_unwrap_stop_mut",
                        ),
                    ),
                    val @ ServiceCommand::List(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "List",
                            "try_unwrap_stop_mut",
                        ),
                    ),
                    val @ ServiceCommand::Status(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Status",
                            "try_unwrap_stop_mut",
                        ),
                    ),
                    val @ ServiceCommand::Add(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Add",
                            "try_unwrap_stop_mut",
                        ),
                    ),
                    val @ ServiceCommand::Remove(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Remove",
                            "try_unwrap_stop_mut",
                        ),
                    ),
                    val @ ServiceCommand::ConfigGet(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "ConfigGet",
                            "try_unwrap_stop_mut",
                        ),
                    ),
                    val @ ServiceCommand::ConfigUpdate(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "ConfigUpdate",
                                "try_unwrap_stop_mut",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyAdd(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyAdd",
                                "try_unwrap_stop_mut",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyRemove(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyRemove",
                                "try_unwrap_stop_mut",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyList(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyList",
                                "try_unwrap_stop_mut",
                            ),
                        )
                    }
                    val @ ServiceCommand::GitCheckout(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "GitCheckout",
                                "try_unwrap_stop_mut",
                            ),
                        )
                    }
                    val @ ServiceCommand::GitStatus(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "GitStatus",
                            "try_unwrap_stop_mut",
                        ),
                    ),
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Attempts to unwrap this value to the `ServiceCommand::Restart` variant.
        */
        ///Returns a [TryUnwrapError] with the original value if this value is of any other type.
        pub fn try_unwrap_restart(
            self,
        ) -> derive_more::core::result::Result<
            (RestartServiceCommand),
            derive_more::TryUnwrapError<Self>,
        > {
            match self {
                ServiceCommand::Restart(field_0) => {
                    derive_more::core::result::Result::Ok((field_0))
                }
                val @ _ => match val {
                    val @ ServiceCommand::Start(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Start",
                            "try_unwrap_restart",
                        ),
                    ),
                    val @ ServiceCommand::Stop(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Stop",
                            "try_unwrap_restart",
                        ),
                    ),
                    val @ ServiceCommand::Restart(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Restart",
                            "try_unwrap_restart",
                        ),
                    ),
                    val @ ServiceCommand::List(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "List",
                            "try_unwrap_restart",
                        ),
                    ),
                    val @ ServiceCommand::Status(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Status",
                            "try_unwrap_restart",
                        ),
                    ),
                    val @ ServiceCommand::Add(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Add",
                            "try_unwrap_restart",
                        ),
                    ),
                    val @ ServiceCommand::Remove(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Remove",
                            "try_unwrap_restart",
                        ),
                    ),
                    val @ ServiceCommand::ConfigGet(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "ConfigGet",
                            "try_unwrap_restart",
                        ),
                    ),
                    val @ ServiceCommand::ConfigUpdate(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "ConfigUpdate",
                                "try_unwrap_restart",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyAdd(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyAdd",
                                "try_unwrap_restart",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyRemove(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyRemove",
                                "try_unwrap_restart",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyList(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyList",
                                "try_unwrap_restart",
                            ),
                        )
                    }
                    val @ ServiceCommand::GitCheckout(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "GitCheckout",
                                "try_unwrap_restart",
                            ),
                        )
                    }
                    val @ ServiceCommand::GitStatus(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "GitStatus",
                            "try_unwrap_restart",
                        ),
                    ),
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Attempts to unwrap this reference to the `ServiceCommand::Restart` variant.
        */
        ///Returns a [TryUnwrapError] with the original value if this value is of any other type.
        pub fn try_unwrap_restart_ref(
            &self,
        ) -> derive_more::core::result::Result<
            (&RestartServiceCommand),
            derive_more::TryUnwrapError<&Self>,
        > {
            match self {
                ServiceCommand::Restart(field_0) => {
                    derive_more::core::result::Result::Ok((field_0))
                }
                val @ _ => match val {
                    val @ ServiceCommand::Start(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Start",
                            "try_unwrap_restart_ref",
                        ),
                    ),
                    val @ ServiceCommand::Stop(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Stop",
                            "try_unwrap_restart_ref",
                        ),
                    ),
                    val @ ServiceCommand::Restart(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Restart",
                            "try_unwrap_restart_ref",
                        ),
                    ),
                    val @ ServiceCommand::List(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "List",
                            "try_unwrap_restart_ref",
                        ),
                    ),
                    val @ ServiceCommand::Status(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Status",
                            "try_unwrap_restart_ref",
                        ),
                    ),
                    val @ ServiceCommand::Add(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Add",
                            "try_unwrap_restart_ref",
                        ),
                    ),
                    val @ ServiceCommand::Remove(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Remove",
                            "try_unwrap_restart_ref",
                        ),
                    ),
                    val @ ServiceCommand::ConfigGet(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "ConfigGet",
                            "try_unwrap_restart_ref",
                        ),
                    ),
                    val @ ServiceCommand::ConfigUpdate(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "ConfigUpdate",
                                "try_unwrap_restart_ref",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyAdd(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyAdd",
                                "try_unwrap_restart_ref",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyRemove(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyRemove",
                                "try_unwrap_restart_ref",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyList(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyList",
                                "try_unwrap_restart_ref",
                            ),
                        )
                    }
                    val @ ServiceCommand::GitCheckout(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "GitCheckout",
                                "try_unwrap_restart_ref",
                            ),
                        )
                    }
                    val @ ServiceCommand::GitStatus(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "GitStatus",
                            "try_unwrap_restart_ref",
                        ),
                    ),
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Attempts to unwrap this mutable reference to the `ServiceCommand::Restart` variant.
        */
        ///Returns a [TryUnwrapError] with the original value if this value is of any other type.
        pub fn try_unwrap_restart_mut(
            &mut self,
        ) -> derive_more::core::result::Result<
            (&mut RestartServiceCommand),
            derive_more::TryUnwrapError<&mut Self>,
        > {
            match self {
                ServiceCommand::Restart(field_0) => {
                    derive_more::core::result::Result::Ok((field_0))
                }
                val @ _ => match val {
                    val @ ServiceCommand::Start(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Start",
                            "try_unwrap_restart_mut",
                        ),
                    ),
                    val @ ServiceCommand::Stop(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Stop",
                            "try_unwrap_restart_mut",
                        ),
                    ),
                    val @ ServiceCommand::Restart(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Restart",
                            "try_unwrap_restart_mut",
                        ),
                    ),
                    val @ ServiceCommand::List(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "List",
                            "try_unwrap_restart_mut",
                        ),
                    ),
                    val @ ServiceCommand::Status(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Status",
                            "try_unwrap_restart_mut",
                        ),
                    ),
                    val @ ServiceCommand::Add(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Add",
                            "try_unwrap_restart_mut",
                        ),
                    ),
                    val @ ServiceCommand::Remove(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Remove",
                            "try_unwrap_restart_mut",
                        ),
                    ),
                    val @ ServiceCommand::ConfigGet(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "ConfigGet",
                            "try_unwrap_restart_mut",
                        ),
                    ),
                    val @ ServiceCommand::ConfigUpdate(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "ConfigUpdate",
                                "try_unwrap_restart_mut",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyAdd(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyAdd",
                                "try_unwrap_restart_mut",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyRemove(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyRemove",
                                "try_unwrap_restart_mut",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyList(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyList",
                                "try_unwrap_restart_mut",
                            ),
                        )
                    }
                    val @ ServiceCommand::GitCheckout(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "GitCheckout",
                                "try_unwrap_restart_mut",
                            ),
                        )
                    }
                    val @ ServiceCommand::GitStatus(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "GitStatus",
                            "try_unwrap_restart_mut",
                        ),
                    ),
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Attempts to unwrap this value to the `ServiceCommand::List` variant.
        */
        ///Returns a [TryUnwrapError] with the original value if this value is of any other type.
        pub fn try_unwrap_list(
            self,
        ) -> derive_more::core::result::Result<
            (ListServicesCommand),
            derive_more::TryUnwrapError<Self>,
        > {
            match self {
                ServiceCommand::List(field_0) => derive_more::core::result::Result::Ok((field_0)),
                val @ _ => match val {
                    val @ ServiceCommand::Start(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Start",
                            "try_unwrap_list",
                        ),
                    ),
                    val @ ServiceCommand::Stop(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Stop",
                            "try_unwrap_list",
                        ),
                    ),
                    val @ ServiceCommand::Restart(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Restart",
                            "try_unwrap_list",
                        ),
                    ),
                    val @ ServiceCommand::List(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "List",
                            "try_unwrap_list",
                        ),
                    ),
                    val @ ServiceCommand::Status(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Status",
                            "try_unwrap_list",
                        ),
                    ),
                    val @ ServiceCommand::Add(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Add",
                            "try_unwrap_list",
                        ),
                    ),
                    val @ ServiceCommand::Remove(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Remove",
                            "try_unwrap_list",
                        ),
                    ),
                    val @ ServiceCommand::ConfigGet(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "ConfigGet",
                            "try_unwrap_list",
                        ),
                    ),
                    val @ ServiceCommand::ConfigUpdate(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "ConfigUpdate",
                                "try_unwrap_list",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyAdd(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyAdd",
                                "try_unwrap_list",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyRemove(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyRemove",
                                "try_unwrap_list",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyList(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyList",
                                "try_unwrap_list",
                            ),
                        )
                    }
                    val @ ServiceCommand::GitCheckout(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "GitCheckout",
                                "try_unwrap_list",
                            ),
                        )
                    }
                    val @ ServiceCommand::GitStatus(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "GitStatus",
                            "try_unwrap_list",
                        ),
                    ),
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Attempts to unwrap this reference to the `ServiceCommand::List` variant.
        */
        ///Returns a [TryUnwrapError] with the original value if this value is of any other type.
        pub fn try_unwrap_list_ref(
            &self,
        ) -> derive_more::core::result::Result<
            (&ListServicesCommand),
            derive_more::TryUnwrapError<&Self>,
        > {
            match self {
                ServiceCommand::List(field_0) => derive_more::core::result::Result::Ok((field_0)),
                val @ _ => match val {
                    val @ ServiceCommand::Start(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Start",
                            "try_unwrap_list_ref",
                        ),
                    ),
                    val @ ServiceCommand::Stop(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Stop",
                            "try_unwrap_list_ref",
                        ),
                    ),
                    val @ ServiceCommand::Restart(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Restart",
                            "try_unwrap_list_ref",
                        ),
                    ),
                    val @ ServiceCommand::List(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "List",
                            "try_unwrap_list_ref",
                        ),
                    ),
                    val @ ServiceCommand::Status(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Status",
                            "try_unwrap_list_ref",
                        ),
                    ),
                    val @ ServiceCommand::Add(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Add",
                            "try_unwrap_list_ref",
                        ),
                    ),
                    val @ ServiceCommand::Remove(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Remove",
                            "try_unwrap_list_ref",
                        ),
                    ),
                    val @ ServiceCommand::ConfigGet(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "ConfigGet",
                            "try_unwrap_list_ref",
                        ),
                    ),
                    val @ ServiceCommand::ConfigUpdate(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "ConfigUpdate",
                                "try_unwrap_list_ref",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyAdd(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyAdd",
                                "try_unwrap_list_ref",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyRemove(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyRemove",
                                "try_unwrap_list_ref",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyList(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyList",
                                "try_unwrap_list_ref",
                            ),
                        )
                    }
                    val @ ServiceCommand::GitCheckout(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "GitCheckout",
                                "try_unwrap_list_ref",
                            ),
                        )
                    }
                    val @ ServiceCommand::GitStatus(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "GitStatus",
                            "try_unwrap_list_ref",
                        ),
                    ),
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Attempts to unwrap this mutable reference to the `ServiceCommand::List` variant.
        */
        ///Returns a [TryUnwrapError] with the original value if this value is of any other type.
        pub fn try_unwrap_list_mut(
            &mut self,
        ) -> derive_more::core::result::Result<
            (&mut ListServicesCommand),
            derive_more::TryUnwrapError<&mut Self>,
        > {
            match self {
                ServiceCommand::List(field_0) => derive_more::core::result::Result::Ok((field_0)),
                val @ _ => match val {
                    val @ ServiceCommand::Start(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Start",
                            "try_unwrap_list_mut",
                        ),
                    ),
                    val @ ServiceCommand::Stop(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Stop",
                            "try_unwrap_list_mut",
                        ),
                    ),
                    val @ ServiceCommand::Restart(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Restart",
                            "try_unwrap_list_mut",
                        ),
                    ),
                    val @ ServiceCommand::List(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "List",
                            "try_unwrap_list_mut",
                        ),
                    ),
                    val @ ServiceCommand::Status(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Status",
                            "try_unwrap_list_mut",
                        ),
                    ),
                    val @ ServiceCommand::Add(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Add",
                            "try_unwrap_list_mut",
                        ),
                    ),
                    val @ ServiceCommand::Remove(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Remove",
                            "try_unwrap_list_mut",
                        ),
                    ),
                    val @ ServiceCommand::ConfigGet(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "ConfigGet",
                            "try_unwrap_list_mut",
                        ),
                    ),
                    val @ ServiceCommand::ConfigUpdate(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "ConfigUpdate",
                                "try_unwrap_list_mut",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyAdd(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyAdd",
                                "try_unwrap_list_mut",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyRemove(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyRemove",
                                "try_unwrap_list_mut",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyList(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyList",
                                "try_unwrap_list_mut",
                            ),
                        )
                    }
                    val @ ServiceCommand::GitCheckout(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "GitCheckout",
                                "try_unwrap_list_mut",
                            ),
                        )
                    }
                    val @ ServiceCommand::GitStatus(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "GitStatus",
                            "try_unwrap_list_mut",
                        ),
                    ),
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Attempts to unwrap this value to the `ServiceCommand::Status` variant.
        */
        ///Returns a [TryUnwrapError] with the original value if this value is of any other type.
        pub fn try_unwrap_status(
            self,
        ) -> derive_more::core::result::Result<(GetServiceStatus), derive_more::TryUnwrapError<Self>>
        {
            match self {
                ServiceCommand::Status(field_0) => derive_more::core::result::Result::Ok((field_0)),
                val @ _ => match val {
                    val @ ServiceCommand::Start(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Start",
                            "try_unwrap_status",
                        ),
                    ),
                    val @ ServiceCommand::Stop(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Stop",
                            "try_unwrap_status",
                        ),
                    ),
                    val @ ServiceCommand::Restart(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Restart",
                            "try_unwrap_status",
                        ),
                    ),
                    val @ ServiceCommand::List(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "List",
                            "try_unwrap_status",
                        ),
                    ),
                    val @ ServiceCommand::Status(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Status",
                            "try_unwrap_status",
                        ),
                    ),
                    val @ ServiceCommand::Add(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Add",
                            "try_unwrap_status",
                        ),
                    ),
                    val @ ServiceCommand::Remove(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Remove",
                            "try_unwrap_status",
                        ),
                    ),
                    val @ ServiceCommand::ConfigGet(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "ConfigGet",
                            "try_unwrap_status",
                        ),
                    ),
                    val @ ServiceCommand::ConfigUpdate(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "ConfigUpdate",
                                "try_unwrap_status",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyAdd(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyAdd",
                                "try_unwrap_status",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyRemove(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyRemove",
                                "try_unwrap_status",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyList(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyList",
                                "try_unwrap_status",
                            ),
                        )
                    }
                    val @ ServiceCommand::GitCheckout(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "GitCheckout",
                                "try_unwrap_status",
                            ),
                        )
                    }
                    val @ ServiceCommand::GitStatus(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "GitStatus",
                            "try_unwrap_status",
                        ),
                    ),
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Attempts to unwrap this reference to the `ServiceCommand::Status` variant.
        */
        ///Returns a [TryUnwrapError] with the original value if this value is of any other type.
        pub fn try_unwrap_status_ref(
            &self,
        ) -> derive_more::core::result::Result<
            (&GetServiceStatus),
            derive_more::TryUnwrapError<&Self>,
        > {
            match self {
                ServiceCommand::Status(field_0) => derive_more::core::result::Result::Ok((field_0)),
                val @ _ => match val {
                    val @ ServiceCommand::Start(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Start",
                            "try_unwrap_status_ref",
                        ),
                    ),
                    val @ ServiceCommand::Stop(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Stop",
                            "try_unwrap_status_ref",
                        ),
                    ),
                    val @ ServiceCommand::Restart(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Restart",
                            "try_unwrap_status_ref",
                        ),
                    ),
                    val @ ServiceCommand::List(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "List",
                            "try_unwrap_status_ref",
                        ),
                    ),
                    val @ ServiceCommand::Status(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Status",
                            "try_unwrap_status_ref",
                        ),
                    ),
                    val @ ServiceCommand::Add(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Add",
                            "try_unwrap_status_ref",
                        ),
                    ),
                    val @ ServiceCommand::Remove(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Remove",
                            "try_unwrap_status_ref",
                        ),
                    ),
                    val @ ServiceCommand::ConfigGet(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "ConfigGet",
                            "try_unwrap_status_ref",
                        ),
                    ),
                    val @ ServiceCommand::ConfigUpdate(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "ConfigUpdate",
                                "try_unwrap_status_ref",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyAdd(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyAdd",
                                "try_unwrap_status_ref",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyRemove(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyRemove",
                                "try_unwrap_status_ref",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyList(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyList",
                                "try_unwrap_status_ref",
                            ),
                        )
                    }
                    val @ ServiceCommand::GitCheckout(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "GitCheckout",
                                "try_unwrap_status_ref",
                            ),
                        )
                    }
                    val @ ServiceCommand::GitStatus(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "GitStatus",
                            "try_unwrap_status_ref",
                        ),
                    ),
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Attempts to unwrap this mutable reference to the `ServiceCommand::Status` variant.
        */
        ///Returns a [TryUnwrapError] with the original value if this value is of any other type.
        pub fn try_unwrap_status_mut(
            &mut self,
        ) -> derive_more::core::result::Result<
            (&mut GetServiceStatus),
            derive_more::TryUnwrapError<&mut Self>,
        > {
            match self {
                ServiceCommand::Status(field_0) => derive_more::core::result::Result::Ok((field_0)),
                val @ _ => match val {
                    val @ ServiceCommand::Start(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Start",
                            "try_unwrap_status_mut",
                        ),
                    ),
                    val @ ServiceCommand::Stop(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Stop",
                            "try_unwrap_status_mut",
                        ),
                    ),
                    val @ ServiceCommand::Restart(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Restart",
                            "try_unwrap_status_mut",
                        ),
                    ),
                    val @ ServiceCommand::List(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "List",
                            "try_unwrap_status_mut",
                        ),
                    ),
                    val @ ServiceCommand::Status(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Status",
                            "try_unwrap_status_mut",
                        ),
                    ),
                    val @ ServiceCommand::Add(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Add",
                            "try_unwrap_status_mut",
                        ),
                    ),
                    val @ ServiceCommand::Remove(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Remove",
                            "try_unwrap_status_mut",
                        ),
                    ),
                    val @ ServiceCommand::ConfigGet(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "ConfigGet",
                            "try_unwrap_status_mut",
                        ),
                    ),
                    val @ ServiceCommand::ConfigUpdate(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "ConfigUpdate",
                                "try_unwrap_status_mut",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyAdd(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyAdd",
                                "try_unwrap_status_mut",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyRemove(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyRemove",
                                "try_unwrap_status_mut",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyList(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyList",
                                "try_unwrap_status_mut",
                            ),
                        )
                    }
                    val @ ServiceCommand::GitCheckout(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "GitCheckout",
                                "try_unwrap_status_mut",
                            ),
                        )
                    }
                    val @ ServiceCommand::GitStatus(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "GitStatus",
                            "try_unwrap_status_mut",
                        ),
                    ),
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Attempts to unwrap this value to the `ServiceCommand::Add` variant.
        */
        ///Returns a [TryUnwrapError] with the original value if this value is of any other type.
        pub fn try_unwrap_add(
            self,
        ) -> derive_more::core::result::Result<(AddServiceCommand), derive_more::TryUnwrapError<Self>>
        {
            match self {
                ServiceCommand::Add(field_0) => derive_more::core::result::Result::Ok((field_0)),
                val @ _ => match val {
                    val @ ServiceCommand::Start(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Start",
                            "try_unwrap_add",
                        ),
                    ),
                    val @ ServiceCommand::Stop(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Stop",
                            "try_unwrap_add",
                        ),
                    ),
                    val @ ServiceCommand::Restart(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Restart",
                            "try_unwrap_add",
                        ),
                    ),
                    val @ ServiceCommand::List(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "List",
                            "try_unwrap_add",
                        ),
                    ),
                    val @ ServiceCommand::Status(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Status",
                            "try_unwrap_add",
                        ),
                    ),
                    val @ ServiceCommand::Add(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Add",
                            "try_unwrap_add",
                        ),
                    ),
                    val @ ServiceCommand::Remove(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Remove",
                            "try_unwrap_add",
                        ),
                    ),
                    val @ ServiceCommand::ConfigGet(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "ConfigGet",
                            "try_unwrap_add",
                        ),
                    ),
                    val @ ServiceCommand::ConfigUpdate(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "ConfigUpdate",
                                "try_unwrap_add",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyAdd(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyAdd",
                                "try_unwrap_add",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyRemove(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyRemove",
                                "try_unwrap_add",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyList(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyList",
                                "try_unwrap_add",
                            ),
                        )
                    }
                    val @ ServiceCommand::GitCheckout(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "GitCheckout",
                                "try_unwrap_add",
                            ),
                        )
                    }
                    val @ ServiceCommand::GitStatus(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "GitStatus",
                            "try_unwrap_add",
                        ),
                    ),
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Attempts to unwrap this reference to the `ServiceCommand::Add` variant.
        */
        ///Returns a [TryUnwrapError] with the original value if this value is of any other type.
        pub fn try_unwrap_add_ref(
            &self,
        ) -> derive_more::core::result::Result<
            (&AddServiceCommand),
            derive_more::TryUnwrapError<&Self>,
        > {
            match self {
                ServiceCommand::Add(field_0) => derive_more::core::result::Result::Ok((field_0)),
                val @ _ => match val {
                    val @ ServiceCommand::Start(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Start",
                            "try_unwrap_add_ref",
                        ),
                    ),
                    val @ ServiceCommand::Stop(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Stop",
                            "try_unwrap_add_ref",
                        ),
                    ),
                    val @ ServiceCommand::Restart(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Restart",
                            "try_unwrap_add_ref",
                        ),
                    ),
                    val @ ServiceCommand::List(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "List",
                            "try_unwrap_add_ref",
                        ),
                    ),
                    val @ ServiceCommand::Status(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Status",
                            "try_unwrap_add_ref",
                        ),
                    ),
                    val @ ServiceCommand::Add(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Add",
                            "try_unwrap_add_ref",
                        ),
                    ),
                    val @ ServiceCommand::Remove(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Remove",
                            "try_unwrap_add_ref",
                        ),
                    ),
                    val @ ServiceCommand::ConfigGet(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "ConfigGet",
                            "try_unwrap_add_ref",
                        ),
                    ),
                    val @ ServiceCommand::ConfigUpdate(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "ConfigUpdate",
                                "try_unwrap_add_ref",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyAdd(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyAdd",
                                "try_unwrap_add_ref",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyRemove(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyRemove",
                                "try_unwrap_add_ref",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyList(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyList",
                                "try_unwrap_add_ref",
                            ),
                        )
                    }
                    val @ ServiceCommand::GitCheckout(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "GitCheckout",
                                "try_unwrap_add_ref",
                            ),
                        )
                    }
                    val @ ServiceCommand::GitStatus(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "GitStatus",
                            "try_unwrap_add_ref",
                        ),
                    ),
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Attempts to unwrap this mutable reference to the `ServiceCommand::Add` variant.
        */
        ///Returns a [TryUnwrapError] with the original value if this value is of any other type.
        pub fn try_unwrap_add_mut(
            &mut self,
        ) -> derive_more::core::result::Result<
            (&mut AddServiceCommand),
            derive_more::TryUnwrapError<&mut Self>,
        > {
            match self {
                ServiceCommand::Add(field_0) => derive_more::core::result::Result::Ok((field_0)),
                val @ _ => match val {
                    val @ ServiceCommand::Start(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Start",
                            "try_unwrap_add_mut",
                        ),
                    ),
                    val @ ServiceCommand::Stop(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Stop",
                            "try_unwrap_add_mut",
                        ),
                    ),
                    val @ ServiceCommand::Restart(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Restart",
                            "try_unwrap_add_mut",
                        ),
                    ),
                    val @ ServiceCommand::List(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "List",
                            "try_unwrap_add_mut",
                        ),
                    ),
                    val @ ServiceCommand::Status(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Status",
                            "try_unwrap_add_mut",
                        ),
                    ),
                    val @ ServiceCommand::Add(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Add",
                            "try_unwrap_add_mut",
                        ),
                    ),
                    val @ ServiceCommand::Remove(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Remove",
                            "try_unwrap_add_mut",
                        ),
                    ),
                    val @ ServiceCommand::ConfigGet(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "ConfigGet",
                            "try_unwrap_add_mut",
                        ),
                    ),
                    val @ ServiceCommand::ConfigUpdate(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "ConfigUpdate",
                                "try_unwrap_add_mut",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyAdd(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyAdd",
                                "try_unwrap_add_mut",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyRemove(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyRemove",
                                "try_unwrap_add_mut",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyList(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyList",
                                "try_unwrap_add_mut",
                            ),
                        )
                    }
                    val @ ServiceCommand::GitCheckout(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "GitCheckout",
                                "try_unwrap_add_mut",
                            ),
                        )
                    }
                    val @ ServiceCommand::GitStatus(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "GitStatus",
                            "try_unwrap_add_mut",
                        ),
                    ),
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Attempts to unwrap this value to the `ServiceCommand::Remove` variant.
        */
        ///Returns a [TryUnwrapError] with the original value if this value is of any other type.
        pub fn try_unwrap_remove(
            self,
        ) -> derive_more::core::result::Result<
            (RemoveServiceCommand),
            derive_more::TryUnwrapError<Self>,
        > {
            match self {
                ServiceCommand::Remove(field_0) => derive_more::core::result::Result::Ok((field_0)),
                val @ _ => match val {
                    val @ ServiceCommand::Start(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Start",
                            "try_unwrap_remove",
                        ),
                    ),
                    val @ ServiceCommand::Stop(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Stop",
                            "try_unwrap_remove",
                        ),
                    ),
                    val @ ServiceCommand::Restart(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Restart",
                            "try_unwrap_remove",
                        ),
                    ),
                    val @ ServiceCommand::List(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "List",
                            "try_unwrap_remove",
                        ),
                    ),
                    val @ ServiceCommand::Status(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Status",
                            "try_unwrap_remove",
                        ),
                    ),
                    val @ ServiceCommand::Add(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Add",
                            "try_unwrap_remove",
                        ),
                    ),
                    val @ ServiceCommand::Remove(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Remove",
                            "try_unwrap_remove",
                        ),
                    ),
                    val @ ServiceCommand::ConfigGet(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "ConfigGet",
                            "try_unwrap_remove",
                        ),
                    ),
                    val @ ServiceCommand::ConfigUpdate(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "ConfigUpdate",
                                "try_unwrap_remove",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyAdd(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyAdd",
                                "try_unwrap_remove",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyRemove(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyRemove",
                                "try_unwrap_remove",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyList(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyList",
                                "try_unwrap_remove",
                            ),
                        )
                    }
                    val @ ServiceCommand::GitCheckout(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "GitCheckout",
                                "try_unwrap_remove",
                            ),
                        )
                    }
                    val @ ServiceCommand::GitStatus(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "GitStatus",
                            "try_unwrap_remove",
                        ),
                    ),
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Attempts to unwrap this reference to the `ServiceCommand::Remove` variant.
        */
        ///Returns a [TryUnwrapError] with the original value if this value is of any other type.
        pub fn try_unwrap_remove_ref(
            &self,
        ) -> derive_more::core::result::Result<
            (&RemoveServiceCommand),
            derive_more::TryUnwrapError<&Self>,
        > {
            match self {
                ServiceCommand::Remove(field_0) => derive_more::core::result::Result::Ok((field_0)),
                val @ _ => match val {
                    val @ ServiceCommand::Start(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Start",
                            "try_unwrap_remove_ref",
                        ),
                    ),
                    val @ ServiceCommand::Stop(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Stop",
                            "try_unwrap_remove_ref",
                        ),
                    ),
                    val @ ServiceCommand::Restart(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Restart",
                            "try_unwrap_remove_ref",
                        ),
                    ),
                    val @ ServiceCommand::List(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "List",
                            "try_unwrap_remove_ref",
                        ),
                    ),
                    val @ ServiceCommand::Status(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Status",
                            "try_unwrap_remove_ref",
                        ),
                    ),
                    val @ ServiceCommand::Add(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Add",
                            "try_unwrap_remove_ref",
                        ),
                    ),
                    val @ ServiceCommand::Remove(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Remove",
                            "try_unwrap_remove_ref",
                        ),
                    ),
                    val @ ServiceCommand::ConfigGet(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "ConfigGet",
                            "try_unwrap_remove_ref",
                        ),
                    ),
                    val @ ServiceCommand::ConfigUpdate(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "ConfigUpdate",
                                "try_unwrap_remove_ref",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyAdd(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyAdd",
                                "try_unwrap_remove_ref",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyRemove(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyRemove",
                                "try_unwrap_remove_ref",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyList(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyList",
                                "try_unwrap_remove_ref",
                            ),
                        )
                    }
                    val @ ServiceCommand::GitCheckout(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "GitCheckout",
                                "try_unwrap_remove_ref",
                            ),
                        )
                    }
                    val @ ServiceCommand::GitStatus(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "GitStatus",
                            "try_unwrap_remove_ref",
                        ),
                    ),
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Attempts to unwrap this mutable reference to the `ServiceCommand::Remove` variant.
        */
        ///Returns a [TryUnwrapError] with the original value if this value is of any other type.
        pub fn try_unwrap_remove_mut(
            &mut self,
        ) -> derive_more::core::result::Result<
            (&mut RemoveServiceCommand),
            derive_more::TryUnwrapError<&mut Self>,
        > {
            match self {
                ServiceCommand::Remove(field_0) => derive_more::core::result::Result::Ok((field_0)),
                val @ _ => match val {
                    val @ ServiceCommand::Start(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Start",
                            "try_unwrap_remove_mut",
                        ),
                    ),
                    val @ ServiceCommand::Stop(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Stop",
                            "try_unwrap_remove_mut",
                        ),
                    ),
                    val @ ServiceCommand::Restart(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Restart",
                            "try_unwrap_remove_mut",
                        ),
                    ),
                    val @ ServiceCommand::List(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "List",
                            "try_unwrap_remove_mut",
                        ),
                    ),
                    val @ ServiceCommand::Status(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Status",
                            "try_unwrap_remove_mut",
                        ),
                    ),
                    val @ ServiceCommand::Add(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Add",
                            "try_unwrap_remove_mut",
                        ),
                    ),
                    val @ ServiceCommand::Remove(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Remove",
                            "try_unwrap_remove_mut",
                        ),
                    ),
                    val @ ServiceCommand::ConfigGet(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "ConfigGet",
                            "try_unwrap_remove_mut",
                        ),
                    ),
                    val @ ServiceCommand::ConfigUpdate(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "ConfigUpdate",
                                "try_unwrap_remove_mut",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyAdd(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyAdd",
                                "try_unwrap_remove_mut",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyRemove(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyRemove",
                                "try_unwrap_remove_mut",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyList(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyList",
                                "try_unwrap_remove_mut",
                            ),
                        )
                    }
                    val @ ServiceCommand::GitCheckout(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "GitCheckout",
                                "try_unwrap_remove_mut",
                            ),
                        )
                    }
                    val @ ServiceCommand::GitStatus(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "GitStatus",
                            "try_unwrap_remove_mut",
                        ),
                    ),
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Attempts to unwrap this value to the `ServiceCommand::ConfigGet` variant.
        */
        ///Returns a [TryUnwrapError] with the original value if this value is of any other type.
        pub fn try_unwrap_config_get(
            self,
        ) -> derive_more::core::result::Result<(GetConfig), derive_more::TryUnwrapError<Self>>
        {
            match self {
                ServiceCommand::ConfigGet(field_0) => {
                    derive_more::core::result::Result::Ok((field_0))
                }
                val @ _ => match val {
                    val @ ServiceCommand::Start(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Start",
                            "try_unwrap_config_get",
                        ),
                    ),
                    val @ ServiceCommand::Stop(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Stop",
                            "try_unwrap_config_get",
                        ),
                    ),
                    val @ ServiceCommand::Restart(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Restart",
                            "try_unwrap_config_get",
                        ),
                    ),
                    val @ ServiceCommand::List(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "List",
                            "try_unwrap_config_get",
                        ),
                    ),
                    val @ ServiceCommand::Status(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Status",
                            "try_unwrap_config_get",
                        ),
                    ),
                    val @ ServiceCommand::Add(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Add",
                            "try_unwrap_config_get",
                        ),
                    ),
                    val @ ServiceCommand::Remove(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Remove",
                            "try_unwrap_config_get",
                        ),
                    ),
                    val @ ServiceCommand::ConfigGet(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "ConfigGet",
                            "try_unwrap_config_get",
                        ),
                    ),
                    val @ ServiceCommand::ConfigUpdate(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "ConfigUpdate",
                                "try_unwrap_config_get",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyAdd(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyAdd",
                                "try_unwrap_config_get",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyRemove(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyRemove",
                                "try_unwrap_config_get",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyList(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyList",
                                "try_unwrap_config_get",
                            ),
                        )
                    }
                    val @ ServiceCommand::GitCheckout(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "GitCheckout",
                                "try_unwrap_config_get",
                            ),
                        )
                    }
                    val @ ServiceCommand::GitStatus(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "GitStatus",
                            "try_unwrap_config_get",
                        ),
                    ),
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Attempts to unwrap this reference to the `ServiceCommand::ConfigGet` variant.
        */
        ///Returns a [TryUnwrapError] with the original value if this value is of any other type.
        pub fn try_unwrap_config_get_ref(
            &self,
        ) -> derive_more::core::result::Result<(&GetConfig), derive_more::TryUnwrapError<&Self>>
        {
            match self {
                ServiceCommand::ConfigGet(field_0) => {
                    derive_more::core::result::Result::Ok((field_0))
                }
                val @ _ => match val {
                    val @ ServiceCommand::Start(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Start",
                            "try_unwrap_config_get_ref",
                        ),
                    ),
                    val @ ServiceCommand::Stop(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Stop",
                            "try_unwrap_config_get_ref",
                        ),
                    ),
                    val @ ServiceCommand::Restart(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Restart",
                            "try_unwrap_config_get_ref",
                        ),
                    ),
                    val @ ServiceCommand::List(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "List",
                            "try_unwrap_config_get_ref",
                        ),
                    ),
                    val @ ServiceCommand::Status(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Status",
                            "try_unwrap_config_get_ref",
                        ),
                    ),
                    val @ ServiceCommand::Add(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Add",
                            "try_unwrap_config_get_ref",
                        ),
                    ),
                    val @ ServiceCommand::Remove(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Remove",
                            "try_unwrap_config_get_ref",
                        ),
                    ),
                    val @ ServiceCommand::ConfigGet(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "ConfigGet",
                            "try_unwrap_config_get_ref",
                        ),
                    ),
                    val @ ServiceCommand::ConfigUpdate(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "ConfigUpdate",
                                "try_unwrap_config_get_ref",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyAdd(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyAdd",
                                "try_unwrap_config_get_ref",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyRemove(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyRemove",
                                "try_unwrap_config_get_ref",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyList(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyList",
                                "try_unwrap_config_get_ref",
                            ),
                        )
                    }
                    val @ ServiceCommand::GitCheckout(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "GitCheckout",
                                "try_unwrap_config_get_ref",
                            ),
                        )
                    }
                    val @ ServiceCommand::GitStatus(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "GitStatus",
                            "try_unwrap_config_get_ref",
                        ),
                    ),
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Attempts to unwrap this mutable reference to the `ServiceCommand::ConfigGet` variant.
        */
        ///Returns a [TryUnwrapError] with the original value if this value is of any other type.
        pub fn try_unwrap_config_get_mut(
            &mut self,
        ) -> derive_more::core::result::Result<
            (&mut GetConfig),
            derive_more::TryUnwrapError<&mut Self>,
        > {
            match self {
                ServiceCommand::ConfigGet(field_0) => {
                    derive_more::core::result::Result::Ok((field_0))
                }
                val @ _ => match val {
                    val @ ServiceCommand::Start(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Start",
                            "try_unwrap_config_get_mut",
                        ),
                    ),
                    val @ ServiceCommand::Stop(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Stop",
                            "try_unwrap_config_get_mut",
                        ),
                    ),
                    val @ ServiceCommand::Restart(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Restart",
                            "try_unwrap_config_get_mut",
                        ),
                    ),
                    val @ ServiceCommand::List(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "List",
                            "try_unwrap_config_get_mut",
                        ),
                    ),
                    val @ ServiceCommand::Status(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Status",
                            "try_unwrap_config_get_mut",
                        ),
                    ),
                    val @ ServiceCommand::Add(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Add",
                            "try_unwrap_config_get_mut",
                        ),
                    ),
                    val @ ServiceCommand::Remove(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Remove",
                            "try_unwrap_config_get_mut",
                        ),
                    ),
                    val @ ServiceCommand::ConfigGet(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "ConfigGet",
                            "try_unwrap_config_get_mut",
                        ),
                    ),
                    val @ ServiceCommand::ConfigUpdate(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "ConfigUpdate",
                                "try_unwrap_config_get_mut",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyAdd(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyAdd",
                                "try_unwrap_config_get_mut",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyRemove(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyRemove",
                                "try_unwrap_config_get_mut",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyList(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyList",
                                "try_unwrap_config_get_mut",
                            ),
                        )
                    }
                    val @ ServiceCommand::GitCheckout(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "GitCheckout",
                                "try_unwrap_config_get_mut",
                            ),
                        )
                    }
                    val @ ServiceCommand::GitStatus(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "GitStatus",
                            "try_unwrap_config_get_mut",
                        ),
                    ),
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Attempts to unwrap this value to the `ServiceCommand::ConfigUpdate` variant.
        */
        ///Returns a [TryUnwrapError] with the original value if this value is of any other type.
        pub fn try_unwrap_config_update(
            self,
        ) -> derive_more::core::result::Result<
            (UpdateConfigCommand),
            derive_more::TryUnwrapError<Self>,
        > {
            match self {
                ServiceCommand::ConfigUpdate(field_0) => {
                    derive_more::core::result::Result::Ok((field_0))
                }
                val @ _ => match val {
                    val @ ServiceCommand::Start(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Start",
                            "try_unwrap_config_update",
                        ),
                    ),
                    val @ ServiceCommand::Stop(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Stop",
                            "try_unwrap_config_update",
                        ),
                    ),
                    val @ ServiceCommand::Restart(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Restart",
                            "try_unwrap_config_update",
                        ),
                    ),
                    val @ ServiceCommand::List(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "List",
                            "try_unwrap_config_update",
                        ),
                    ),
                    val @ ServiceCommand::Status(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Status",
                            "try_unwrap_config_update",
                        ),
                    ),
                    val @ ServiceCommand::Add(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Add",
                            "try_unwrap_config_update",
                        ),
                    ),
                    val @ ServiceCommand::Remove(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Remove",
                            "try_unwrap_config_update",
                        ),
                    ),
                    val @ ServiceCommand::ConfigGet(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "ConfigGet",
                            "try_unwrap_config_update",
                        ),
                    ),
                    val @ ServiceCommand::ConfigUpdate(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "ConfigUpdate",
                                "try_unwrap_config_update",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyAdd(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyAdd",
                                "try_unwrap_config_update",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyRemove(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyRemove",
                                "try_unwrap_config_update",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyList(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyList",
                                "try_unwrap_config_update",
                            ),
                        )
                    }
                    val @ ServiceCommand::GitCheckout(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "GitCheckout",
                                "try_unwrap_config_update",
                            ),
                        )
                    }
                    val @ ServiceCommand::GitStatus(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "GitStatus",
                            "try_unwrap_config_update",
                        ),
                    ),
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Attempts to unwrap this reference to the `ServiceCommand::ConfigUpdate` variant.
        */
        ///Returns a [TryUnwrapError] with the original value if this value is of any other type.
        pub fn try_unwrap_config_update_ref(
            &self,
        ) -> derive_more::core::result::Result<
            (&UpdateConfigCommand),
            derive_more::TryUnwrapError<&Self>,
        > {
            match self {
                ServiceCommand::ConfigUpdate(field_0) => {
                    derive_more::core::result::Result::Ok((field_0))
                }
                val @ _ => match val {
                    val @ ServiceCommand::Start(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Start",
                            "try_unwrap_config_update_ref",
                        ),
                    ),
                    val @ ServiceCommand::Stop(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Stop",
                            "try_unwrap_config_update_ref",
                        ),
                    ),
                    val @ ServiceCommand::Restart(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Restart",
                            "try_unwrap_config_update_ref",
                        ),
                    ),
                    val @ ServiceCommand::List(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "List",
                            "try_unwrap_config_update_ref",
                        ),
                    ),
                    val @ ServiceCommand::Status(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Status",
                            "try_unwrap_config_update_ref",
                        ),
                    ),
                    val @ ServiceCommand::Add(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Add",
                            "try_unwrap_config_update_ref",
                        ),
                    ),
                    val @ ServiceCommand::Remove(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Remove",
                            "try_unwrap_config_update_ref",
                        ),
                    ),
                    val @ ServiceCommand::ConfigGet(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "ConfigGet",
                            "try_unwrap_config_update_ref",
                        ),
                    ),
                    val @ ServiceCommand::ConfigUpdate(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "ConfigUpdate",
                                "try_unwrap_config_update_ref",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyAdd(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyAdd",
                                "try_unwrap_config_update_ref",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyRemove(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyRemove",
                                "try_unwrap_config_update_ref",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyList(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyList",
                                "try_unwrap_config_update_ref",
                            ),
                        )
                    }
                    val @ ServiceCommand::GitCheckout(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "GitCheckout",
                                "try_unwrap_config_update_ref",
                            ),
                        )
                    }
                    val @ ServiceCommand::GitStatus(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "GitStatus",
                            "try_unwrap_config_update_ref",
                        ),
                    ),
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Attempts to unwrap this mutable reference to the `ServiceCommand::ConfigUpdate` variant.
        */
        ///Returns a [TryUnwrapError] with the original value if this value is of any other type.
        pub fn try_unwrap_config_update_mut(
            &mut self,
        ) -> derive_more::core::result::Result<
            (&mut UpdateConfigCommand),
            derive_more::TryUnwrapError<&mut Self>,
        > {
            match self {
                ServiceCommand::ConfigUpdate(field_0) => {
                    derive_more::core::result::Result::Ok((field_0))
                }
                val @ _ => match val {
                    val @ ServiceCommand::Start(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Start",
                            "try_unwrap_config_update_mut",
                        ),
                    ),
                    val @ ServiceCommand::Stop(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Stop",
                            "try_unwrap_config_update_mut",
                        ),
                    ),
                    val @ ServiceCommand::Restart(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Restart",
                            "try_unwrap_config_update_mut",
                        ),
                    ),
                    val @ ServiceCommand::List(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "List",
                            "try_unwrap_config_update_mut",
                        ),
                    ),
                    val @ ServiceCommand::Status(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Status",
                            "try_unwrap_config_update_mut",
                        ),
                    ),
                    val @ ServiceCommand::Add(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Add",
                            "try_unwrap_config_update_mut",
                        ),
                    ),
                    val @ ServiceCommand::Remove(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Remove",
                            "try_unwrap_config_update_mut",
                        ),
                    ),
                    val @ ServiceCommand::ConfigGet(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "ConfigGet",
                            "try_unwrap_config_update_mut",
                        ),
                    ),
                    val @ ServiceCommand::ConfigUpdate(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "ConfigUpdate",
                                "try_unwrap_config_update_mut",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyAdd(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyAdd",
                                "try_unwrap_config_update_mut",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyRemove(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyRemove",
                                "try_unwrap_config_update_mut",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyList(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyList",
                                "try_unwrap_config_update_mut",
                            ),
                        )
                    }
                    val @ ServiceCommand::GitCheckout(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "GitCheckout",
                                "try_unwrap_config_update_mut",
                            ),
                        )
                    }
                    val @ ServiceCommand::GitStatus(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "GitStatus",
                            "try_unwrap_config_update_mut",
                        ),
                    ),
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Attempts to unwrap this value to the `ServiceCommand::DependencyAdd` variant.
        */
        ///Returns a [TryUnwrapError] with the original value if this value is of any other type.
        pub fn try_unwrap_dependency_add(
            self,
        ) -> derive_more::core::result::Result<
            (AddDependencyCommand),
            derive_more::TryUnwrapError<Self>,
        > {
            match self {
                ServiceCommand::DependencyAdd(field_0) => {
                    derive_more::core::result::Result::Ok((field_0))
                }
                val @ _ => match val {
                    val @ ServiceCommand::Start(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Start",
                            "try_unwrap_dependency_add",
                        ),
                    ),
                    val @ ServiceCommand::Stop(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Stop",
                            "try_unwrap_dependency_add",
                        ),
                    ),
                    val @ ServiceCommand::Restart(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Restart",
                            "try_unwrap_dependency_add",
                        ),
                    ),
                    val @ ServiceCommand::List(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "List",
                            "try_unwrap_dependency_add",
                        ),
                    ),
                    val @ ServiceCommand::Status(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Status",
                            "try_unwrap_dependency_add",
                        ),
                    ),
                    val @ ServiceCommand::Add(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Add",
                            "try_unwrap_dependency_add",
                        ),
                    ),
                    val @ ServiceCommand::Remove(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Remove",
                            "try_unwrap_dependency_add",
                        ),
                    ),
                    val @ ServiceCommand::ConfigGet(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "ConfigGet",
                            "try_unwrap_dependency_add",
                        ),
                    ),
                    val @ ServiceCommand::ConfigUpdate(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "ConfigUpdate",
                                "try_unwrap_dependency_add",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyAdd(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyAdd",
                                "try_unwrap_dependency_add",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyRemove(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyRemove",
                                "try_unwrap_dependency_add",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyList(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyList",
                                "try_unwrap_dependency_add",
                            ),
                        )
                    }
                    val @ ServiceCommand::GitCheckout(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "GitCheckout",
                                "try_unwrap_dependency_add",
                            ),
                        )
                    }
                    val @ ServiceCommand::GitStatus(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "GitStatus",
                            "try_unwrap_dependency_add",
                        ),
                    ),
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Attempts to unwrap this reference to the `ServiceCommand::DependencyAdd` variant.
        */
        ///Returns a [TryUnwrapError] with the original value if this value is of any other type.
        pub fn try_unwrap_dependency_add_ref(
            &self,
        ) -> derive_more::core::result::Result<
            (&AddDependencyCommand),
            derive_more::TryUnwrapError<&Self>,
        > {
            match self {
                ServiceCommand::DependencyAdd(field_0) => {
                    derive_more::core::result::Result::Ok((field_0))
                }
                val @ _ => match val {
                    val @ ServiceCommand::Start(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Start",
                            "try_unwrap_dependency_add_ref",
                        ),
                    ),
                    val @ ServiceCommand::Stop(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Stop",
                            "try_unwrap_dependency_add_ref",
                        ),
                    ),
                    val @ ServiceCommand::Restart(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Restart",
                            "try_unwrap_dependency_add_ref",
                        ),
                    ),
                    val @ ServiceCommand::List(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "List",
                            "try_unwrap_dependency_add_ref",
                        ),
                    ),
                    val @ ServiceCommand::Status(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Status",
                            "try_unwrap_dependency_add_ref",
                        ),
                    ),
                    val @ ServiceCommand::Add(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Add",
                            "try_unwrap_dependency_add_ref",
                        ),
                    ),
                    val @ ServiceCommand::Remove(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Remove",
                            "try_unwrap_dependency_add_ref",
                        ),
                    ),
                    val @ ServiceCommand::ConfigGet(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "ConfigGet",
                            "try_unwrap_dependency_add_ref",
                        ),
                    ),
                    val @ ServiceCommand::ConfigUpdate(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "ConfigUpdate",
                                "try_unwrap_dependency_add_ref",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyAdd(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyAdd",
                                "try_unwrap_dependency_add_ref",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyRemove(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyRemove",
                                "try_unwrap_dependency_add_ref",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyList(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyList",
                                "try_unwrap_dependency_add_ref",
                            ),
                        )
                    }
                    val @ ServiceCommand::GitCheckout(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "GitCheckout",
                                "try_unwrap_dependency_add_ref",
                            ),
                        )
                    }
                    val @ ServiceCommand::GitStatus(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "GitStatus",
                            "try_unwrap_dependency_add_ref",
                        ),
                    ),
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Attempts to unwrap this mutable reference to the `ServiceCommand::DependencyAdd` variant.
        */
        ///Returns a [TryUnwrapError] with the original value if this value is of any other type.
        pub fn try_unwrap_dependency_add_mut(
            &mut self,
        ) -> derive_more::core::result::Result<
            (&mut AddDependencyCommand),
            derive_more::TryUnwrapError<&mut Self>,
        > {
            match self {
                ServiceCommand::DependencyAdd(field_0) => {
                    derive_more::core::result::Result::Ok((field_0))
                }
                val @ _ => match val {
                    val @ ServiceCommand::Start(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Start",
                            "try_unwrap_dependency_add_mut",
                        ),
                    ),
                    val @ ServiceCommand::Stop(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Stop",
                            "try_unwrap_dependency_add_mut",
                        ),
                    ),
                    val @ ServiceCommand::Restart(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Restart",
                            "try_unwrap_dependency_add_mut",
                        ),
                    ),
                    val @ ServiceCommand::List(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "List",
                            "try_unwrap_dependency_add_mut",
                        ),
                    ),
                    val @ ServiceCommand::Status(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Status",
                            "try_unwrap_dependency_add_mut",
                        ),
                    ),
                    val @ ServiceCommand::Add(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Add",
                            "try_unwrap_dependency_add_mut",
                        ),
                    ),
                    val @ ServiceCommand::Remove(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Remove",
                            "try_unwrap_dependency_add_mut",
                        ),
                    ),
                    val @ ServiceCommand::ConfigGet(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "ConfigGet",
                            "try_unwrap_dependency_add_mut",
                        ),
                    ),
                    val @ ServiceCommand::ConfigUpdate(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "ConfigUpdate",
                                "try_unwrap_dependency_add_mut",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyAdd(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyAdd",
                                "try_unwrap_dependency_add_mut",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyRemove(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyRemove",
                                "try_unwrap_dependency_add_mut",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyList(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyList",
                                "try_unwrap_dependency_add_mut",
                            ),
                        )
                    }
                    val @ ServiceCommand::GitCheckout(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "GitCheckout",
                                "try_unwrap_dependency_add_mut",
                            ),
                        )
                    }
                    val @ ServiceCommand::GitStatus(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "GitStatus",
                            "try_unwrap_dependency_add_mut",
                        ),
                    ),
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Attempts to unwrap this value to the `ServiceCommand::DependencyRemove` variant.
        */
        ///Returns a [TryUnwrapError] with the original value if this value is of any other type.
        pub fn try_unwrap_dependency_remove(
            self,
        ) -> derive_more::core::result::Result<
            (RemoveDependencyCommand),
            derive_more::TryUnwrapError<Self>,
        > {
            match self {
                ServiceCommand::DependencyRemove(field_0) => {
                    derive_more::core::result::Result::Ok((field_0))
                }
                val @ _ => match val {
                    val @ ServiceCommand::Start(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Start",
                            "try_unwrap_dependency_remove",
                        ),
                    ),
                    val @ ServiceCommand::Stop(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Stop",
                            "try_unwrap_dependency_remove",
                        ),
                    ),
                    val @ ServiceCommand::Restart(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Restart",
                            "try_unwrap_dependency_remove",
                        ),
                    ),
                    val @ ServiceCommand::List(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "List",
                            "try_unwrap_dependency_remove",
                        ),
                    ),
                    val @ ServiceCommand::Status(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Status",
                            "try_unwrap_dependency_remove",
                        ),
                    ),
                    val @ ServiceCommand::Add(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Add",
                            "try_unwrap_dependency_remove",
                        ),
                    ),
                    val @ ServiceCommand::Remove(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Remove",
                            "try_unwrap_dependency_remove",
                        ),
                    ),
                    val @ ServiceCommand::ConfigGet(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "ConfigGet",
                            "try_unwrap_dependency_remove",
                        ),
                    ),
                    val @ ServiceCommand::ConfigUpdate(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "ConfigUpdate",
                                "try_unwrap_dependency_remove",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyAdd(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyAdd",
                                "try_unwrap_dependency_remove",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyRemove(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyRemove",
                                "try_unwrap_dependency_remove",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyList(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyList",
                                "try_unwrap_dependency_remove",
                            ),
                        )
                    }
                    val @ ServiceCommand::GitCheckout(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "GitCheckout",
                                "try_unwrap_dependency_remove",
                            ),
                        )
                    }
                    val @ ServiceCommand::GitStatus(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "GitStatus",
                            "try_unwrap_dependency_remove",
                        ),
                    ),
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Attempts to unwrap this reference to the `ServiceCommand::DependencyRemove` variant.
        */
        ///Returns a [TryUnwrapError] with the original value if this value is of any other type.
        pub fn try_unwrap_dependency_remove_ref(
            &self,
        ) -> derive_more::core::result::Result<
            (&RemoveDependencyCommand),
            derive_more::TryUnwrapError<&Self>,
        > {
            match self {
                ServiceCommand::DependencyRemove(field_0) => {
                    derive_more::core::result::Result::Ok((field_0))
                }
                val @ _ => match val {
                    val @ ServiceCommand::Start(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Start",
                            "try_unwrap_dependency_remove_ref",
                        ),
                    ),
                    val @ ServiceCommand::Stop(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Stop",
                            "try_unwrap_dependency_remove_ref",
                        ),
                    ),
                    val @ ServiceCommand::Restart(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Restart",
                            "try_unwrap_dependency_remove_ref",
                        ),
                    ),
                    val @ ServiceCommand::List(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "List",
                            "try_unwrap_dependency_remove_ref",
                        ),
                    ),
                    val @ ServiceCommand::Status(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Status",
                            "try_unwrap_dependency_remove_ref",
                        ),
                    ),
                    val @ ServiceCommand::Add(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Add",
                            "try_unwrap_dependency_remove_ref",
                        ),
                    ),
                    val @ ServiceCommand::Remove(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Remove",
                            "try_unwrap_dependency_remove_ref",
                        ),
                    ),
                    val @ ServiceCommand::ConfigGet(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "ConfigGet",
                            "try_unwrap_dependency_remove_ref",
                        ),
                    ),
                    val @ ServiceCommand::ConfigUpdate(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "ConfigUpdate",
                                "try_unwrap_dependency_remove_ref",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyAdd(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyAdd",
                                "try_unwrap_dependency_remove_ref",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyRemove(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyRemove",
                                "try_unwrap_dependency_remove_ref",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyList(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyList",
                                "try_unwrap_dependency_remove_ref",
                            ),
                        )
                    }
                    val @ ServiceCommand::GitCheckout(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "GitCheckout",
                                "try_unwrap_dependency_remove_ref",
                            ),
                        )
                    }
                    val @ ServiceCommand::GitStatus(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "GitStatus",
                            "try_unwrap_dependency_remove_ref",
                        ),
                    ),
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Attempts to unwrap this mutable reference to the `ServiceCommand::DependencyRemove` variant.
        */
        ///Returns a [TryUnwrapError] with the original value if this value is of any other type.
        pub fn try_unwrap_dependency_remove_mut(
            &mut self,
        ) -> derive_more::core::result::Result<
            (&mut RemoveDependencyCommand),
            derive_more::TryUnwrapError<&mut Self>,
        > {
            match self {
                ServiceCommand::DependencyRemove(field_0) => {
                    derive_more::core::result::Result::Ok((field_0))
                }
                val @ _ => match val {
                    val @ ServiceCommand::Start(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Start",
                            "try_unwrap_dependency_remove_mut",
                        ),
                    ),
                    val @ ServiceCommand::Stop(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Stop",
                            "try_unwrap_dependency_remove_mut",
                        ),
                    ),
                    val @ ServiceCommand::Restart(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Restart",
                            "try_unwrap_dependency_remove_mut",
                        ),
                    ),
                    val @ ServiceCommand::List(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "List",
                            "try_unwrap_dependency_remove_mut",
                        ),
                    ),
                    val @ ServiceCommand::Status(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Status",
                            "try_unwrap_dependency_remove_mut",
                        ),
                    ),
                    val @ ServiceCommand::Add(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Add",
                            "try_unwrap_dependency_remove_mut",
                        ),
                    ),
                    val @ ServiceCommand::Remove(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Remove",
                            "try_unwrap_dependency_remove_mut",
                        ),
                    ),
                    val @ ServiceCommand::ConfigGet(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "ConfigGet",
                            "try_unwrap_dependency_remove_mut",
                        ),
                    ),
                    val @ ServiceCommand::ConfigUpdate(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "ConfigUpdate",
                                "try_unwrap_dependency_remove_mut",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyAdd(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyAdd",
                                "try_unwrap_dependency_remove_mut",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyRemove(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyRemove",
                                "try_unwrap_dependency_remove_mut",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyList(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyList",
                                "try_unwrap_dependency_remove_mut",
                            ),
                        )
                    }
                    val @ ServiceCommand::GitCheckout(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "GitCheckout",
                                "try_unwrap_dependency_remove_mut",
                            ),
                        )
                    }
                    val @ ServiceCommand::GitStatus(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "GitStatus",
                            "try_unwrap_dependency_remove_mut",
                        ),
                    ),
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Attempts to unwrap this value to the `ServiceCommand::DependencyList` variant.
        */
        ///Returns a [TryUnwrapError] with the original value if this value is of any other type.
        pub fn try_unwrap_dependency_list(
            self,
        ) -> derive_more::core::result::Result<
            (ListDependenciesCommand),
            derive_more::TryUnwrapError<Self>,
        > {
            match self {
                ServiceCommand::DependencyList(field_0) => {
                    derive_more::core::result::Result::Ok((field_0))
                }
                val @ _ => match val {
                    val @ ServiceCommand::Start(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Start",
                            "try_unwrap_dependency_list",
                        ),
                    ),
                    val @ ServiceCommand::Stop(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Stop",
                            "try_unwrap_dependency_list",
                        ),
                    ),
                    val @ ServiceCommand::Restart(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Restart",
                            "try_unwrap_dependency_list",
                        ),
                    ),
                    val @ ServiceCommand::List(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "List",
                            "try_unwrap_dependency_list",
                        ),
                    ),
                    val @ ServiceCommand::Status(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Status",
                            "try_unwrap_dependency_list",
                        ),
                    ),
                    val @ ServiceCommand::Add(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Add",
                            "try_unwrap_dependency_list",
                        ),
                    ),
                    val @ ServiceCommand::Remove(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Remove",
                            "try_unwrap_dependency_list",
                        ),
                    ),
                    val @ ServiceCommand::ConfigGet(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "ConfigGet",
                            "try_unwrap_dependency_list",
                        ),
                    ),
                    val @ ServiceCommand::ConfigUpdate(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "ConfigUpdate",
                                "try_unwrap_dependency_list",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyAdd(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyAdd",
                                "try_unwrap_dependency_list",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyRemove(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyRemove",
                                "try_unwrap_dependency_list",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyList(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyList",
                                "try_unwrap_dependency_list",
                            ),
                        )
                    }
                    val @ ServiceCommand::GitCheckout(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "GitCheckout",
                                "try_unwrap_dependency_list",
                            ),
                        )
                    }
                    val @ ServiceCommand::GitStatus(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "GitStatus",
                            "try_unwrap_dependency_list",
                        ),
                    ),
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Attempts to unwrap this reference to the `ServiceCommand::DependencyList` variant.
        */
        ///Returns a [TryUnwrapError] with the original value if this value is of any other type.
        pub fn try_unwrap_dependency_list_ref(
            &self,
        ) -> derive_more::core::result::Result<
            (&ListDependenciesCommand),
            derive_more::TryUnwrapError<&Self>,
        > {
            match self {
                ServiceCommand::DependencyList(field_0) => {
                    derive_more::core::result::Result::Ok((field_0))
                }
                val @ _ => match val {
                    val @ ServiceCommand::Start(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Start",
                            "try_unwrap_dependency_list_ref",
                        ),
                    ),
                    val @ ServiceCommand::Stop(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Stop",
                            "try_unwrap_dependency_list_ref",
                        ),
                    ),
                    val @ ServiceCommand::Restart(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Restart",
                            "try_unwrap_dependency_list_ref",
                        ),
                    ),
                    val @ ServiceCommand::List(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "List",
                            "try_unwrap_dependency_list_ref",
                        ),
                    ),
                    val @ ServiceCommand::Status(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Status",
                            "try_unwrap_dependency_list_ref",
                        ),
                    ),
                    val @ ServiceCommand::Add(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Add",
                            "try_unwrap_dependency_list_ref",
                        ),
                    ),
                    val @ ServiceCommand::Remove(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Remove",
                            "try_unwrap_dependency_list_ref",
                        ),
                    ),
                    val @ ServiceCommand::ConfigGet(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "ConfigGet",
                            "try_unwrap_dependency_list_ref",
                        ),
                    ),
                    val @ ServiceCommand::ConfigUpdate(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "ConfigUpdate",
                                "try_unwrap_dependency_list_ref",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyAdd(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyAdd",
                                "try_unwrap_dependency_list_ref",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyRemove(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyRemove",
                                "try_unwrap_dependency_list_ref",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyList(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyList",
                                "try_unwrap_dependency_list_ref",
                            ),
                        )
                    }
                    val @ ServiceCommand::GitCheckout(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "GitCheckout",
                                "try_unwrap_dependency_list_ref",
                            ),
                        )
                    }
                    val @ ServiceCommand::GitStatus(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "GitStatus",
                            "try_unwrap_dependency_list_ref",
                        ),
                    ),
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Attempts to unwrap this mutable reference to the `ServiceCommand::DependencyList` variant.
        */
        ///Returns a [TryUnwrapError] with the original value if this value is of any other type.
        pub fn try_unwrap_dependency_list_mut(
            &mut self,
        ) -> derive_more::core::result::Result<
            (&mut ListDependenciesCommand),
            derive_more::TryUnwrapError<&mut Self>,
        > {
            match self {
                ServiceCommand::DependencyList(field_0) => {
                    derive_more::core::result::Result::Ok((field_0))
                }
                val @ _ => match val {
                    val @ ServiceCommand::Start(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Start",
                            "try_unwrap_dependency_list_mut",
                        ),
                    ),
                    val @ ServiceCommand::Stop(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Stop",
                            "try_unwrap_dependency_list_mut",
                        ),
                    ),
                    val @ ServiceCommand::Restart(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Restart",
                            "try_unwrap_dependency_list_mut",
                        ),
                    ),
                    val @ ServiceCommand::List(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "List",
                            "try_unwrap_dependency_list_mut",
                        ),
                    ),
                    val @ ServiceCommand::Status(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Status",
                            "try_unwrap_dependency_list_mut",
                        ),
                    ),
                    val @ ServiceCommand::Add(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Add",
                            "try_unwrap_dependency_list_mut",
                        ),
                    ),
                    val @ ServiceCommand::Remove(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Remove",
                            "try_unwrap_dependency_list_mut",
                        ),
                    ),
                    val @ ServiceCommand::ConfigGet(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "ConfigGet",
                            "try_unwrap_dependency_list_mut",
                        ),
                    ),
                    val @ ServiceCommand::ConfigUpdate(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "ConfigUpdate",
                                "try_unwrap_dependency_list_mut",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyAdd(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyAdd",
                                "try_unwrap_dependency_list_mut",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyRemove(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyRemove",
                                "try_unwrap_dependency_list_mut",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyList(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyList",
                                "try_unwrap_dependency_list_mut",
                            ),
                        )
                    }
                    val @ ServiceCommand::GitCheckout(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "GitCheckout",
                                "try_unwrap_dependency_list_mut",
                            ),
                        )
                    }
                    val @ ServiceCommand::GitStatus(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "GitStatus",
                            "try_unwrap_dependency_list_mut",
                        ),
                    ),
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Attempts to unwrap this value to the `ServiceCommand::GitCheckout` variant.
        */
        ///Returns a [TryUnwrapError] with the original value if this value is of any other type.
        pub fn try_unwrap_git_checkout(
            self,
        ) -> derive_more::core::result::Result<(CheckoutCommand), derive_more::TryUnwrapError<Self>>
        {
            match self {
                ServiceCommand::GitCheckout(field_0) => {
                    derive_more::core::result::Result::Ok((field_0))
                }
                val @ _ => match val {
                    val @ ServiceCommand::Start(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Start",
                            "try_unwrap_git_checkout",
                        ),
                    ),
                    val @ ServiceCommand::Stop(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Stop",
                            "try_unwrap_git_checkout",
                        ),
                    ),
                    val @ ServiceCommand::Restart(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Restart",
                            "try_unwrap_git_checkout",
                        ),
                    ),
                    val @ ServiceCommand::List(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "List",
                            "try_unwrap_git_checkout",
                        ),
                    ),
                    val @ ServiceCommand::Status(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Status",
                            "try_unwrap_git_checkout",
                        ),
                    ),
                    val @ ServiceCommand::Add(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Add",
                            "try_unwrap_git_checkout",
                        ),
                    ),
                    val @ ServiceCommand::Remove(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Remove",
                            "try_unwrap_git_checkout",
                        ),
                    ),
                    val @ ServiceCommand::ConfigGet(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "ConfigGet",
                            "try_unwrap_git_checkout",
                        ),
                    ),
                    val @ ServiceCommand::ConfigUpdate(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "ConfigUpdate",
                                "try_unwrap_git_checkout",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyAdd(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyAdd",
                                "try_unwrap_git_checkout",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyRemove(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyRemove",
                                "try_unwrap_git_checkout",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyList(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyList",
                                "try_unwrap_git_checkout",
                            ),
                        )
                    }
                    val @ ServiceCommand::GitCheckout(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "GitCheckout",
                                "try_unwrap_git_checkout",
                            ),
                        )
                    }
                    val @ ServiceCommand::GitStatus(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "GitStatus",
                            "try_unwrap_git_checkout",
                        ),
                    ),
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Attempts to unwrap this reference to the `ServiceCommand::GitCheckout` variant.
        */
        ///Returns a [TryUnwrapError] with the original value if this value is of any other type.
        pub fn try_unwrap_git_checkout_ref(
            &self,
        ) -> derive_more::core::result::Result<(&CheckoutCommand), derive_more::TryUnwrapError<&Self>>
        {
            match self {
                ServiceCommand::GitCheckout(field_0) => {
                    derive_more::core::result::Result::Ok((field_0))
                }
                val @ _ => match val {
                    val @ ServiceCommand::Start(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Start",
                            "try_unwrap_git_checkout_ref",
                        ),
                    ),
                    val @ ServiceCommand::Stop(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Stop",
                            "try_unwrap_git_checkout_ref",
                        ),
                    ),
                    val @ ServiceCommand::Restart(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Restart",
                            "try_unwrap_git_checkout_ref",
                        ),
                    ),
                    val @ ServiceCommand::List(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "List",
                            "try_unwrap_git_checkout_ref",
                        ),
                    ),
                    val @ ServiceCommand::Status(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Status",
                            "try_unwrap_git_checkout_ref",
                        ),
                    ),
                    val @ ServiceCommand::Add(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Add",
                            "try_unwrap_git_checkout_ref",
                        ),
                    ),
                    val @ ServiceCommand::Remove(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Remove",
                            "try_unwrap_git_checkout_ref",
                        ),
                    ),
                    val @ ServiceCommand::ConfigGet(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "ConfigGet",
                            "try_unwrap_git_checkout_ref",
                        ),
                    ),
                    val @ ServiceCommand::ConfigUpdate(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "ConfigUpdate",
                                "try_unwrap_git_checkout_ref",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyAdd(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyAdd",
                                "try_unwrap_git_checkout_ref",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyRemove(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyRemove",
                                "try_unwrap_git_checkout_ref",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyList(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyList",
                                "try_unwrap_git_checkout_ref",
                            ),
                        )
                    }
                    val @ ServiceCommand::GitCheckout(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "GitCheckout",
                                "try_unwrap_git_checkout_ref",
                            ),
                        )
                    }
                    val @ ServiceCommand::GitStatus(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "GitStatus",
                            "try_unwrap_git_checkout_ref",
                        ),
                    ),
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Attempts to unwrap this mutable reference to the `ServiceCommand::GitCheckout` variant.
        */
        ///Returns a [TryUnwrapError] with the original value if this value is of any other type.
        pub fn try_unwrap_git_checkout_mut(
            &mut self,
        ) -> derive_more::core::result::Result<
            (&mut CheckoutCommand),
            derive_more::TryUnwrapError<&mut Self>,
        > {
            match self {
                ServiceCommand::GitCheckout(field_0) => {
                    derive_more::core::result::Result::Ok((field_0))
                }
                val @ _ => match val {
                    val @ ServiceCommand::Start(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Start",
                            "try_unwrap_git_checkout_mut",
                        ),
                    ),
                    val @ ServiceCommand::Stop(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Stop",
                            "try_unwrap_git_checkout_mut",
                        ),
                    ),
                    val @ ServiceCommand::Restart(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Restart",
                            "try_unwrap_git_checkout_mut",
                        ),
                    ),
                    val @ ServiceCommand::List(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "List",
                            "try_unwrap_git_checkout_mut",
                        ),
                    ),
                    val @ ServiceCommand::Status(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Status",
                            "try_unwrap_git_checkout_mut",
                        ),
                    ),
                    val @ ServiceCommand::Add(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Add",
                            "try_unwrap_git_checkout_mut",
                        ),
                    ),
                    val @ ServiceCommand::Remove(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Remove",
                            "try_unwrap_git_checkout_mut",
                        ),
                    ),
                    val @ ServiceCommand::ConfigGet(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "ConfigGet",
                            "try_unwrap_git_checkout_mut",
                        ),
                    ),
                    val @ ServiceCommand::ConfigUpdate(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "ConfigUpdate",
                                "try_unwrap_git_checkout_mut",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyAdd(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyAdd",
                                "try_unwrap_git_checkout_mut",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyRemove(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyRemove",
                                "try_unwrap_git_checkout_mut",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyList(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyList",
                                "try_unwrap_git_checkout_mut",
                            ),
                        )
                    }
                    val @ ServiceCommand::GitCheckout(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "GitCheckout",
                                "try_unwrap_git_checkout_mut",
                            ),
                        )
                    }
                    val @ ServiceCommand::GitStatus(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "GitStatus",
                            "try_unwrap_git_checkout_mut",
                        ),
                    ),
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Attempts to unwrap this value to the `ServiceCommand::GitStatus` variant.
        */
        ///Returns a [TryUnwrapError] with the original value if this value is of any other type.
        pub fn try_unwrap_git_status(
            self,
        ) -> derive_more::core::result::Result<
            (GetRepoStatusCommand),
            derive_more::TryUnwrapError<Self>,
        > {
            match self {
                ServiceCommand::GitStatus(field_0) => {
                    derive_more::core::result::Result::Ok((field_0))
                }
                val @ _ => match val {
                    val @ ServiceCommand::Start(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Start",
                            "try_unwrap_git_status",
                        ),
                    ),
                    val @ ServiceCommand::Stop(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Stop",
                            "try_unwrap_git_status",
                        ),
                    ),
                    val @ ServiceCommand::Restart(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Restart",
                            "try_unwrap_git_status",
                        ),
                    ),
                    val @ ServiceCommand::List(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "List",
                            "try_unwrap_git_status",
                        ),
                    ),
                    val @ ServiceCommand::Status(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Status",
                            "try_unwrap_git_status",
                        ),
                    ),
                    val @ ServiceCommand::Add(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Add",
                            "try_unwrap_git_status",
                        ),
                    ),
                    val @ ServiceCommand::Remove(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Remove",
                            "try_unwrap_git_status",
                        ),
                    ),
                    val @ ServiceCommand::ConfigGet(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "ConfigGet",
                            "try_unwrap_git_status",
                        ),
                    ),
                    val @ ServiceCommand::ConfigUpdate(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "ConfigUpdate",
                                "try_unwrap_git_status",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyAdd(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyAdd",
                                "try_unwrap_git_status",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyRemove(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyRemove",
                                "try_unwrap_git_status",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyList(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyList",
                                "try_unwrap_git_status",
                            ),
                        )
                    }
                    val @ ServiceCommand::GitCheckout(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "GitCheckout",
                                "try_unwrap_git_status",
                            ),
                        )
                    }
                    val @ ServiceCommand::GitStatus(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "GitStatus",
                            "try_unwrap_git_status",
                        ),
                    ),
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Attempts to unwrap this reference to the `ServiceCommand::GitStatus` variant.
        */
        ///Returns a [TryUnwrapError] with the original value if this value is of any other type.
        pub fn try_unwrap_git_status_ref(
            &self,
        ) -> derive_more::core::result::Result<
            (&GetRepoStatusCommand),
            derive_more::TryUnwrapError<&Self>,
        > {
            match self {
                ServiceCommand::GitStatus(field_0) => {
                    derive_more::core::result::Result::Ok((field_0))
                }
                val @ _ => match val {
                    val @ ServiceCommand::Start(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Start",
                            "try_unwrap_git_status_ref",
                        ),
                    ),
                    val @ ServiceCommand::Stop(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Stop",
                            "try_unwrap_git_status_ref",
                        ),
                    ),
                    val @ ServiceCommand::Restart(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Restart",
                            "try_unwrap_git_status_ref",
                        ),
                    ),
                    val @ ServiceCommand::List(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "List",
                            "try_unwrap_git_status_ref",
                        ),
                    ),
                    val @ ServiceCommand::Status(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Status",
                            "try_unwrap_git_status_ref",
                        ),
                    ),
                    val @ ServiceCommand::Add(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Add",
                            "try_unwrap_git_status_ref",
                        ),
                    ),
                    val @ ServiceCommand::Remove(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Remove",
                            "try_unwrap_git_status_ref",
                        ),
                    ),
                    val @ ServiceCommand::ConfigGet(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "ConfigGet",
                            "try_unwrap_git_status_ref",
                        ),
                    ),
                    val @ ServiceCommand::ConfigUpdate(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "ConfigUpdate",
                                "try_unwrap_git_status_ref",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyAdd(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyAdd",
                                "try_unwrap_git_status_ref",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyRemove(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyRemove",
                                "try_unwrap_git_status_ref",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyList(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyList",
                                "try_unwrap_git_status_ref",
                            ),
                        )
                    }
                    val @ ServiceCommand::GitCheckout(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "GitCheckout",
                                "try_unwrap_git_status_ref",
                            ),
                        )
                    }
                    val @ ServiceCommand::GitStatus(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "GitStatus",
                            "try_unwrap_git_status_ref",
                        ),
                    ),
                },
            }
        }
        #[inline]
        #[track_caller]
        /**Attempts to unwrap this mutable reference to the `ServiceCommand::GitStatus` variant.
        */
        ///Returns a [TryUnwrapError] with the original value if this value is of any other type.
        pub fn try_unwrap_git_status_mut(
            &mut self,
        ) -> derive_more::core::result::Result<
            (&mut GetRepoStatusCommand),
            derive_more::TryUnwrapError<&mut Self>,
        > {
            match self {
                ServiceCommand::GitStatus(field_0) => {
                    derive_more::core::result::Result::Ok((field_0))
                }
                val @ _ => match val {
                    val @ ServiceCommand::Start(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Start",
                            "try_unwrap_git_status_mut",
                        ),
                    ),
                    val @ ServiceCommand::Stop(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Stop",
                            "try_unwrap_git_status_mut",
                        ),
                    ),
                    val @ ServiceCommand::Restart(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Restart",
                            "try_unwrap_git_status_mut",
                        ),
                    ),
                    val @ ServiceCommand::List(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "List",
                            "try_unwrap_git_status_mut",
                        ),
                    ),
                    val @ ServiceCommand::Status(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Status",
                            "try_unwrap_git_status_mut",
                        ),
                    ),
                    val @ ServiceCommand::Add(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Add",
                            "try_unwrap_git_status_mut",
                        ),
                    ),
                    val @ ServiceCommand::Remove(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "Remove",
                            "try_unwrap_git_status_mut",
                        ),
                    ),
                    val @ ServiceCommand::ConfigGet(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "ConfigGet",
                            "try_unwrap_git_status_mut",
                        ),
                    ),
                    val @ ServiceCommand::ConfigUpdate(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "ConfigUpdate",
                                "try_unwrap_git_status_mut",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyAdd(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyAdd",
                                "try_unwrap_git_status_mut",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyRemove(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyRemove",
                                "try_unwrap_git_status_mut",
                            ),
                        )
                    }
                    val @ ServiceCommand::DependencyList(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "DependencyList",
                                "try_unwrap_git_status_mut",
                            ),
                        )
                    }
                    val @ ServiceCommand::GitCheckout(..) => {
                        derive_more::core::result::Result::Err(
                            derive_more::TryUnwrapError::<_>::new(
                                val,
                                "ServiceCommand",
                                "GitCheckout",
                                "try_unwrap_git_status_mut",
                            ),
                        )
                    }
                    val @ ServiceCommand::GitStatus(..) => derive_more::core::result::Result::Err(
                        derive_more::TryUnwrapError::<_>::new(
                            val,
                            "ServiceCommand",
                            "GitStatus",
                            "try_unwrap_git_status_mut",
                        ),
                    ),
                },
            }
        }
    }
    impl<T: Into<CommandPayload>> From<Option<T>> for CommandPayload {
        fn from(value: Option<T>) -> Self {
            if let Some(value) = value {
                value.into()
            } else {
                Self::Empty
            }
        }
    }
    impl From<()> for CommandPayload {
        fn from(_: ()) -> Self {
            Self::Empty
        }
    }
}
pub mod header {
    use crate::commands::Command;
    use bincode::{Decode, Encode};
    use binrw::{BinRead, BinResult, BinWrite};
    use std::io::{Read, Seek, Write};
    pub struct MessageFlags(u16);
    #[automatically_derived]
    impl ::core::fmt::Debug for MessageFlags {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_tuple_field1_finish(f, "MessageFlags", &&self.0)
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for MessageFlags {
        #[inline]
        fn clone(&self) -> MessageFlags {
            let _: ::core::clone::AssertParamIsClone<u16>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for MessageFlags {}
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for MessageFlags {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for MessageFlags {
        #[inline]
        fn eq(&self, other: &MessageFlags) -> bool {
            self.0 == other.0
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for MessageFlags {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<u16>;
        }
    }
    impl ::bincode::Encode for MessageFlags {
        fn encode<__E: ::bincode::enc::Encoder>(
            &self,
            encoder: &mut __E,
        ) -> core::result::Result<(), ::bincode::error::EncodeError> {
            ::bincode::Encode::encode(&self.0, encoder)?;
            Ok(())
        }
    }
    impl ::bincode::Decode for MessageFlags {
        fn decode<__D: ::bincode::de::Decoder>(
            decoder: &mut __D,
        ) -> core::result::Result<Self, ::bincode::error::DecodeError> {
            Ok(Self {
                0: ::bincode::Decode::decode(decoder)?,
            })
        }
    }
    impl<'__de> ::bincode::BorrowDecode<'__de> for MessageFlags {
        fn borrow_decode<__D: ::bincode::de::BorrowDecoder<'__de>>(
            decoder: &mut __D,
        ) -> core::result::Result<Self, ::bincode::error::DecodeError> {
            Ok(Self {
                0: ::bincode::BorrowDecode::borrow_decode(decoder)?,
            })
        }
    }
    impl MessageFlags {
        pub const NONE: MessageFlags = MessageFlags(0);
        pub const COMPRESSED: MessageFlags = MessageFlags(1 << 0);
        pub const ENCRYPTED: MessageFlags = MessageFlags(1 << 1);
        pub const REQUIRES_ACK: MessageFlags = MessageFlags(1 << 2);
        pub const HAS_PAYLOAD: MessageFlags = MessageFlags(1 << 3);
        pub fn contains(self, other: MessageFlags) -> bool {
            (self.0 & other.0) == other.0
        }
        pub fn is_empty(self) -> bool {
            self.0 == 0
        }
    }
    impl std::ops::BitOr for MessageFlags {
        type Output = Self;
        fn bitor(self, rhs: Self) -> Self::Output {
            MessageFlags(self.0 | rhs.0)
        }
    }
    impl std::ops::BitAnd for MessageFlags {
        type Output = Self;
        fn bitand(self, rhs: Self) -> Self::Output {
            MessageFlags(self.0 & rhs.0)
        }
    }
    impl BinRead for MessageFlags {
        type Args<'a> = ();
        fn read_options<R: Read + Seek>(
            reader: &mut R,
            endian: binrw::Endian,
            _args: Self::Args<'_>,
        ) -> BinResult<Self> {
            let value = u16::read_options(reader, endian, ())?;
            Ok(MessageFlags(value))
        }
    }
    impl BinWrite for MessageFlags {
        type Args<'a> = ();
        fn write_options<W: Write + Seek>(
            &self,
            writer: &mut W,
            endian: binrw::Endian,
            _args: Self::Args<'_>,
        ) -> BinResult<()> {
            self.0.write_options(writer, endian, ())
        }
    }
    #[brw(magic = b"NEX\0", big)]
    pub struct MessageHeader {
        #[brw(big)]
        pub(crate) version: u16,
        #[brw(big)]
        pub command: Command,
        #[brw(big)]
        pub(crate) payload_length: u32,
        #[brw(big)]
        pub(crate) sequence_number: u32,
        #[brw(big)]
        pub(crate) flags: MessageFlags,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for MessageHeader {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field5_finish(
                f,
                "MessageHeader",
                "version",
                &self.version,
                "command",
                &self.command,
                "payload_length",
                &self.payload_length,
                "sequence_number",
                &self.sequence_number,
                "flags",
                &&self.flags,
            )
        }
    }
    #[automatically_derived]
    #[allow(non_snake_case, unknown_lints)]
    #[allow(clippy::redundant_closure_call)]
    impl binrw::BinRead for MessageHeader {
        type Args<'__binrw_generated_args_lifetime> = ();
        fn read_options<R: binrw::io::Read + binrw::io::Seek>(
            __binrw_generated_var_reader: &mut R,
            __binrw_generated_var_endian: binrw::Endian,
            __binrw_generated_var_arguments: Self::Args<'_>,
        ) -> binrw::BinResult<Self> {
            let __binrw_generated_var_reader = __binrw_generated_var_reader;
            let __binrw_generated_position_temp =
                binrw::io::Seek::stream_position(__binrw_generated_var_reader)?;
            (|| {
                let __binrw_generated_var_endian = binrw::Endian::Big;
                binrw::__private::magic(
                    __binrw_generated_var_reader,
                    *b"NEX\0",
                    __binrw_generated_var_endian,
                )?;
                let __binrw_generated_read_function = binrw::BinRead::read_options;
                let __binrw_generated_endian_version = binrw::Endian::Big;
                let mut version: u16 = __binrw_generated_read_function(
                        __binrw_generated_var_reader,
                        __binrw_generated_endian_version,
                        <_ as binrw::__private::Required>::args(),
                    )
                    .map_err(|err| binrw::error::ContextExt::with_context(
                        err,
                        binrw::error::BacktraceFrame::Full {
                            message: "While parsing field 'version' in MessageHeader"
                                .into(),
                            line: 75u32,
                            file: "nexsock-protocol/src/header.rs",
                            code: Some(
                                "  ┄───╮\n   74 |  \u{1b}[38;5;197m#\u{1b}[39m\u{1b}[38;5;197m[\u{1b}[39m\u{1b}[38;5;197mbrw\u{1b}[39m\u{1b}[38;5;197m(\u{1b}[39m\u{1b}[38;5;197mbig\u{1b}[39m\u{1b}[38;5;197m)\u{1b}[39m\u{1b}[38;5;197m]\u{1b}[39m // Explicitly set big endian\n   \u{1b}[1m75\u{1b}[0m \u{1b}[1m⎬\u{1b}[0m  \u{1b}[1mpub(crate) version: \u{1b}[0m\u{1b}[1m\u{1b}[38;5;197mu16\u{1b}[39m\u{1b}[0m\n  ┄───╯\n",
                            ),
                        },
                    ))?;
                let __binrw_generated_read_function = binrw::BinRead::read_options;
                let __binrw_generated_endian_command = binrw::Endian::Big;
                let mut command: Command = __binrw_generated_read_function(
                        __binrw_generated_var_reader,
                        __binrw_generated_endian_command,
                        <_ as binrw::__private::Required>::args(),
                    )
                    .map_err(|err| binrw::error::ContextExt::with_context(
                        err,
                        binrw::error::BacktraceFrame::Full {
                            message: "While parsing field 'command' in MessageHeader"
                                .into(),
                            line: 77u32,
                            file: "nexsock-protocol/src/header.rs",
                            code: Some(
                                "  ┄───╮\n   76 |  \u{1b}[38;5;197m#\u{1b}[39m\u{1b}[38;5;197m[\u{1b}[39m\u{1b}[38;5;197mbrw\u{1b}[39m\u{1b}[38;5;197m(\u{1b}[39m\u{1b}[38;5;197mbig\u{1b}[39m\u{1b}[38;5;197m)\u{1b}[39m\u{1b}[38;5;197m]\u{1b}[39m // Explicitly set big endian\n   \u{1b}[1m77\u{1b}[0m \u{1b}[1m⎬\u{1b}[0m  \u{1b}[1mpub command: Command\u{1b}[0m\n  ┄───╯\n",
                            ),
                        },
                    ))?;
                let __binrw_generated_read_function = binrw::BinRead::read_options;
                let __binrw_generated_endian_payload_length = binrw::Endian::Big;
                let mut payload_length: u32 = __binrw_generated_read_function(
                        __binrw_generated_var_reader,
                        __binrw_generated_endian_payload_length,
                        <_ as binrw::__private::Required>::args(),
                    )
                    .map_err(|err| binrw::error::ContextExt::with_context(
                        err,
                        binrw::error::BacktraceFrame::Full {
                            message: "While parsing field 'payload_length' in MessageHeader"
                                .into(),
                            line: 79u32,
                            file: "nexsock-protocol/src/header.rs",
                            code: Some(
                                "  ┄───╮\n   78 |  \u{1b}[38;5;197m#\u{1b}[39m\u{1b}[38;5;197m[\u{1b}[39m\u{1b}[38;5;197mbrw\u{1b}[39m\u{1b}[38;5;197m(\u{1b}[39m\u{1b}[38;5;197mbig\u{1b}[39m\u{1b}[38;5;197m)\u{1b}[39m\u{1b}[38;5;197m]\u{1b}[39m // Explicitly set big endian\n   \u{1b}[1m79\u{1b}[0m \u{1b}[1m⎬\u{1b}[0m  \u{1b}[1mpub(crate) payload_length: \u{1b}[0m\u{1b}[1m\u{1b}[38;5;197mu32\u{1b}[39m\u{1b}[0m\n  ┄───╯\n",
                            ),
                        },
                    ))?;
                let __binrw_generated_read_function = binrw::BinRead::read_options;
                let __binrw_generated_endian_sequence_number = binrw::Endian::Big;
                let mut sequence_number: u32 = __binrw_generated_read_function(
                        __binrw_generated_var_reader,
                        __binrw_generated_endian_sequence_number,
                        <_ as binrw::__private::Required>::args(),
                    )
                    .map_err(|err| binrw::error::ContextExt::with_context(
                        err,
                        binrw::error::BacktraceFrame::Full {
                            message: "While parsing field 'sequence_number' in MessageHeader"
                                .into(),
                            line: 81u32,
                            file: "nexsock-protocol/src/header.rs",
                            code: Some(
                                "  ┄───╮\n   80 |  \u{1b}[38;5;197m#\u{1b}[39m\u{1b}[38;5;197m[\u{1b}[39m\u{1b}[38;5;197mbrw\u{1b}[39m\u{1b}[38;5;197m(\u{1b}[39m\u{1b}[38;5;197mbig\u{1b}[39m\u{1b}[38;5;197m)\u{1b}[39m\u{1b}[38;5;197m]\u{1b}[39m // Explicitly set big endian\n   \u{1b}[1m81\u{1b}[0m \u{1b}[1m⎬\u{1b}[0m  \u{1b}[1mpub(crate) sequence_number: \u{1b}[0m\u{1b}[1m\u{1b}[38;5;197mu32\u{1b}[39m\u{1b}[0m\n  ┄───╯\n",
                            ),
                        },
                    ))?;
                let __binrw_generated_read_function = binrw::BinRead::read_options;
                let __binrw_generated_endian_flags = binrw::Endian::Big;
                let mut flags: MessageFlags = __binrw_generated_read_function(
                        __binrw_generated_var_reader,
                        __binrw_generated_endian_flags,
                        <_ as binrw::__private::Required>::args(),
                    )
                    .map_err(|err| binrw::error::ContextExt::with_context(
                        err,
                        binrw::error::BacktraceFrame::Full {
                            message: "While parsing field 'flags' in MessageHeader"
                                .into(),
                            line: 83u32,
                            file: "nexsock-protocol/src/header.rs",
                            code: Some(
                                "  ┄───╮\n   82 |  \u{1b}[38;5;197m#\u{1b}[39m\u{1b}[38;5;197m[\u{1b}[39m\u{1b}[38;5;197mbrw\u{1b}[39m\u{1b}[38;5;197m(\u{1b}[39m\u{1b}[38;5;197mbig\u{1b}[39m\u{1b}[38;5;197m)\u{1b}[39m\u{1b}[38;5;197m]\u{1b}[39m // Explicitly set big endian\n   \u{1b}[1m83\u{1b}[0m \u{1b}[1m⎬\u{1b}[0m  \u{1b}[1mpub(crate) flags: MessageFlags\u{1b}[0m\n  ┄───╯\n",
                            ),
                        },
                    ))?;
                let __binrw_this = Self {
                    version,
                    command,
                    payload_length,
                    sequence_number,
                    flags,
                };
                Ok(__binrw_this)
            })()
                .or_else(
                    binrw::__private::restore_position::<
                        binrw::Error,
                        _,
                        _,
                    >(__binrw_generated_var_reader, __binrw_generated_position_temp),
                )
        }
    }
    impl binrw::meta::ReadMagic for MessageHeader {
        type MagicType = [u8; 4];
        const MAGIC: Self::MagicType = *b"NEX\0";
    }
    impl binrw::meta::ReadEndian for MessageHeader {
        const ENDIAN: binrw::meta::EndianKind = binrw::meta::EndianKind::Endian(binrw::Endian::Big);
    }
    #[automatically_derived]
    #[allow(non_snake_case, unknown_lints)]
    #[allow(clippy::redundant_closure_call)]
    impl binrw::BinWrite for MessageHeader {
        type Args<'__binrw_generated_args_lifetime> = ();
        fn write_options<W: binrw::io::Write + binrw::io::Seek>(
            &self,
            __binrw_generated_var_writer: &mut W,
            __binrw_generated_var_endian: binrw::Endian,
            __binrw_generated_var_arguments: Self::Args<'_>,
        ) -> binrw::BinResult<()> {
            let __binrw_generated_var_writer = __binrw_generated_var_writer;
            let __binrw_generated_position_temp =
                binrw::io::Seek::stream_position(__binrw_generated_var_writer)?;
            let __binrw_this = self;
            let MessageHeader {
                ref version,
                ref command,
                ref payload_length,
                ref sequence_number,
                ref flags,
            } = self;
            let __binrw_generated_var_endian = binrw::Endian::Big;
            binrw::BinWrite::write_options(
                &b"NEX\0",
                __binrw_generated_var_writer,
                __binrw_generated_var_endian,
                (),
            )?;
            let __binrw_generated_write_function =
                binrw::__private::write_fn_type_hint::<u16, _, _, _>(
                    binrw::BinWrite::write_options,
                );
            let __binrw_generated_args_version: <u16 as binrw::BinWrite>::Args<'_> =
                <_ as binrw::__private::Required>::args();
            __binrw_generated_write_function(
                &version,
                __binrw_generated_var_writer,
                binrw::Endian::Big,
                __binrw_generated_args_version,
            )?;
            let __binrw_generated_write_function =
                binrw::__private::write_fn_type_hint::<Command, _, _, _>(
                    binrw::BinWrite::write_options,
                );
            let __binrw_generated_args_command: <Command as binrw::BinWrite>::Args<'_> =
                <_ as binrw::__private::Required>::args();
            __binrw_generated_write_function(
                &command,
                __binrw_generated_var_writer,
                binrw::Endian::Big,
                __binrw_generated_args_command,
            )?;
            let __binrw_generated_write_function =
                binrw::__private::write_fn_type_hint::<u32, _, _, _>(
                    binrw::BinWrite::write_options,
                );
            let __binrw_generated_args_payload_length: <u32 as binrw::BinWrite>::Args<'_> =
                <_ as binrw::__private::Required>::args();
            __binrw_generated_write_function(
                &payload_length,
                __binrw_generated_var_writer,
                binrw::Endian::Big,
                __binrw_generated_args_payload_length,
            )?;
            let __binrw_generated_write_function =
                binrw::__private::write_fn_type_hint::<u32, _, _, _>(
                    binrw::BinWrite::write_options,
                );
            let __binrw_generated_args_sequence_number: <u32 as binrw::BinWrite>::Args<'_> =
                <_ as binrw::__private::Required>::args();
            __binrw_generated_write_function(
                &sequence_number,
                __binrw_generated_var_writer,
                binrw::Endian::Big,
                __binrw_generated_args_sequence_number,
            )?;
            let __binrw_generated_write_function =
                binrw::__private::write_fn_type_hint::<MessageFlags, _, _, _>(
                    binrw::BinWrite::write_options,
                );
            let __binrw_generated_args_flags: <MessageFlags as binrw::BinWrite>::Args<'_> =
                <_ as binrw::__private::Required>::args();
            __binrw_generated_write_function(
                &flags,
                __binrw_generated_var_writer,
                binrw::Endian::Big,
                __binrw_generated_args_flags,
            )?;
            Ok(())
        }
    }
    impl binrw::meta::WriteMagic for MessageHeader {
        type MagicType = [u8; 4];
        const MAGIC: Self::MagicType = *b"NEX\0";
    }
    impl binrw::meta::WriteEndian for MessageHeader {
        const ENDIAN: binrw::meta::EndianKind = binrw::meta::EndianKind::Endian(binrw::Endian::Big);
    }
    impl ::bincode::Encode for MessageHeader {
        fn encode<__E: ::bincode::enc::Encoder>(
            &self,
            encoder: &mut __E,
        ) -> core::result::Result<(), ::bincode::error::EncodeError> {
            ::bincode::Encode::encode(&self.version, encoder)?;
            ::bincode::Encode::encode(&self.command, encoder)?;
            ::bincode::Encode::encode(&self.payload_length, encoder)?;
            ::bincode::Encode::encode(&self.sequence_number, encoder)?;
            ::bincode::Encode::encode(&self.flags, encoder)?;
            Ok(())
        }
    }
    impl ::bincode::Decode for MessageHeader {
        fn decode<__D: ::bincode::de::Decoder>(
            decoder: &mut __D,
        ) -> core::result::Result<Self, ::bincode::error::DecodeError> {
            Ok(Self {
                version: ::bincode::Decode::decode(decoder)?,
                command: ::bincode::Decode::decode(decoder)?,
                payload_length: ::bincode::Decode::decode(decoder)?,
                sequence_number: ::bincode::Decode::decode(decoder)?,
                flags: ::bincode::Decode::decode(decoder)?,
            })
        }
    }
    impl<'__de> ::bincode::BorrowDecode<'__de> for MessageHeader {
        fn borrow_decode<__D: ::bincode::de::BorrowDecoder<'__de>>(
            decoder: &mut __D,
        ) -> core::result::Result<Self, ::bincode::error::DecodeError> {
            Ok(Self {
                version: ::bincode::BorrowDecode::borrow_decode(decoder)?,
                command: ::bincode::BorrowDecode::borrow_decode(decoder)?,
                payload_length: ::bincode::BorrowDecode::borrow_decode(decoder)?,
                sequence_number: ::bincode::BorrowDecode::borrow_decode(decoder)?,
                flags: ::bincode::BorrowDecode::borrow_decode(decoder)?,
            })
        }
    }
}
mod macros {}
pub mod protocol {
    use crate::commands::Command;
    use crate::header::{MessageFlags, MessageHeader};
    use bincode::{Decode, Encode};
    use binrw::{BinRead, BinWrite};
    use std::fmt::Debug;
    use std::io;
    use tokio::io::{AsyncRead, AsyncReadExt, AsyncWrite, AsyncWriteExt};
    use tracing::debug;
    #[cfg(debug_assertions)]
    use tracing::error;
    pub struct Protocol {
        sequence: u32,
        version: u16,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Protocol {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "Protocol",
                "sequence",
                &self.sequence,
                "version",
                &&self.version,
            )
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Protocol {
        #[inline]
        fn default() -> Protocol {
            Protocol {
                sequence: ::core::default::Default::default(),
                version: ::core::default::Default::default(),
            }
        }
    }
    impl Protocol {
        pub fn new(version: u16) -> Self {
            Self {
                sequence: 0,
                version,
            }
        }
        pub async fn write_command<W>(&mut self, writer: &mut W, command: Command) -> io::Result<()>
        where
            W: AsyncWrite + Unpin,
        {
            {}
            let __tracing_attr_span = {
                use ::tracing::__macro_support::Callsite as _;
                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "write_command",
                            "nexsock_protocol::protocol",
                            tracing::Level::DEBUG,
                            ::tracing_core::__macro_support::Option::Some(
                                "nexsock-protocol/src/protocol.rs",
                            ),
                            ::tracing_core::__macro_support::Option::Some(26u32),
                            ::tracing_core::__macro_support::Option::Some(
                                "nexsock_protocol::protocol",
                            ),
                            ::tracing_core::field::FieldSet::new(
                                &["self", "command"],
                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                            ),
                            ::tracing::metadata::Kind::SPAN,
                        )
                    };
                    ::tracing::callsite::DefaultCallsite::new(&META)
                };
                let mut interest = ::tracing::subscriber::Interest::never();
                if tracing::Level::DEBUG <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && tracing::Level::DEBUG <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        interest = __CALLSITE.interest();
                        !interest.is_never()
                    }
                    && ::tracing::__macro_support::__is_enabled(__CALLSITE.metadata(), interest)
                {
                    let meta = __CALLSITE.metadata();
                    ::tracing::Span::new(meta, &{
                        #[allow(unused_imports)]
                        use ::tracing::field::{debug, display, Value};
                        let mut iter = meta.fields().iter();
                        meta.fields().value_set(&[
                            (
                                &::tracing::__macro_support::Iterator::next(&mut iter)
                                    .expect("FieldSet corrupted (this is a bug)"),
                                ::tracing::__macro_support::Option::Some(&tracing::field::debug(
                                    &self,
                                )
                                    as &dyn Value),
                            ),
                            (
                                &::tracing::__macro_support::Iterator::next(&mut iter)
                                    .expect("FieldSet corrupted (this is a bug)"),
                                ::tracing::__macro_support::Option::Some(&tracing::field::debug(
                                    &command,
                                )
                                    as &dyn Value),
                            ),
                        ])
                    })
                } else {
                    let span = ::tracing::__macro_support::__disabled_span(__CALLSITE.metadata());
                    if match tracing::Level::DEBUG {
                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                        _ => ::tracing::log::Level::Trace,
                    } <= ::tracing::log::STATIC_MAX_LEVEL
                    {
                        if !::tracing::dispatcher::has_been_set() {
                            {
                                span.record_all(&{
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE.metadata().fields().value_set(&[
                                        (
                                            &::tracing::__macro_support::Iterator::next(&mut iter)
                                                .expect("FieldSet corrupted (this is a bug)"),
                                            ::tracing::__macro_support::Option::Some(
                                                &tracing::field::debug(&self) as &dyn Value,
                                            ),
                                        ),
                                        (
                                            &::tracing::__macro_support::Iterator::next(&mut iter)
                                                .expect("FieldSet corrupted (this is a bug)"),
                                            ::tracing::__macro_support::Option::Some(
                                                &tracing::field::debug(&command) as &dyn Value,
                                            ),
                                        ),
                                    ])
                                });
                            }
                        } else {
                            {}
                        }
                    } else {
                        {}
                    };
                    span
                }
            };
            let __tracing_instrument_future = async move {
                #[allow(
                    unknown_lints,
                    unreachable_code,
                    clippy::diverging_sub_expression,
                    clippy::let_unit_value,
                    clippy::unreachable,
                    clippy::let_with_type_underscore,
                    clippy::empty_loop
                )]
                if false {
                    let __tracing_attr_fake_return: io::Result<()> = loop {};
                    return __tracing_attr_fake_return;
                }
                {
                    self.write_message(writer, command, None::<&()>, MessageFlags::NONE)
                        .await
                }
            };
            if !__tracing_attr_span.is_disabled() {
                tracing::Instrument::instrument(__tracing_instrument_future, __tracing_attr_span)
                    .await
            } else {
                __tracing_instrument_future.await
            }
        }
        pub async fn write_command_with_payload<W, T: Encode + Debug>(
            &mut self,
            writer: &mut W,
            command: Command,
            payload: &T,
            flags: MessageFlags,
        ) -> io::Result<()>
        where
            W: AsyncWrite + Unpin,
        {
            {}
            let __tracing_attr_span = {
                use ::tracing::__macro_support::Callsite as _;
                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "write_command_with_payload",
                            "nexsock_protocol::protocol",
                            tracing::Level::DEBUG,
                            ::tracing_core::__macro_support::Option::Some(
                                "nexsock-protocol/src/protocol.rs",
                            ),
                            ::tracing_core::__macro_support::Option::Some(35u32),
                            ::tracing_core::__macro_support::Option::Some(
                                "nexsock_protocol::protocol",
                            ),
                            ::tracing_core::field::FieldSet::new(
                                &["self", "command", "payload", "flags"],
                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                            ),
                            ::tracing::metadata::Kind::SPAN,
                        )
                    };
                    ::tracing::callsite::DefaultCallsite::new(&META)
                };
                let mut interest = ::tracing::subscriber::Interest::never();
                if tracing::Level::DEBUG <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && tracing::Level::DEBUG <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        interest = __CALLSITE.interest();
                        !interest.is_never()
                    }
                    && ::tracing::__macro_support::__is_enabled(__CALLSITE.metadata(), interest)
                {
                    let meta = __CALLSITE.metadata();
                    ::tracing::Span::new(meta, &{
                        #[allow(unused_imports)]
                        use ::tracing::field::{debug, display, Value};
                        let mut iter = meta.fields().iter();
                        meta.fields().value_set(&[
                            (
                                &::tracing::__macro_support::Iterator::next(&mut iter)
                                    .expect("FieldSet corrupted (this is a bug)"),
                                ::tracing::__macro_support::Option::Some(&tracing::field::debug(
                                    &self,
                                )
                                    as &dyn Value),
                            ),
                            (
                                &::tracing::__macro_support::Iterator::next(&mut iter)
                                    .expect("FieldSet corrupted (this is a bug)"),
                                ::tracing::__macro_support::Option::Some(&tracing::field::debug(
                                    &command,
                                )
                                    as &dyn Value),
                            ),
                            (
                                &::tracing::__macro_support::Iterator::next(&mut iter)
                                    .expect("FieldSet corrupted (this is a bug)"),
                                ::tracing::__macro_support::Option::Some(&tracing::field::debug(
                                    &payload,
                                )
                                    as &dyn Value),
                            ),
                            (
                                &::tracing::__macro_support::Iterator::next(&mut iter)
                                    .expect("FieldSet corrupted (this is a bug)"),
                                ::tracing::__macro_support::Option::Some(&tracing::field::debug(
                                    &flags,
                                )
                                    as &dyn Value),
                            ),
                        ])
                    })
                } else {
                    let span = ::tracing::__macro_support::__disabled_span(__CALLSITE.metadata());
                    if match tracing::Level::DEBUG {
                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                        _ => ::tracing::log::Level::Trace,
                    } <= ::tracing::log::STATIC_MAX_LEVEL
                    {
                        if !::tracing::dispatcher::has_been_set() {
                            {
                                span.record_all(&{
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE.metadata().fields().value_set(&[
                                        (
                                            &::tracing::__macro_support::Iterator::next(&mut iter)
                                                .expect("FieldSet corrupted (this is a bug)"),
                                            ::tracing::__macro_support::Option::Some(
                                                &tracing::field::debug(&self) as &dyn Value,
                                            ),
                                        ),
                                        (
                                            &::tracing::__macro_support::Iterator::next(&mut iter)
                                                .expect("FieldSet corrupted (this is a bug)"),
                                            ::tracing::__macro_support::Option::Some(
                                                &tracing::field::debug(&command) as &dyn Value,
                                            ),
                                        ),
                                        (
                                            &::tracing::__macro_support::Iterator::next(&mut iter)
                                                .expect("FieldSet corrupted (this is a bug)"),
                                            ::tracing::__macro_support::Option::Some(
                                                &tracing::field::debug(&payload) as &dyn Value,
                                            ),
                                        ),
                                        (
                                            &::tracing::__macro_support::Iterator::next(&mut iter)
                                                .expect("FieldSet corrupted (this is a bug)"),
                                            ::tracing::__macro_support::Option::Some(
                                                &tracing::field::debug(&flags) as &dyn Value,
                                            ),
                                        ),
                                    ])
                                });
                            }
                        } else {
                            {}
                        }
                    } else {
                        {}
                    };
                    span
                }
            };
            let __tracing_instrument_future = async move {
                #[allow(
                    unknown_lints,
                    unreachable_code,
                    clippy::diverging_sub_expression,
                    clippy::let_unit_value,
                    clippy::unreachable,
                    clippy::let_with_type_underscore,
                    clippy::empty_loop
                )]
                if false {
                    let __tracing_attr_fake_return: io::Result<()> = loop {};
                    return __tracing_attr_fake_return;
                }
                {
                    let flags = flags | MessageFlags::HAS_PAYLOAD;
                    self.write_message(writer, command, Some(payload), flags)
                        .await
                }
            };
            if !__tracing_attr_span.is_disabled() {
                tracing::Instrument::instrument(__tracing_instrument_future, __tracing_attr_span)
                    .await
            } else {
                __tracing_instrument_future.await
            }
        }
        async fn write_message<W, T: Encode + Debug>(
            &mut self,
            writer: &mut W,
            command: Command,
            payload: Option<&T>,
            flags: MessageFlags,
        ) -> io::Result<()>
        where
            W: AsyncWrite + Unpin,
        {
            {}
            let __tracing_attr_span = {
                use ::tracing::__macro_support::Callsite as _;
                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "write_message",
                            "nexsock_protocol::protocol",
                            tracing::Level::DEBUG,
                            ::tracing_core::__macro_support::Option::Some(
                                "nexsock-protocol/src/protocol.rs",
                            ),
                            ::tracing_core::__macro_support::Option::Some(51u32),
                            ::tracing_core::__macro_support::Option::Some(
                                "nexsock_protocol::protocol",
                            ),
                            ::tracing_core::field::FieldSet::new(
                                &["self", "command", "payload", "flags"],
                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                            ),
                            ::tracing::metadata::Kind::SPAN,
                        )
                    };
                    ::tracing::callsite::DefaultCallsite::new(&META)
                };
                let mut interest = ::tracing::subscriber::Interest::never();
                if tracing::Level::DEBUG <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && tracing::Level::DEBUG <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        interest = __CALLSITE.interest();
                        !interest.is_never()
                    }
                    && ::tracing::__macro_support::__is_enabled(__CALLSITE.metadata(), interest)
                {
                    let meta = __CALLSITE.metadata();
                    ::tracing::Span::new(meta, &{
                        #[allow(unused_imports)]
                        use ::tracing::field::{debug, display, Value};
                        let mut iter = meta.fields().iter();
                        meta.fields().value_set(&[
                            (
                                &::tracing::__macro_support::Iterator::next(&mut iter)
                                    .expect("FieldSet corrupted (this is a bug)"),
                                ::tracing::__macro_support::Option::Some(&tracing::field::debug(
                                    &self,
                                )
                                    as &dyn Value),
                            ),
                            (
                                &::tracing::__macro_support::Iterator::next(&mut iter)
                                    .expect("FieldSet corrupted (this is a bug)"),
                                ::tracing::__macro_support::Option::Some(&tracing::field::debug(
                                    &command,
                                )
                                    as &dyn Value),
                            ),
                            (
                                &::tracing::__macro_support::Iterator::next(&mut iter)
                                    .expect("FieldSet corrupted (this is a bug)"),
                                ::tracing::__macro_support::Option::Some(&tracing::field::debug(
                                    &payload,
                                )
                                    as &dyn Value),
                            ),
                            (
                                &::tracing::__macro_support::Iterator::next(&mut iter)
                                    .expect("FieldSet corrupted (this is a bug)"),
                                ::tracing::__macro_support::Option::Some(&tracing::field::debug(
                                    &flags,
                                )
                                    as &dyn Value),
                            ),
                        ])
                    })
                } else {
                    let span = ::tracing::__macro_support::__disabled_span(__CALLSITE.metadata());
                    if match tracing::Level::DEBUG {
                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                        _ => ::tracing::log::Level::Trace,
                    } <= ::tracing::log::STATIC_MAX_LEVEL
                    {
                        if !::tracing::dispatcher::has_been_set() {
                            {
                                span.record_all(&{
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE.metadata().fields().value_set(&[
                                        (
                                            &::tracing::__macro_support::Iterator::next(&mut iter)
                                                .expect("FieldSet corrupted (this is a bug)"),
                                            ::tracing::__macro_support::Option::Some(
                                                &tracing::field::debug(&self) as &dyn Value,
                                            ),
                                        ),
                                        (
                                            &::tracing::__macro_support::Iterator::next(&mut iter)
                                                .expect("FieldSet corrupted (this is a bug)"),
                                            ::tracing::__macro_support::Option::Some(
                                                &tracing::field::debug(&command) as &dyn Value,
                                            ),
                                        ),
                                        (
                                            &::tracing::__macro_support::Iterator::next(&mut iter)
                                                .expect("FieldSet corrupted (this is a bug)"),
                                            ::tracing::__macro_support::Option::Some(
                                                &tracing::field::debug(&payload) as &dyn Value,
                                            ),
                                        ),
                                        (
                                            &::tracing::__macro_support::Iterator::next(&mut iter)
                                                .expect("FieldSet corrupted (this is a bug)"),
                                            ::tracing::__macro_support::Option::Some(
                                                &tracing::field::debug(&flags) as &dyn Value,
                                            ),
                                        ),
                                    ])
                                });
                            }
                        } else {
                            {}
                        }
                    } else {
                        {}
                    };
                    span
                }
            };
            let __tracing_instrument_future = async move {
                #[allow(
                    unknown_lints,
                    unreachable_code,
                    clippy::diverging_sub_expression,
                    clippy::let_unit_value,
                    clippy::unreachable,
                    clippy::let_with_type_underscore,
                    clippy::empty_loop
                )]
                if false {
                    let __tracing_attr_fake_return: io::Result<()> = loop {};
                    return __tracing_attr_fake_return;
                }
                {
                    let payload_data = if let Some(payload) = payload {
                        let config = bincode::config::standard();
                        bincode::encode_to_vec(payload, config)
                            .map_err(|e| io::Error::new(io::ErrorKind::InvalidData, e))?
                    } else {
                        Vec::new()
                    };
                    let header = MessageHeader {
                        version: self.version,
                        command,
                        payload_length: payload_data.len() as u32,
                        sequence_number: self.next_sequence(),
                        flags,
                    };
                    let mut header_bytes = io::Cursor::new(Vec::new());
                    header
                        .write(&mut header_bytes)
                        .map_err(|e| io::Error::new(io::ErrorKind::InvalidData, e))?;
                    writer.write_all(&header_bytes.into_inner()).await?;
                    if !payload_data.is_empty() {
                        writer.write_all(&payload_data).await?;
                    }
                    writer.flush().await?;
                    Ok(())
                }
            };
            if !__tracing_attr_span.is_disabled() {
                tracing::Instrument::instrument(__tracing_instrument_future, __tracing_attr_span)
                    .await
            } else {
                __tracing_instrument_future.await
            }
        }
        pub async fn read_message<R>(
            &mut self,
            reader: &mut R,
        ) -> io::Result<(MessageHeader, Option<Vec<u8>>)>
        where
            R: AsyncRead + Unpin,
        {
            {}
            let __tracing_attr_span = {
                use ::tracing::__macro_support::Callsite as _;
                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "read_message",
                            "nexsock_protocol::protocol",
                            tracing::Level::DEBUG,
                            ::tracing_core::__macro_support::Option::Some(
                                "nexsock-protocol/src/protocol.rs",
                            ),
                            ::tracing_core::__macro_support::Option::Some(97u32),
                            ::tracing_core::__macro_support::Option::Some(
                                "nexsock_protocol::protocol",
                            ),
                            ::tracing_core::field::FieldSet::new(
                                &["self"],
                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                            ),
                            ::tracing::metadata::Kind::SPAN,
                        )
                    };
                    ::tracing::callsite::DefaultCallsite::new(&META)
                };
                let mut interest = ::tracing::subscriber::Interest::never();
                if tracing::Level::DEBUG <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && tracing::Level::DEBUG <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        interest = __CALLSITE.interest();
                        !interest.is_never()
                    }
                    && ::tracing::__macro_support::__is_enabled(__CALLSITE.metadata(), interest)
                {
                    let meta = __CALLSITE.metadata();
                    ::tracing::Span::new(meta, &{
                        #[allow(unused_imports)]
                        use ::tracing::field::{debug, display, Value};
                        let mut iter = meta.fields().iter();
                        meta.fields().value_set(&[(
                            &::tracing::__macro_support::Iterator::next(&mut iter)
                                .expect("FieldSet corrupted (this is a bug)"),
                            ::tracing::__macro_support::Option::Some(
                                &tracing::field::debug(&self) as &dyn Value
                            ),
                        )])
                    })
                } else {
                    let span = ::tracing::__macro_support::__disabled_span(__CALLSITE.metadata());
                    if match tracing::Level::DEBUG {
                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                        _ => ::tracing::log::Level::Trace,
                    } <= ::tracing::log::STATIC_MAX_LEVEL
                    {
                        if !::tracing::dispatcher::has_been_set() {
                            {
                                span.record_all(&{
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE.metadata().fields().value_set(&[(
                                        &::tracing::__macro_support::Iterator::next(&mut iter)
                                            .expect("FieldSet corrupted (this is a bug)"),
                                        ::tracing::__macro_support::Option::Some(
                                            &tracing::field::debug(&self) as &dyn Value,
                                        ),
                                    )])
                                });
                            }
                        } else {
                            {}
                        }
                    } else {
                        {}
                    };
                    span
                }
            };
            let __tracing_instrument_future = async move {
                #[allow(
                    unknown_lints,
                    unreachable_code,
                    clippy::diverging_sub_expression,
                    clippy::let_unit_value,
                    clippy::unreachable,
                    clippy::let_with_type_underscore,
                    clippy::empty_loop
                )]
                if false {
                    let __tracing_attr_fake_return: io::Result<(MessageHeader, Option<Vec<u8>>)> =
                        loop {};
                    return __tracing_attr_fake_return;
                }
                {
                    let mut magic = [0u8; 4];
                    reader.read_exact(&mut magic).await?;
                    if &magic != b"NEX\0" {
                        return Err(io::Error::new(
                            io::ErrorKind::InvalidData,
                            "Invalid protocol magic bytes",
                        ));
                    }
                    let mut header_bytes =
                        ::alloc::vec::from_elem(0u8, size_of::<MessageHeader>() - 2);
                    reader.read_exact(&mut header_bytes).await?;
                    let mut full_header = Vec::with_capacity(size_of::<MessageHeader>());
                    full_header.extend_from_slice(&magic);
                    full_header.extend_from_slice(&header_bytes);
                    let header: MessageHeader = BinRead::read(&mut io::Cursor::new(full_header))
                        .map_err(|e| io::Error::new(io::ErrorKind::InvalidData, e))?;
                    let payload = if header.flags.contains(MessageFlags::HAS_PAYLOAD) {
                        let mut payload =
                            ::alloc::vec::from_elem(0u8, header.payload_length as usize);
                        reader.read_exact(&mut payload).await?;
                        Some(payload)
                    } else {
                        None
                    };
                    Ok((header, payload))
                }
            };
            if !__tracing_attr_span.is_disabled() {
                tracing::Instrument::instrument(__tracing_instrument_future, __tracing_attr_span)
                    .await
            } else {
                __tracing_instrument_future.await
            }
        }
        pub fn read_payload<T: Decode>(payload: &[u8]) -> io::Result<Option<T>> {
            let config = bincode::config::standard();
            if !payload.is_empty() {
                let (data, size) = match bincode::decode_from_slice(payload, config) {
                    Ok(data) => data,
                    Err(e) => {
                        #[cfg(debug_assertions)]
                        {
                            use crate::traits::PayloadDebug;
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "event nexsock-protocol/src/protocol.rs:152",
                                            "nexsock_protocol::protocol",
                                            ::tracing::Level::ERROR,
                                            ::tracing_core::__macro_support::Option::Some(
                                                "nexsock-protocol/src/protocol.rs",
                                            ),
                                            ::tracing_core::__macro_support::Option::Some(152u32),
                                            ::tracing_core::__macro_support::Option::Some(
                                                "nexsock_protocol::protocol",
                                            ),
                                            ::tracing_core::field::FieldSet::new(
                                                &["message"],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::EVENT,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let enabled = ::tracing::Level::ERROR
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::ERROR
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        let interest = __CALLSITE.interest();
                                        !interest.is_never()
                                            && ::tracing::__macro_support::__is_enabled(
                                                __CALLSITE.metadata(),
                                                interest,
                                            )
                                    };
                                if enabled {
                                    (|value_set: ::tracing::field::ValueSet| {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                        if match ::tracing::Level::ERROR {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        } <= ::tracing::log::STATIC_MAX_LEVEL
                                        {
                                            if !::tracing::dispatcher::has_been_set() {
                                                {
                                                    use ::tracing::log;
                                                    let level = match ::tracing::Level::ERROR {
                                                        ::tracing::Level::ERROR => {
                                                            ::tracing::log::Level::Error
                                                        }
                                                        ::tracing::Level::WARN => {
                                                            ::tracing::log::Level::Warn
                                                        }
                                                        ::tracing::Level::INFO => {
                                                            ::tracing::log::Level::Info
                                                        }
                                                        ::tracing::Level::DEBUG => {
                                                            ::tracing::log::Level::Debug
                                                        }
                                                        _ => ::tracing::log::Level::Trace,
                                                    };
                                                    if level <= log::max_level() {
                                                        let meta = __CALLSITE.metadata();
                                                        let log_meta = log::Metadata::builder()
                                                            .level(level)
                                                            .target(meta.target())
                                                            .build();
                                                        let logger = log::logger();
                                                        if logger.enabled(&log_meta) {
                                                            ::tracing::__macro_support::__tracing_log(
                                                                meta,
                                                                logger,
                                                                log_meta,
                                                                &value_set,
                                                            )
                                                        }
                                                    }
                                                }
                                            } else {
                                                {}
                                            }
                                        } else {
                                            {}
                                        };
                                    })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                        __CALLSITE.metadata().fields().value_set(&[(
                                            &::tracing::__macro_support::Iterator::next(&mut iter)
                                                .expect("FieldSet corrupted (this is a bug)"),
                                            ::tracing::__macro_support::Option::Some(
                                                &format_args!("{0}", payload.debug_dump())
                                                    as &dyn Value,
                                            ),
                                        )])
                                    });
                                } else {
                                    if match ::tracing::Level::ERROR {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    } <= ::tracing::log::STATIC_MAX_LEVEL
                                    {
                                        if !::tracing::dispatcher::has_been_set() {
                                            {
                                                use ::tracing::log;
                                                let level = match ::tracing::Level::ERROR {
                                                    ::tracing::Level::ERROR => {
                                                        ::tracing::log::Level::Error
                                                    }
                                                    ::tracing::Level::WARN => {
                                                        ::tracing::log::Level::Warn
                                                    }
                                                    ::tracing::Level::INFO => {
                                                        ::tracing::log::Level::Info
                                                    }
                                                    ::tracing::Level::DEBUG => {
                                                        ::tracing::log::Level::Debug
                                                    }
                                                    _ => ::tracing::log::Level::Trace,
                                                };
                                                if level <= log::max_level() {
                                                    let meta = __CALLSITE.metadata();
                                                    let log_meta = log::Metadata::builder()
                                                        .level(level)
                                                        .target(meta.target())
                                                        .build();
                                                    let logger = log::logger();
                                                    if logger.enabled(&log_meta) {
                                                        ::tracing::__macro_support::__tracing_log(
                                                            meta,
                                                            logger,
                                                            log_meta,
                                                            &{
                                                                #[allow(unused_imports)]
                                                                use ::tracing::field::{
                                                                    debug, display, Value,
                                                                };
                                                                let mut iter = __CALLSITE
                                                                    .metadata()
                                                                    .fields()
                                                                    .iter();
                                                                __CALLSITE
                                                                    .metadata()
                                                                    .fields()
                                                                    .value_set(
                                                                        &[
                                                                            (
                                                                                &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                                                ::tracing::__macro_support::Option::Some(
                                                                                    &format_args!("{0}", payload.debug_dump()) as &dyn Value,
                                                                                ),
                                                                            ),
                                                                        ],
                                                                    )
                                                            },
                                                        )
                                                    }
                                                }
                                            }
                                        } else {
                                            {}
                                        }
                                    } else {
                                        {}
                                    };
                                }
                            };
                        }
                        return Err(io::Error::new(io::ErrorKind::InvalidData, e));
                    }
                };
                {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "event nexsock-protocol/src/protocol.rs:158",
                                "nexsock_protocol::protocol",
                                ::tracing::Level::DEBUG,
                                ::tracing_core::__macro_support::Option::Some(
                                    "nexsock-protocol/src/protocol.rs",
                                ),
                                ::tracing_core::__macro_support::Option::Some(158u32),
                                ::tracing_core::__macro_support::Option::Some(
                                    "nexsock_protocol::protocol",
                                ),
                                ::tracing_core::field::FieldSet::new(
                                    &["message"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::EVENT,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let enabled = ::tracing::Level::DEBUG
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && ::tracing::Level::DEBUG
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            let interest = __CALLSITE.interest();
                            !interest.is_never()
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                        };
                    if enabled {
                        (|value_set: ::tracing::field::ValueSet| {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Event::dispatch(meta, &value_set);
                            if match ::tracing::Level::DEBUG {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            } <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match ::tracing::Level::DEBUG {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let meta = __CALLSITE.metadata();
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(meta.target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                ::tracing::__macro_support::__tracing_log(
                                                    meta, logger, log_meta, &value_set,
                                                )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        })({
                            #[allow(unused_imports)]
                            use ::tracing::field::{debug, display, Value};
                            let mut iter = __CALLSITE.metadata().fields().iter();
                            __CALLSITE.metadata().fields().value_set(&[(
                                &::tracing::__macro_support::Iterator::next(&mut iter)
                                    .expect("FieldSet corrupted (this is a bug)"),
                                ::tracing::__macro_support::Option::Some(&format_args!(
                                    "Read payload of size: `{0}`",
                                    size
                                )
                                    as &dyn Value),
                            )])
                        });
                    } else {
                        if match ::tracing::Level::DEBUG {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        } <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    use ::tracing::log;
                                    let level = match ::tracing::Level::DEBUG {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    };
                                    if level <= log::max_level() {
                                        let meta = __CALLSITE.metadata();
                                        let log_meta = log::Metadata::builder()
                                            .level(level)
                                            .target(meta.target())
                                            .build();
                                        let logger = log::logger();
                                        if logger.enabled(&log_meta) {
                                            ::tracing::__macro_support::__tracing_log(
                                                meta,
                                                logger,
                                                log_meta,
                                                &{
                                                    #[allow(unused_imports)]
                                                    use ::tracing::field::{debug, display, Value};
                                                    let mut iter =
                                                        __CALLSITE.metadata().fields().iter();
                                                    __CALLSITE
                                                        .metadata()
                                                        .fields()
                                                        .value_set(
                                                            &[
                                                                (
                                                                    &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                                    ::tracing::__macro_support::Option::Some(
                                                                        &format_args!("Read payload of size: `{0}`", size)
                                                                            as &dyn Value,
                                                                    ),
                                                                ),
                                                            ],
                                                        )
                                                },
                                            )
                                        }
                                    }
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                    }
                };
                Ok(Some(data))
            } else {
                Ok(None)
            }
        }
        fn next_sequence(&mut self) -> u32 {
            let seq = self.sequence;
            self.sequence = self.sequence.wrapping_add(1);
            seq
        }
    }
}
pub mod traits {
    use crate::commands::Command;
    pub trait ServiceCommand {
        type Input;
        type Output;
        const COMMAND: Command;
        fn into_payload(self) -> Self::Input;
    }
    #[cfg(debug_assertions)]
    pub trait PayloadDebug {
        fn debug_dump(&self) -> String;
    }
    #[cfg(debug_assertions)]
    impl PayloadDebug for [u8] {
        fn debug_dump(&self) -> String {
            use std::fmt::Write;
            let mut s = String::new();
            s.write_fmt(format_args!("Payload ({0} bytes): [", self.len()))
                .unwrap();
            for (i, b) in self.iter().enumerate() {
                if i > 0 {
                    s.write_fmt(format_args!(", ")).unwrap();
                }
                s.write_fmt(format_args!("{0:#04x}", b)).unwrap();
            }
            s.write_fmt(format_args!("]")).unwrap();
            s
        }
    }
}
pub fn add(left: u64, right: u64) -> u64 {
    left + right
}
