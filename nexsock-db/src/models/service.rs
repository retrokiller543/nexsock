//! `SeaORM` Entity, @generated by sea-orm-codegen 1.1.7

use crate::error::DatabaseError;
use crate::models::prelude::*;
use derive_more::Display;
use nexsock_protocol::commands::service_status::ServiceState;
use sea_orm::entity::prelude::*;
use sea_orm::sea_query::{ArrayType, ValueType, ValueTypeErr};
use sea_orm::{ColIdx, TryGetError, TryGetable};
use sqlx::Type;

/// Represents a service managed by nexsock.
#[derive(Clone, Debug, PartialEq, DeriveEntityModel, DerivePartialModel, Eq)]
#[sea_orm(table_name = "service")]
#[sea_orm(entity = "Entity")]
pub struct Model {
    /// The unique identifier for the service.
    #[sea_orm(primary_key)]
    pub id: i64,
    /// The foreign key referencing the service's configuration.
    pub config_id: Option<i64>,
    /// The unique name of the service.
    #[sea_orm(column_type = "Text", unique)]
    pub name: String,
    /// The URL of the service's repository.
    #[sea_orm(column_type = "Text")]
    pub repo_url: String,
    /// The port number the service will run on.
    pub port: i64,
    /// The path to the service's repository on the local filesystem.
    #[sea_orm(column_type = "Text")]
    pub repo_path: String,
    /// The current status of the service.
    #[sea_orm(column_type = "Text")]
    pub status: ServiceStatus,
    /// The current Git branch name (if applicable).
    #[sea_orm(column_type = "Text")]
    pub git_branch: Option<String>,
    /// The current Git commit hash (if applicable).
    #[sea_orm(column_type = "Text")]
    pub git_commit_hash: Option<String>,
    /// The Git authentication type used for this service.
    #[sea_orm(column_type = "Text")]
    pub git_auth_type: Option<String>,
}

/// Git-related parameters for service creation.
#[derive(Debug, Clone)]
pub struct GitParams {
    pub branch: Option<String>,
    pub commit_hash: Option<String>,
    pub auth_type: Option<String>,
}

impl Model {
    /// Creates a new `Model` instance.
    ///
    /// # Arguments
    ///
    /// * `name` - The name of the service.
    /// * `repo_url` - The URL of the service's repository.
    /// * `port` - The port number the service will run on.
    /// * `repo_path` - The path to the service's repository on the local filesystem.
    ///
    /// Creates a new service model with the specified basic information and default status `Stopped`.
    ///
    /// # Parameters
    /// - `config_id`: Optional foreign key referencing the service's configuration.
    ///
    /// # Returns
    /// A `Model` instance representing a service with the provided details and no Git metadata.
    ///
    /// # Examples
    ///
    /// ```
    /// let service = Model::new(
    ///     "my-service".to_string(),
    ///     "https://github.com/example/repo.git".to_string(),
    ///     8080,
    ///     "/srv/my-service".to_string(),
    ///     Some(1),
    /// );
    /// assert_eq!(service.status, ServiceStatus::Stopped);
    /// assert_eq!(service.git_branch, None);
    /// ```
    pub fn new(
        name: String,
        repo_url: String,
        port: i64,
        repo_path: String,
        config_id: Option<i64>,
    ) -> Self {
        Self {
            id: 0,
            config_id,
            name,
            repo_url,
            port,
            repo_path,
            status: ServiceStatus::Stopped,
            git_branch: None,
            git_commit_hash: None,
            git_auth_type: None,
        }
    }

    /// Creates a new `Model` instance with Git information.
    ///
    /// # Arguments
    ///
    /// * `name` - The name of the service.
    /// * `repo_url` - The URL of the service's repository.
    /// * `port` - The port number the service will run on.
    /// * `repo_path` - The path to the service's repository on the local filesystem.
    /// * `config_id` - An optional foreign key referencing the service's configuration.
    /// * `git_branch` - The current Git branch name.
    /// * `git_commit_hash` - The current Git commit hash.
    ///
    /// Creates a new `Model` instance with the specified fields, including optional Git metadata.
    ///
    /// Initializes a service with the provided name, repository URL, port, repository path, optional configuration ID, and optional Git branch, commit hash, and authentication type. The service status is set to `Stopped` by default.
    ///
    /// # Examples
    ///
    /// ```
    /// let service = Model::new_with_git(
    ///     "example".to_string(),
    ///     "https://github.com/example/repo.git".to_string(),
    ///     8080,
    ///     "/srv/example".to_string(),
    ///     Some(1),
    ///     GitParams {
    ///         branch: Some("main".to_string()),
    ///         commit_hash: Some("abc123".to_string()),
    ///         auth_type: Some("ssh".to_string()),
    ///     },
    /// );
    /// assert_eq!(service.status, ServiceStatus::Stopped);
    /// ```
    pub fn new_with_git(
        name: String,
        repo_url: String,
        port: i64,
        repo_path: String,
        config_id: Option<i64>,
        git_params: GitParams,
    ) -> Self {
        Self {
            id: 0,
            config_id,
            name,
            repo_url,
            port,
            repo_path,
            status: ServiceStatus::Stopped,
            git_branch: git_params.branch,
            git_commit_hash: git_params.commit_hash,
            git_auth_type: git_params.auth_type,
        }
    }

    /// Converts this `Model` into a `nexsock_protocol::commands::service_status::ServiceStatus`.
    ///
    /// # Arguments
    ///
    /// Converts the service model into a protocol-level `ServiceStatus` struct, including its dependencies.
    ///
    /// # Parameters
    /// - `dependencies`: A vector of joined dependency records to include in the status.
    ///
    /// # Returns
    /// A `ServiceStatus` struct representing the current state and metadata of the service, suitable for protocol communication.
    ///
    /// # Examples
    ///
    /// ```
    /// let model = Model::new("svc".to_string(), "https://repo".to_string(), 8080, "/path".to_string(), None);
    /// let deps = vec![];
    /// let status = model.to_status(deps);
    /// assert_eq!(status.name, "svc");
    /// ```
    pub fn to_status(
        &self,
        dependencies: Vec<JoinedDependency>,
    ) -> nexsock_protocol::commands::service_status::ServiceStatus {
        nexsock_protocol::commands::service_status::ServiceStatus {
            id: self.id,
            name: self.name.clone(),
            state: self.status.into(),
            config: None,
            port: self.port,
            repo_url: self.repo_url.clone(),
            repo_path: self.repo_path.clone(),
            dependencies: dependencies.into_iter().map(|d| d.into()).collect(),
            git_branch: self.git_branch.clone(),
            git_commit_hash: self.git_commit_hash.clone(),
            git_auth_type: self.git_auth_type.clone(),
        }
    }
}

/// Defines the relationships between the `Service` entity and other entities.
#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
    /// Defines a "belongs_to" relationship with the `ServiceConfig` entity.
    #[sea_orm(
        belongs_to = "super::service_config::Entity",
        from = "Column::ConfigId",
        to = "super::service_config::Column::Id",
        on_update = "NoAction",
        on_delete = "NoAction"
    )]
    ServiceConfig,
}

impl Related<super::service_config::Entity> for Entity {
    /// Returns the relation definition for the "belongs to" association with the `service_config` entity.
    ///
    /// # Examples
    ///
    /// ```
    /// let relation_def = Entity::to();
    /// assert_eq!(relation_def.to_string(), "service_config");
    /// ```
    fn to() -> RelationDef {
        Relation::ServiceConfig.def()
    }
}

impl ActiveModelBehavior for ActiveModel {}

/// Represents the possible statuses of a service.
#[derive(Clone, Copy, Default, Debug, Ord, PartialOrd, PartialEq, Eq, Hash, Type, Display)]
pub enum ServiceStatus {
    /// The service is in the process of starting.
    Starting,
    /// The service is currently running.
    Running,
    /// The service is in the process of stopping.
    Stopping,
    /// The service is not running.
    #[default]
    Stopped,
    /// The service has failed to start or has crashed.
    Failed,
}

impl From<ServiceState> for ServiceStatus {
    /// Converts a `ServiceState` from the protocol into the corresponding `ServiceStatus`.
    ///
    /// # Examples
    ///
    /// ```
    /// use crate::{ServiceStatus, ServiceState};
    /// let status = ServiceStatus::from(ServiceState::Running);
    /// assert_eq!(status, ServiceStatus::Running);
    /// ```
    fn from(value: ServiceState) -> Self {
        match value {
            ServiceState::Starting => Self::Starting,
            ServiceState::Running => Self::Running,
            ServiceState::Stopping => Self::Stopping,
            ServiceState::Stopped => Self::Stopped,
            ServiceState::Failed => Self::Failed,
        }
    }
}

impl From<ServiceStatus> for ServiceState {
    /// Converts a `ServiceStatus` into the corresponding `ServiceState`.
    ///
    /// # Examples
    ///
    /// ```
    /// use crate::{ServiceStatus, ServiceState};
    /// let status = ServiceStatus::Running;
    /// let state: ServiceState = ServiceState::from(status);
    /// assert_eq!(state, ServiceState::Running);
    /// ```
    fn from(value: ServiceStatus) -> Self {
        match value {
            ServiceStatus::Starting => Self::Starting,
            ServiceStatus::Running => Self::Running,
            ServiceStatus::Stopping => Self::Stopping,
            ServiceStatus::Stopped => Self::Stopped,
            ServiceStatus::Failed => Self::Failed,
        }
    }
}

impl ValueType for ServiceStatus {
    /// Attempts to convert a database `Value` into a `ServiceStatus`.
    ///
    /// Returns `Ok(ServiceStatus)` if the string value matches a known service status; otherwise, returns `Err(ValueTypeErr)`.
    ///
    /// # Examples
    ///
    /// ```
    /// use sea_orm::Value;
    /// let status = ServiceStatus::try_from(Value::String(Some("Running".to_string())));
    /// assert_eq!(status.unwrap(), ServiceStatus::Running);
    ///
    /// let invalid = ServiceStatus::try_from(Value::String(Some("Unknown".to_string())));
    /// assert!(invalid.is_err());
    /// ```
    fn try_from(v: Value) -> Result<Self, ValueTypeErr> {
        match v {
            Value::String(Some(x)) => match x.as_str() {
                "Starting" => Ok(ServiceStatus::Starting),
                "Running" => Ok(ServiceStatus::Running),
                "Stopping" => Ok(ServiceStatus::Stopping),
                "Stopped" => Ok(ServiceStatus::Stopped),
                "Failed" => Ok(ServiceStatus::Failed),
                _ => Err(ValueTypeErr),
            },
            _ => Err(ValueTypeErr),
        }
    }

    /// Returns the type name as a string for use in database integration.
    ///
    /// # Examples
    ///
    /// ```
    /// let name = type_name();
    /// assert_eq!(name, "ServiceStatus");
    /// ```
    fn type_name() -> String {
        "ServiceStatus".to_string()
    }

    /// This specifies that `ServiceStatus` is represented as an array of strings in the database.
    fn array_type() -> ArrayType {
        ArrayType::String
    }

    /// Returns the database column type used to store the enum as an unbounded string.
    fn column_type() -> ColumnType {
        ColumnType::String(StringLen::None)
    }
}

impl From<ServiceStatus> for Value {
    /// Converts a `ServiceStatus` enum variant into a `Value::String` for database storage.
    ///
    /// The resulting string represents the name of the status variant.
    fn from(state: ServiceStatus) -> Self {
        Value::String(Some(Box::new(state.to_string())))
    }
}

impl TryGetable for ServiceStatus {
    /// Attempts to extract a `ServiceStatus` enum from a database query result by matching a string value.
    ///
    /// Returns an error if the value does not correspond to a known `ServiceStatus` variant.
    ///
    /// # Errors
    ///
    /// Returns a `TryGetError` if the database value is not a valid `ServiceStatus` string.
    ///
    /// # Examples
    ///
    /// ```
    /// use sea_orm::QueryResult;
    /// // Assume `res` is a QueryResult with a valid ServiceStatus string at column 0
    /// let status = ServiceStatus::try_get_by(&res, 0)?;
    /// assert!(matches!(status, ServiceStatus::Running | ServiceStatus::Stopped | ServiceStatus::Starting | ServiceStatus::Stopping | ServiceStatus::Failed));
    /// ```
    fn try_get_by<I: ColIdx>(res: &QueryResult, index: I) -> Result<Self, TryGetError> {
        let val: String = res.try_get_by(index)?;

        match val.as_str() {
            "Starting" => Ok(ServiceStatus::Starting),
            "Running" => Ok(ServiceStatus::Running),
            "Stopping" => Ok(ServiceStatus::Stopping),
            "Stopped" => Ok(ServiceStatus::Stopped),
            "Failed" => Ok(ServiceStatus::Failed),
            unknown => Err(TryGetError::DbErr(sea_orm::DbErr::TryIntoErr {
                from: "String",
                into: "ServiceStatus",
                source: Box::new(DatabaseError::UnknownEnumValue {
                    expected: "Starting, Running, Stopping, Stopped, Failed".to_string(),
                    value: unknown.to_string(),
                    enum_name: "ServiceStatus".to_string(),
                }),
            })),
        }
    }
}
