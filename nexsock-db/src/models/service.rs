//! `SeaORM` Entity, @generated by sea-orm-codegen 1.1.7

use derive_more::Display;
use nexsock_protocol::commands::service_status::ServiceState;
use sea_orm::entity::prelude::*;
use sea_orm::sea_query::{ArrayType, ValueType, ValueTypeErr};
use sea_orm::{ColIdx, TryGetError, TryGetable};
use sqlx::Type;

use crate::models::prelude::*;

#[derive(Clone, Debug, PartialEq, DeriveEntityModel, DerivePartialModel, Eq)]
#[sea_orm(table_name = "service")]
#[sea_orm(entity = "Entity")]
pub struct Model {
    #[sea_orm(primary_key)]
    pub id: i64,
    pub config_id: Option<i64>,
    #[sea_orm(column_type = "Text", unique)]
    pub name: String,
    #[sea_orm(column_type = "Text")]
    pub repo_url: String,
    pub port: i64,
    #[sea_orm(column_type = "Text")]
    pub repo_path: String,
    #[sea_orm(column_type = "Text")]
    pub status: ServiceStatus,
}

impl Model {
    pub fn new(
        name: String,
        repo_url: String,
        port: i64,
        repo_path: String,
        config_id: Option<i64>,
    ) -> Self {
        Self {
            id: 0,
            config_id,
            name,
            repo_url,
            port,
            repo_path,
            status: ServiceStatus::Stopped,
        }
    }

    pub fn to_status(
        &self,
        dependencies: Vec<JoinedDependency>,
    ) -> nexsock_protocol::commands::service_status::ServiceStatus {
        nexsock_protocol::commands::service_status::ServiceStatus {
            id: self.id,
            name: self.name.clone(),
            state: self.status.into(),
            config_id: self.config_id,
            port: self.port,
            repo_url: self.repo_url.clone(),
            repo_path: self.repo_path.clone(),
            dependencies: dependencies.into_iter().map(|d| d.into()).collect(),
        }
    }
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
    #[sea_orm(
        belongs_to = "super::service_config::Entity",
        from = "Column::ConfigId",
        to = "super::service_config::Column::Id",
        on_update = "NoAction",
        on_delete = "NoAction"
    )]
    ServiceConfig,
}

impl Related<super::service_config::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::ServiceConfig.def()
    }
}

impl ActiveModelBehavior for ActiveModel {}

#[derive(Clone, Copy, Default, Debug, Ord, PartialOrd, PartialEq, Eq, Hash, Type, Display)]
pub enum ServiceStatus {
    Starting,
    Running,
    Stopping,
    #[default]
    Stopped,
    Failed,
}

impl From<ServiceState> for ServiceStatus {
    fn from(value: ServiceState) -> Self {
        match value {
            ServiceState::Starting => Self::Starting,
            ServiceState::Running => Self::Running,
            ServiceState::Stopping => Self::Stopping,
            ServiceState::Stopped => Self::Stopped,
            ServiceState::Failed => Self::Failed,
        }
    }
}

impl From<ServiceStatus> for ServiceState {
    fn from(value: ServiceStatus) -> Self {
        match value {
            ServiceStatus::Starting => Self::Starting,
            ServiceStatus::Running => Self::Running,
            ServiceStatus::Stopping => Self::Stopping,
            ServiceStatus::Stopped => Self::Stopped,
            ServiceStatus::Failed => Self::Failed,
        }
    }
}

impl ValueType for ServiceStatus {
    fn try_from(v: Value) -> Result<Self, ValueTypeErr> {
        match v {
            Value::String(Some(x)) => match x.as_str() {
                "Starting" => Ok(ServiceStatus::Starting),
                "Running" => Ok(ServiceStatus::Running),
                "Stopping" => Ok(ServiceStatus::Stopping),
                "Stopped" => Ok(ServiceStatus::Stopped),
                "Failed" => Ok(ServiceStatus::Failed),
                _ => Err(ValueTypeErr),
            },
            _ => Err(ValueTypeErr),
        }
    }

    fn type_name() -> String {
        "ServiceStatus".to_string()
    }

    fn array_type() -> ArrayType {
        ArrayType::String
    }

    fn column_type() -> ColumnType {
        ColumnType::String(StringLen::None)
    }
}

impl From<ServiceStatus> for Value {
    fn from(state: ServiceStatus) -> Self {
        Value::String(Some(Box::new(state.to_string())))
    }
}

impl TryGetable for ServiceStatus {
    fn try_get_by<I: ColIdx>(res: &QueryResult, index: I) -> Result<Self, TryGetError> {
        let val: String = res.try_get_by(index)?;

        match val.as_str() {
            "Starting" => Ok(ServiceStatus::Starting),
            "Running" => Ok(ServiceStatus::Running),
            "Stopping" => Ok(ServiceStatus::Stopping),
            "Stopped" => Ok(ServiceStatus::Stopped),
            "Failed" => Ok(ServiceStatus::Failed),
            _ => Ok(ServiceStatus::Stopped), // Default fallback
        }
    }
}
