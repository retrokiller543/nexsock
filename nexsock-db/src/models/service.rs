//! `SeaORM` Entity, @generated by sea-orm-codegen 1.1.7

use derive_more::Display;
use nexsock_protocol::commands::service_status::ServiceState;
use sea_orm::entity::prelude::*;
use sea_orm::sea_query::{ArrayType, ValueType, ValueTypeErr};
use sea_orm::{ColIdx, TryGetError, TryGetable};
use sqlx::Type;
use crate::error::DatabaseError;
use crate::models::prelude::*;

/// Represents a service managed by nexsock.
#[derive(Clone, Debug, PartialEq, DeriveEntityModel, DerivePartialModel, Eq)]
#[sea_orm(table_name = "service")]
#[sea_orm(entity = "Entity")]
pub struct Model {
    /// The unique identifier for the service.
    #[sea_orm(primary_key)]
    pub id: i64,
    /// The foreign key referencing the service's configuration.
    pub config_id: Option<i64>,
    /// The unique name of the service.
    #[sea_orm(column_type = "Text", unique)]
    pub name: String,
    /// The URL of the service's repository.
    #[sea_orm(column_type = "Text")]
    pub repo_url: String,
    /// The port number the service will run on.
    pub port: i64,
    /// The path to the service's repository on the local filesystem.
    #[sea_orm(column_type = "Text")]
    pub repo_path: String,
    /// The current status of the service.
    #[sea_orm(column_type = "Text")]
    pub status: ServiceStatus,
}

impl Model {
    /// Creates a new `Model` instance.
    ///
    /// # Arguments
    ///
    /// * `name` - The name of the service.
    /// * `repo_url` - The URL of the service's repository.
    /// * `port` - The port number the service will run on.
    /// * `repo_path` - The path to the service's repository on the local filesystem.
    /// * `config_id` - An optional foreign key referencing the service's configuration.
    pub fn new(
        name: String,
        repo_url: String,
        port: i64,
        repo_path: String,
        config_id: Option<i64>,
    ) -> Self {
        Self {
            id: 0,
            config_id,
            name,
            repo_url,
            port,
            repo_path,
            status: ServiceStatus::Stopped,
        }
    }

    /// Converts this `Model` into a `nexsock_protocol::commands::service_status::ServiceStatus`.
    ///
    /// # Arguments
    ///
    /// * `dependencies` - A vector of `JoinedDependency` instances representing the service's dependencies.
    pub fn to_status(
        &self,
        dependencies: Vec<JoinedDependency>,
    ) -> nexsock_protocol::commands::service_status::ServiceStatus {
        nexsock_protocol::commands::service_status::ServiceStatus {
            id: self.id,
            name: self.name.clone(),
            state: self.status.into(),
            config: None,
            port: self.port,
            repo_url: self.repo_url.clone(),
            repo_path: self.repo_path.clone(),
            dependencies: dependencies.into_iter().map(|d| d.into()).collect(),
        }
    }
}

/// Defines the relationships between the `Service` entity and other entities.
#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
    /// Defines a "belongs_to" relationship with the `ServiceConfig` entity.
    #[sea_orm(
        belongs_to = "super::service_config::Entity",
        from = "Column::ConfigId",
        to = "super::service_config::Column::Id",
        on_update = "NoAction",
        on_delete = "NoAction"
    )]
    ServiceConfig,
}

impl Related<super::service_config::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::ServiceConfig.def()
    }
}

impl ActiveModelBehavior for ActiveModel {}

/// Represents the possible statuses of a service.
#[derive(Clone, Copy, Default, Debug, Ord, PartialOrd, PartialEq, Eq, Hash, Type, Display)]
pub enum ServiceStatus {
    /// The service is in the process of starting.
    Starting,
    /// The service is currently running.
    Running,
    /// The service is in the process of stopping.
    Stopping,
    /// The service is not running.
    #[default]
    Stopped,
    /// The service has failed to start or has crashed.
    Failed,
}

impl From<ServiceState> for ServiceStatus {
    fn from(value: ServiceState) -> Self {
        match value {
            ServiceState::Starting => Self::Starting,
            ServiceState::Running => Self::Running,
            ServiceState::Stopping => Self::Stopping,
            ServiceState::Stopped => Self::Stopped,
            ServiceState::Failed => Self::Failed,
        }
    }
}

impl From<ServiceStatus> for ServiceState {
    fn from(value: ServiceStatus) -> Self {
        match value {
            ServiceStatus::Starting => Self::Starting,
            ServiceStatus::Running => Self::Running,
            ServiceStatus::Stopping => Self::Stopping,
            ServiceStatus::Stopped => Self::Stopped,
            ServiceStatus::Failed => Self::Failed,
        }
    }
}

impl ValueType for ServiceStatus {
    fn try_from(v: Value) -> Result<Self, ValueTypeErr> {
        match v {
            Value::String(Some(x)) => match x.as_str() {
                "Starting" => Ok(ServiceStatus::Starting),
                "Running" => Ok(ServiceStatus::Running),
                "Stopping" => Ok(ServiceStatus::Stopping),
                "Stopped" => Ok(ServiceStatus::Stopped),
                "Failed" => Ok(ServiceStatus::Failed),
                _ => Err(ValueTypeErr),
            },
            _ => Err(ValueTypeErr),
        }
    }

    fn type_name() -> String {
        "ServiceStatus".to_string()
    }

    fn array_type() -> ArrayType {
        ArrayType::String
    }

    fn column_type() -> ColumnType {
        ColumnType::String(StringLen::None)
    }
}

impl From<ServiceStatus> for Value {
    fn from(state: ServiceStatus) -> Self {
        Value::String(Some(Box::new(state.to_string())))
    }
}

impl TryGetable for ServiceStatus {
    fn try_get_by<I: ColIdx>(res: &QueryResult, index: I) -> Result<Self, TryGetError> {
        let val: String = res.try_get_by(index)?;

        match val.as_str() {
            "Starting" => Ok(ServiceStatus::Starting),
            "Running" => Ok(ServiceStatus::Running),
            "Stopping" => Ok(ServiceStatus::Stopping),
            "Stopped" => Ok(ServiceStatus::Stopped),
            "Failed" => Ok(ServiceStatus::Failed),
            unknown => Err(TryGetError::DbErr(sea_orm::DbErr::TryIntoErr {
                from: "String",
                into: "ServiceStatus",
                source: Box::new(DatabaseError::UnknownEnumValue {
                    expected: "Starting, Running, Stopping, Stopped, Failed".to_string(),
                    value: unknown.to_string(),
                    enum_name: "ServiceStatus".to_string(),
                }),
            })),
        }
    }
}
